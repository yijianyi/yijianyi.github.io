[{"title":"CPP控制程序流程(下)","url":"/2026/01/02/CPP%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B-%E4%B8%8B/","content":"这一节来介绍C++中的循环语句。假设你要打印100次&quot;Hello World&quot;，按照前面的方法，就是写100次cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;，这种操作费时费力，这时候就可以使用循环，它可以用几行代码完成重复性工作，让代码更简洁。\ngoto\ngoto语句是C++中最原始的控制流语句，现在的编程中几乎很难看到它的身影，也不推荐在程序中使用它，但是还是作为了解。\n#include &lt;iostream&gt;using namespace std;int main() &#123;    int count = 1;    start_loop:  // 这是一个标签    cout &lt;&lt; &quot;当前计数: &quot; &lt;&lt; count &lt;&lt; endl;    count++;        if (count &lt;= 5) &#123;        goto start_loop;  // 跳转回标签处    &#125;        cout &lt;&lt; &quot;循环结束！&quot; &lt;&lt; endl;    return 0;&#125;\n可以看到goto的用法就是跳转到标签处，循环只是它的一个用法，也可以用来跳过某些语句。\n现在的程序中，只有在一些特殊情况下需要跳出多层嵌套循环时才有可能使用。\nwhile循环\nwhile循环适合用在不确定循环次数，但是知道循环继续的条件的情况下，它的特点是先判断，后执行。基本语法是\nwhile (条件表达式) &#123;    // 循环体&#125;\n下面是一个求和的示例代码：\n#include &lt;iostream&gt;using namespace std;int main() &#123;    int i = 1;        // 计算1到10的和    int sum = 0;    while (i &lt;= 10) &#123;        sum += i;        cout &lt;&lt; &quot;加上 &quot; &lt;&lt; i &lt;&lt; &quot;，当前和为: &quot; &lt;&lt; sum &lt;&lt; endl;        i++;  // 别忘了递增，否则会死循环！    &#125;        cout &lt;&lt; &quot;1到10的总和是: &quot; &lt;&lt; sum &lt;&lt; endl;    return 0;&#125;\n在代码中，while会先判断后面的表达式是否为真(true)，为真就会进入循环体，且每运行完一次循环体，while又会在判断一下表达式的值，直到表达式的值为假(false)，就不再执行循环体。\n\n在编写循环体时，要确保条件可以变为false。\n\ndo…while\ndo...while与while循环类似，但是它的特点是先执行，后循环。这也就代表着循环体至少会被执行一次。基本语法是\ndo &#123;    // 循环体&#125; while (条件表达式);\n下面是一个模拟ATM的示例代码\n#include &lt;iostream&gt;using namespace std;int main() &#123;    char choice;        do &#123;        cout &lt;&lt; &quot;===== 菜单 =====&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;1. 查看余额&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;2. 转账&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;3. 退出&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;请选择 (1-3): &quot;;        cin &gt;&gt; choice;                switch(choice) &#123;            case &#x27;1&#x27;:                cout &lt;&lt; &quot;您的余额是: $1000.00&quot; &lt;&lt; endl;                break;            case &#x27;2&#x27;:                cout &lt;&lt; &quot;转账功能暂未开放&quot; &lt;&lt; endl;                break;            case &#x27;3&#x27;:                cout &lt;&lt; &quot;感谢使用，再见！&quot; &lt;&lt; endl;                break;            default:                cout &lt;&lt; &quot;无效选择，请重新输入！&quot; &lt;&lt; endl;        &#125;        cout &lt;&lt; endl;    &#125; while (choice != &#x27;3&#x27;);  // 当用户选择3时退出循环        return 0;&#125;\n可以看到，无论如何，ATM都要先执行一次循环体，然后直到用户选择3时，程序才能退出。由于无论如何都要先执行一次循环体，因此适合使用do...while\n\n适合在用户交互系统使用\n\nfor\nfor循环是C++中最常用的，功能最强大的循环。它将初始化、条件判断和迭代更新三个部分集中在一个语句中，让代码更加清晰。基本语法是\nfor (初始化; 条件表达式; 迭代更新) &#123;    // 循环体&#125;\n下面是for循环的几种常见的用法的示例代码\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    // 示例1：简单的计数循环    cout &lt;&lt; &quot;=== 乘法表 ===&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= 9; i++) &#123;        for (int j = 1; j &lt;= 9; j++) &#123;            cout &lt;&lt; i &lt;&lt; &quot;*&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; i*j &lt;&lt; &quot;\\t&quot;;        &#125;        cout &lt;&lt; endl;    &#125;        // 示例2：遍历容器    cout &lt;&lt; &quot;\\n=== 遍历vector ===&quot; &lt;&lt; endl;    vector&lt;string&gt; fruits = &#123;&quot;苹果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;, &quot;葡萄&quot;&#125;;        // 传统for循环    for (int i = 0; i &lt; fruits.size(); i++) &#123;        cout &lt;&lt; &quot;索引 &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; fruits[i] &lt;&lt; endl;    &#125;        // C++11及以后的范围for循环（更简洁！）    cout &lt;&lt; &quot;\\n使用范围for循环:&quot; &lt;&lt; endl;    for (const auto&amp; fruit : fruits) &#123;        cout &lt;&lt; &quot;水果: &quot; &lt;&lt; fruit &lt;&lt; endl;    &#125;        return 0;&#125;\n从上面的示例可以看出，在需要固定的循环次数时，优先选择for循环\n\n\n\n在for循环中定义的变量(int i)只在循环内部生效\n\n\nfor循环中，括号里的三个部分都可以为空，但是分号不能省略，也就是for(;;)，它的作用相当于while(true)，是个死循环\n\n\n示例中的最后一种方法是遍历容器的最佳实践\n\n\n在遍历容器时，不要在循环体内修改容器的大小，这可能导致未定义行为(容器后面会讲)\n\n\n\n循环控制语句\nbreak\n立即终止当前循环，跳出循环体。\n#include &lt;iostream&gt;using namespace std;int main() &#123;    cout &lt;&lt; &quot;寻找第一个能被7整除的数:&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= 100; i++) &#123;        if (i % 7 == 0) &#123;            cout &lt;&lt; &quot;找到: &quot; &lt;&lt; i &lt;&lt; endl;            break;  // 找到后立即退出循环        &#125;    &#125;    return 0;&#125;\ncontinue\n跳过当前迭代，直接进入下一次循环。\n#include &lt;iostream&gt;using namespace std;int main() &#123;    cout &lt;&lt; &quot;打印1-20之间的奇数:&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= 20; i++) &#123;        if (i % 2 == 0) &#123;            continue;  // 跳过偶数        &#125;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n最佳实践\n\n\n优先使用for循环\n\n\n循环的嵌套最好不要超过3层\n\n\n操作数组时务必确保不会发生数组越界\n\n\n由于浮点数存在精度问题，最好不要在循环的表达式中比较浮点数，如果一定要比较，最好是判断浮点数是否在目标的极小的范围内(比如判断是a否等于0.3时可以这样写a&gt;=0.29 &amp;&amp; a&lt;=0.31)\n\n\n","categories":["C++"],"tags":["C++"]},{"title":"CPP指针","url":"/2026/01/03/CPP%E6%8C%87%E9%92%88/","content":"如果要概括 C/C++ 与其他高级语言之间最显著的区别，那么显式指针机制无疑是其核心特征之一。与大多数现代高级语言不同，C/C++ 将指针作为一等语言特性直接暴露给程序员，使得程序能够对内存进行精细而直接的控制。这种设计使 C/C++ 在系统级开发、性能敏感场景以及底层资源管理方面具备显著优势。然而，正是由于指针允许直接操作内存，一旦使用不当，极易引发诸如内存越界、悬垂指针和内存泄漏等严重问题，从而增加了程序的不确定性和调试难度。\n指针\n什么是指针\n指针是一个变量，但它存储的不是普通数据，而是另一个变量的内存地址，它也占用内存空间。如图所示，可以看到地址为0x1010的地方是一个指针变量，存储的是0x31FF,这个值被解读为内存地址，因此指向了另一个内存单元。\n声明与使用\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 6;    //声明一个指向a的指针    int* aPointer = &amp;a;    double b = 3.14;    //声明一个指向b的指针    double* bPointer;    bPointer = &amp;b;    //使用指针输出地址和变量值    cout &lt;&lt; &quot;a的地址是：&quot; &lt;&lt; hex &lt;&lt; aPointer &lt;&lt; endl;    cout &lt;&lt; &quot;a的值是：&quot; &lt;&lt; dec &lt;&lt; *aPointer &lt;&lt; endl;    cout &lt;&lt; &quot;b的地址是：&quot; &lt;&lt; hex &lt;&lt; bPointer &lt;&lt; endl;    cout &lt;&lt; &quot;b的值是：&quot; &lt;&lt; dec &lt;&lt; *bPointer &lt;&lt; endl;    return 0;&#125;\n运行结果为\na的地址是：0x6f347ffa0ca的值是：6b的地址是：0x6f347ffa00b的值是：3.14\n可以看到，在声明指针时，要在对应的变量类型后面加上*，比如int*是指向int类型变量的指针，不能混用。要想让指针指向对应的变量，要使用取地址运算符&amp;，代码中的&amp;a表示变量a的地址。在指针变量的前面加上解引用运算符*就可以根据地址，访问并操作地址中存储的对象本身，也就是操作*aPointer就相当于操作变量a。\n需要注意的是，指针可以改变指向，下面的操作是完全可行的。\nint a,b;int* pointer = &amp;a;pointer = &amp;b;\n野指针\n如果代码这样写int* p;，这时，指针p没有指向任何变量，这样的指针叫做野指针。但是这样的操作很危险，野指针并不是不指向内存，而是不知道指向了内存的哪个位置，如果在代码中没有赋值就使用了野指针，可能会操作到危险的，不应该被修改的内存。\n为了避免这样的问题，指针在声明时一定要初始化，在使用指针前也要对指针进行判断，看指针是否指向了明确的变量，用这两个方法来保证程序的安全性。\n空指针\n如果在声明指针时，还不知道要指向哪个变量，就可以将它初始化为空指针(nullptr)。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明指针，并初始化为空指针    int* p = nullptr;    //在使用指针前，要先判断是否为空指针    if(p == nullptr)    &#123;        cout &lt;&lt; &quot;p是空指针，不能解引用&quot; &lt;&lt; endl;        return 0;    &#125;else    &#123;        cout &lt;&lt; &quot;*p = &quot; &lt;&lt; *p &lt;&lt; endl;    &#125;    return 0;&#125;\nsizeof\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 3;    int* aPointer = &amp;a;    double b = 3.14;    double* bPointer = &amp;b;    char c = &#x27;a&#x27;;    char* cPointer = &amp;c;    cout &lt;&lt; &quot;sizeof(a) = &quot; &lt;&lt; sizeof(a) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(*aPointer) = &quot; &lt;&lt; sizeof(*aPointer) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(aPointer) = &quot; &lt;&lt; sizeof(aPointer) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(b) = &quot; &lt;&lt; sizeof(b) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(*bPointer) = &quot; &lt;&lt; sizeof(*bPointer) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(bPointer) = &quot; &lt;&lt; sizeof(bPointer) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(c) = &quot; &lt;&lt; sizeof(c) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(*cPointer) = &quot; &lt;&lt; sizeof(*cPointer) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(cPointer) = &quot; &lt;&lt; sizeof(cPointer) &lt;&lt; endl;    return 0;&#125;\n运行结果为\nsizeof(a) = 4sizeof(*aPointer) = 4sizeof(aPointer) = 8sizeof(b) = 8sizeof(*bPointer) = 8sizeof(bPointer) = 8sizeof(c) = 1sizeof(*cPointer) = 1sizeof(cPointer) = 8\n可以看到解引用后的指针的大小与数据的大小相同，而所有的指针的大小都是8，也就是说指针的大小与变量的类型无关。\n\n这里指针的大小为8字节并不意味着所有的计算机上的指针的大小都为8，这里只能说明指针的大小与变量的类型无关。\n\n数组\n在C++中，数组与指针关系密切但并不等价。\n\n\n数组不是指针\n\n\n数组在大多数表达式中会退化为指向首元素的指针\n\n\n指针可以模拟数组访问，但数组本身有着更强的类型信息\n\n\n大小\nint a[5] = &#123;0&#125;;int* p = nullptr;cout &lt;&lt; sizeof(a) &lt;&lt; endl;  //结果为 5*sizeof(int)cout &lt;&lt; sizeof(p) &lt;&lt; endl;  //结果为8\n上面的结果可以看出，对数组和指针使用sizeof运算符，会得到不一样的结果，说明数组本身有着大小这一属性，而退化为指针后会失去这一属性\n取地址运算符\n如果对数组a取地址，则\n&amp;a          // 会得到a整个数组对象的地址,类型为 int (*)[5],也就是数组指针&amp;a + 1      // 跳过整个数组\n赋值\n可以将数组赋值给指针，但是不能将指针赋值给数组，也就是说p = a是正确的，但是a = p;是错误的。\n\n将数组赋值给指针，会导致数组退化为指针\n\n退化为指针\n当数组被赋值给指针时会退化为指针\nint a[5];int* p = a;   // a 退化为 &amp;a[0]\n上面这段代码等价于int* p = &amp;a[0];\n数组指针与指针数组\n数组指针与指针数组是容易被混淆的两个词。\n数组指针\n数组指针是指向数组的指针，这种情况下，指针认为整个数组是一种变量类型。在下面的例子中，指针p认为自己对应的变量类型是int [5]\nint (*p)[5] = &amp;a;\n指针数组\n指针数组是一个全是指针的数组\nint* p[5];\n这种情况下，p是一个数组，其中p[0],p[1],p[2],p[3],p[4]都是int*类型的指针。\n指针的计算\n指针的自增、自减以及加法运算并不是对“地址数值”的随意操作，而是以指针所指向类型为单位进行的地址偏移。\n自增自减运算符\n可以看到，使用自增自减就像让数组的索引+1-1一样。\nint a[5] = &#123;1, 2, 3, 4, 5&#125;;int* p = a;p++;    // 指向 a[1]p--;    // 回到 a[0]\n加法\n对指针来说，减法也是可以使用的，但是一般不会使用，所以只对加法进行说明，减法与加法同理。\nint a[10];int* p = a;int* q = p + 3;   // 指向 a[3]\n可以看到指针+n相当于a[n]\n\n对于不同类型的指针，移动一步的内存大小也不同，这保证了每走一步都能访问到一个正确的完整的元素。\n\n数组指针与普通指针的区别\nint (*p)[5] = &amp;a;\n以上面这个数组指针为例，如果运行代码p++，那么p跨过的内存则不只是一个sizeof(int)，而是$5 \\times sizeof(int)$，也就是直接跨过了整个数组。\n动态内存分配\n在数组那一节，我们介绍了C++提供的动态数组vector，在这一节，我们可以自己手动创建一个自己的动态数组。\nnew和delete\nnew的作用是分配内存，如果分配成功，就会返回一个指针表示分配的内存的起始地址。delete的作用则是释放内存。\n\n用new创建的指针一定要通过delete释放，否则会导致内存泄漏\n\n如果new分配的内存没有通过delete释放，这块被分配的内存会一直被占用，导致其他变量无法使用这块内存，这就是内存泄露。\n\n学习C++时，忘记delete释放内存是很常见的事，但是不用担心，程序在运行结束后，所有内存都会被释放，因此不会导致计算机内存越来越少。但如果是服务器，它的代码需要一刻不停的运行，如果停止就会导致巨大的损失，这种情况下，内存泄漏会导致服务器的内存不断变小，最后导致崩溃。\n\nnew和delete的用法如下\nint* p1 = new int;   //得到一个指向整数类型变量的指针int* p2 = new int[10]; //得到一个指向10个整数类型变量的内存块的首地址的指针delete p1;  //释放p1delete[] p2;//释放p2,因为p2是指向多个元素的指针\n\n使用 delete 释放动态内存时，传入的指针必须是最初由 new 返回的指针值，即指向该动态对象起始地址的指针。如果在使用过程中对指针进行了算术运算或重定位，使其不再指向原始分配位置，那么对该指针调用 delete 将导致未定义行为，内存释放不会被正确执行。\n\n\n当同一块动态内存存在多个指针副本指向时，只需要、也只能通过其中一个指针执行一次 delete 操作；其余指针在释放后将成为悬垂指针，必须避免再次使用或重复释放。\n\nconst\n如果要用const修饰指针，会发生三种情况:\n\n\nconst int* p\n\n\nint* const p\n\n\nconst int* const p\n\n\n这三种语句都是符合语法的，那么他们的区别是什么呢？\n这里我讲述我的记忆方法，我们可以将上面的情况改写为\n(const) int *(const) p;\n其中，()表示这个地方是个可选项。根据拆分，可以看到第一个const距离int更近，第二个const距离*更近，因此可以这样理解，第一个const用来控制所指向的那个地址的变量不能被修改，也就是int类型的变量不能被修改，第二个const则用来控制存储地址的这个空间不能被修改，也就是只能指向固定的地址。\n根据上面的记忆方法，三种情况就很好理解了。第一种情况保证不能修改*p的值，也就是不能给*p赋值；第二种情况保证不能修改p的值，也就是不能给p赋值；第三中情况是最严格的，既不能修改p的值，也不能修改*p的值。\n动态数组的实现\n#include &lt;iostream&gt;// 创建动态数组int* createArray(int size) &#123;    int* arr = new int[size]; // 分配动态数组    return arr;&#125;// 释放动态数组void deleteArray(int* arr) &#123;    delete[] arr;             // 释放动态数组&#125;// 设置数组元素void setValue(int* arr, int index, int value) &#123;    arr[index] = value;       // 可以用指针运算 *(arr + index) = value;&#125;// 获取数组元素int getValue(int* arr, int index) &#123;    return arr[index];        // 或 *(arr + index)&#125;// 演示函数int main() &#123;    int n = 5;    // 创建动态数组    int* myArray = createArray(n);    // 给数组赋值    for (int i = 0; i &lt; n; ++i) &#123;        setValue(myArray, i, i * 10);    &#125;    // 输出数组元素    std::cout &lt;&lt; &quot;数组元素: &quot;;    for (int i = 0; i &lt; n; ++i) &#123;        std::cout &lt;&lt; getValue(myArray, i) &lt;&lt; &quot; &quot;;    &#125;    std::cout &lt;&lt; std::endl;    // 释放内存    deleteArray(myArray);    return 0;&#125;\n这是一个使用new和delete实现简单动态数组的示例代码，在学习了类之后，可以自己尝试将其修改为动态数组类。\n引用\n在上一节函数中，我们讲到了按引用传递参数的方式，那里的引用与这里的引用是一致的。\n引用在声明时，必须进行初始化，让它引用一个变量，引用一旦绑定，不能重新绑定到其他变量。语法为\nint a = 5;int&amp; b = a; //b是a的引用b = 4;cout &lt;&lt; &quot;a=&quot; &lt;&lt; a &lt;&lt; endl; //结果为4，因为引用相当于是别名，修改b的值会导致a的值也被修改。//如果执行下面这行代码，将会报错，因为引用不能被修改// int c = 3; b = c;\nconst\n如果禁止通过引用修改被引用变量的值，可以使用const\nint a = 5;const int&amp; b = a;//如果运行下面的代码，将会报错// b = 4;","categories":["C++"],"tags":["C++"]},{"title":"CPP数组与字符串","url":"/2025/12/31/CPP%E6%95%B0%E7%BB%84/","content":"静态数组\n如果有5个类型相同，意义相近的变量，你可以用下列代码进行声明。\nint firstNum, secondNum, thirdNum, fourthNum, fifthNum;\n但是如果是100个变量，这样写的效率就极低了，此时我们可以使用数组对这些变量进行存储。\n声明和初始化\n数组的声明语法与变量类似，区别只是多了个[]用来表示要存储多少个变量。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明一个能存储5个整数类型变量的数组    int array1[5];    //声明并初始化数组    char array2[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    //声明并初始化数组    char array3[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    return 0;&#125;\n上面的代码中，array1是能存储5个int类型的变量的数组，array2是能存储5个char类型变量的数组，并且array2通过{}和,的方式进行了初始化。array3在初始化时给出了数组里的所有元素，所以编译器自动推导了数组的长度，此时[]可以不写元素的数量。\n数组的初始化就是在{}里面，用,把每个变量的值隔开。\n\n虽然都是存储5个变量，但是array1占用的空间是$5 \\times sizeof(int)$，array2占用的空间是$5 \\times sizeof(char)$\n\n\n[]里面的数必须是整数\n\n访问数组元素\n访问数组中的某个元素，就是在[]中填入元素的索引。注意：数组的索引从0开始。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化数组    char array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    cout &lt;&lt; array1[0] &lt;&lt; array1[1] &lt;&lt; endl;    char ch1 = array1[4];    cout &lt;&lt; ch1 &lt;&lt; endl;    char ch2 = array1[5];    cout &lt;&lt; ch2 &lt;&lt; endl;    return 0;&#125;\n上面的代码的运行结果是\nabz\n可以看到array1[0]输出的结果是第一个元素a，array1[1]输出的结果是第二个元素b。这也证明了刚才所说的：数组的索引从0开始。\n在示例代码中，数组索引的取值范围是0-4，而ch2尝试读取索引为5的数组元素，运行结果是什么也没有显示。这种访问或修改数组索引范围之外的操作叫做数组越界。\n数组越界在C++中是未定义的行为，未定义的意思就是：C++没有规定如果出现了这种情况该怎么做。因此当程序中不小心出现了数组越界的问题，他导致的后果可能并不相同，这是由编译器决定的。导致的后果包括但不限于：\n\n\n程序报错\n\n\n输出一个垃圾值\n\n\n程序崩溃\n\n\n修改数组元素\n修改数组元素的方法与修改变量的值也类似。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化数组    char array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    cout &lt;&lt; array1[0] &lt;&lt; endl;    array1[0] = &#x27;d&#x27;;    cout &lt;&lt; array1[0] &lt;&lt; endl;    return 0;&#125;\n运行结果为\nad\n可以看到array1[0]存储的值已经被更改了。\n通过上面的代码不难看出，对数组的操作与对变量的操作是类似的，只不过需要加上一个包含索引值的[]来表示你要对数组中的哪个元素进行操作。\n数组的存储\n在程序中创建一个数组时，需要指定数组的长度(长度是数组中元素的个数)，编译时，计算机会将一个连续的空间分配给这个数组，比如下面这行代码。\nchar array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;\n运行后，数组在内存中的结构如下图所示 \n假设这个数组的首地址(地址可以理解为内存的门牌号)为0x01(0x表示后面的数字是十六进制)，可以看到’a’的起始地址为0x01，'b’的起始地址为0x02，这是因为char类型只占1字节。\n在这张图片中，不难发现五个元素的地址是紧挨着的。这是因为数组是由计算机分配的连续的空间，而计算机读取变量值靠的是地址，数组的数据挨在一起，那么计算机只要知道第一个元素的地址，后面的元素的地址可以靠公式$address = firstAddress + index\\times sizeof(variableType)$计算得到。其中address表示我们要找的元素的地址，firstAddress表示数组第一个元素的地址，index表示要找的元素的索引(从0开始)，variableType表示变量类型。\n正是因为无论多大的数组都可以靠这个公式轻松计算得到元素的地址，计算机访问数组的速度极快，且与数组大小无关。\n多维数组\n上面说到的数组都是一维数组，数组也可以定义为多维的。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化多维数组    //声明一个2行3列的数组    //第一行为1，2，3；第二行为4，5，6    int array1[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;     //声明一个3行2列的数组    //第一行为1，2；第二行为3，4；第三行为5，6    int array2[3][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;    //声明一个三维数组    int array3[2][3][4] = &#123;&#123;&#123;1, 2, 3, 4&#125;, &#123;4, 3, 2, 1&#125;, &#123;2, 3, 4, 1&#125;&#125;,                             &#123;&#123;1, 1, 1, 1&#125;, &#123;2, 2, 2, 2&#125;, &#123;3, 3, 3, 3&#125;&#125;&#125;;    //访问多维数组    cout &lt;&lt; array1[0][0] &lt;&lt; endl;    cout &lt;&lt; array2[2][1] &lt;&lt; endl;    cout &lt;&lt; array3[1][1][3] &lt;&lt; endl;    //修改多维数组    array1[0][0] = 2025;    array2[2][1] = 12;    array3[1][1][3] = 31;    cout &lt;&lt; array1[0][0] &lt;&lt; endl;    cout &lt;&lt; array2[2][1] &lt;&lt; endl;    cout &lt;&lt; array3[1][1][3] &lt;&lt; endl;    return 0;&#125;\n结果为\n16220251231\n判断数组是几维的最直接的方法就是看声明和使用数组时要用到几个[]，除了维度变得更高，使用方法几乎与一维数组一样。需要注意的是：多维数组在形式上是多维的，但是存储的方式仍然是一维的。\n以二维数组为例，如果数组的声明为int a[2][2];，则它的表现形式和存储形式如图所示\n因此初始化可以有两种形式\nint a[2][2] = &#123;1, 2, 3, 4&#125;;\nint a[2][2] = &#123;&#123;1, 2&#125;,                &#123;3, 4&#125;&#125;;\n第一种初始化是从内存角度出发的方式，这样可以一眼看出元素在内存中的存储形式。第二种初始化则更符合人的习惯，这样可以看出数组的表现形式。推荐使用第二种赋值方式，对于更高维的数组来说，这样的赋值方式不容易出错。\n注意事项\n对于标准的C++来说，数组的大小必须在编译期就确定，因此[]里只能是字面常量或者编译期常量表达式。\nint array1[3];  //这是用字面常量规定数组长度constexpr int MAX_SIZE = 3;int array2[MAX_SIZE];   //这是用常量表达式规定数组的长度\n也就是说，对于标准C++来说，不能用变量来规定数组的长度。\n// 错误的使用方式，因为变量是运行期确定值int a = 3;int array1[a];\n但是如果真的这样使用，编译器未必会报错，并且可以正确的完成声明的步骤。\n这是因为一些编译器（如GCC）提供了扩展支持，支持变长数组（VLA），但这并非C++的标准语法。\n动态数组\nC++提供的方案\n静态数组虽然读取速度快，但是也有自身的局限性。静态数组需要在程序开始运行前就确定数组的大小，且确定后就无法修改大小。如果一个图书馆要存储图书的数据，那肯定不能使用大小要开始就确定的静态数组，毕竟没有人知道这个图书馆最后会存储多少本书。\n这个时候就可以使用动态数组，动态数组长度不固定，可以随意添加或删除数据。并且C++提供了这种数据类型，不需要自己去实现。\n#include &lt;iostream&gt;//使用C++提供的动态数组，必须包含头文件vector#include &lt;vector&gt;using namespace std;int main()&#123;    //声明动态数组，初始长度为3，并把元素全部初始化为10    vector&lt;int&gt; dynArray(3, 10);    cout &lt;&lt; &quot;dynArray的元素个数：&quot; &lt;&lt; dynArray.size() &lt;&lt; endl;    cout &lt;&lt; dynArray[0] &lt;&lt; endl;    cout &lt;&lt; dynArray[1] &lt;&lt; endl;    cout &lt;&lt; dynArray[2] &lt;&lt; endl;    //在数组后面添加一个元素    dynArray.push_back(333);    cout &lt;&lt; &quot;dynArray的元素个数：&quot; &lt;&lt; dynArray.size() &lt;&lt; endl;    cout &lt;&lt; dynArray[0] &lt;&lt; endl;    cout &lt;&lt; dynArray[1] &lt;&lt; endl;    cout &lt;&lt; dynArray[2] &lt;&lt; endl;    cout &lt;&lt; dynArray[3] &lt;&lt; endl;    return 0;&#125;\n结果为\ndynArray的元素个数：3101010dynArray的元素个数：4101010333\n以上是C++提供的动态数组的基本操作方式，更详细的操作会在后面的STL中介绍。\n字符串\n字符串顾名思义就是许多个字符连接起来，也就是我们平时使用的文本。\n在代码中，经常会遇到需要用文本和用户交互的情况，这种情况下，如果用char就需要定义很多字符型变量。为了解决这个问题，类C语言专门制定了字符串的规范。\nC风格字符串\nC风格字符串是C语言中使用的字符串的格式，C语言的做法是用字符型数组存储字符串，并在最后加上一个'\\0'表示字符串的结尾。下面是一个C语言的示例，它与C++有些许不同，但是整体结构非常相似。\n#include &lt;stdio.h&gt;int main()&#123;    char stringArr[] = &quot;Hello World&quot;;    printf(stringArr);    return 0;&#125;\n上述代码中，stringArr看似只有11个元素，但实际上有12个元素，可以等价为\nchar stringArr[] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;\\0&#x27;&#125;;\n这个字符串最后的'\\0'是字符串的结束字符。计算机并不认识字符串，在计算机眼中，这些只是一串二进制数，那在输出文本的时候，如何判断字符串已经结束了呢？\n答案就是当计算机看到结束字符’\\0’时，就知道字符串已经结束了。如果丢掉这个结束字符，计算机就不知道字符串已经结束了，会继续向后输出，导致数组越界。\n因此，C语言的字符串实际上是一个非常危险的设计。\nC++风格字符串\n无论是处理文本输入，还是执行拼接字符串操作，使用C++风格的字符串都是更高效、更安全的选择。\n不同于C语言的字符串数组，C++的std::string是动态的，在文本更长时它的容量将增大。\n下面是C++字符串的一些常用操作。\n#include &lt;iostream&gt;//使用字符串时，加上string头文件#include &lt;string&gt;using std::cout, std::endl, std::cin;int main()&#123;    //声明并初始化字符串    std::string helloString(&quot;Hello World&quot;);    cout &lt;&lt; helloString &lt;&lt; endl;    //读取输入的字符串    std::string firstLine;    cout &lt;&lt; &quot;请输入第一行数据：&quot;;    getline(cin, firstLine);    std::string secondLine;    cout &lt;&lt; &quot;请输入第二行数据：&quot;;    getline(cin, secondLine);    //输出读取到的内容    cout &lt;&lt; &quot;\\n输入的内容为：\\n&quot;;    cout &lt;&lt; firstLine &lt;&lt; endl;    cout &lt;&lt; secondLine &lt;&lt; endl;    //拼接两个字符串    std::string contactString = firstLine + &quot; &quot; + secondLine;    cout &lt;&lt; &quot;拼接后的字符串： &quot; &lt;&lt; contactString &lt;&lt; endl;    //复制字符串    std::string copyString;    copyString = helloString;    cout &lt;&lt; &quot;复制出来的字符串： &quot; &lt;&lt; copyString &lt;&lt; endl;    //计算字符串的长度    cout &lt;&lt; &quot;helloString的字符数量为： &quot; &lt;&lt; helloString.length() &lt;&lt; endl;    return 0;&#125;\n运行结果为\nHello World请输入第一行数据：你好请输入第二行数据：世界输入的内容为：你好世界拼接后的字符串： 你好 世界复制出来的字符串： Hello WorldhelloString的字符数量为： 11\n上面这些是常用的对字符串的操作，更详细的内容将在后面的STL部分介绍。\n","categories":["C++"],"tags":["C++"]},{"title":"CPP控制程序流程(上)","url":"/2026/01/02/CPP%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B-%E4%B8%8A/","content":"在前面的程序中，我们总是一套逻辑从头执行到尾。但是这样的程序非常的死板，如果想和用户交互，根据用户的行为来决定执行哪些语句又该怎么办？\n三元运算符\n上一节说到的三元运算符? :是一种选择。这个运算符可以根据用户输入的内容和判断语句来选择执行哪个表达式。\n但是这样的方式只能执行一个表达式。大部分情况下，我们要根据不同的输入来执行一系列操作，很明显这个时候三元运算符就不适合使用了。\nif…else\nC++使用if...else帮助程序员解决这个问题。\nif…else基本结构\n下面是一个最简单的if...else结构。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用if else进行判断    if (op == &#x27;+&#x27;)  //如果符号是+，执行下面的语句        res = x+y;    else //如果符号不是+，执行下面的语句        res = x-y;            cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n运行结果：\n请输入计算式(用空格隔开，只能算加减):3 + 5结果为：8请输入计算式(用空格隔开，只能算加减):10 - 2.3结果为：7.7\n可以看到输入的两个计算式都被正确的计算了。\n再来看代码中的\n//使用if else进行判断if (op == &#x27;+&#x27;)  //如果符号是+，执行下面的语句    res = x+y;else //如果符号不是+，执行下面的语句    res = x-y;\n首先，if后面必须要有一个表达式，如果这个表达式结果为true，则执行if下面的语句，即res=x+y;\n如果if后面的表达式结果为false，则if下面的语句不会被执行，会转而执行else下面的语句。else表示：如果上面的判断都为false，就来执行else后面的语句。\n\n在没有使用花括号{}的情况下，if和else都只会执行后面紧跟着的一条语句。使用花括号可以将多条语句组合成一个代码块，使其全部被执行。\n\n执行多条语句\n如果仅仅是上面的效果，仍然满足不了执行多条语句的要求，这个时候，我们可以将要执行的多条语句用{}包裹，形成一个代码块，那么它们就都会被执行了。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用if else进行判断    if (op == &#x27;+&#x27;)  &#123;        cout &lt;&lt; &quot;执行加法&quot; &lt;&lt; endl;        res = x+y;    &#125;    else &#123;        cout &lt;&lt; &quot;执行减法&quot; &lt;&lt; endl;        res = x-y;    &#125;    cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n运行结果：\n请输入计算式(用空格隔开，只能算加减):5 + 3执行加法结果为：8请输入计算式(用空格隔开，只能算加减):4 - 2.2执行减法结果为：1.8\n可以看到运行结果中，if和else都执行了两条语句，语句数量可以扩展到更多。\nelse if\n在上面的示例中，如果用户没有按要求输入，那就会导致代码错误。例如\n请输入计算式(用空格隔开，只能算加减):3 / 2执行减法结果为：1\n可以看到用户输入了除法计算式，但是程序仍然按减法计算了，这就导致了错误。\n因此更推荐对每种情况都加一个判断语句，最后的else用来处理特殊情况。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用if else进行判断    if (op == &#x27;+&#x27;)      &#123;        res = x+y;    &#125;    else if(op == &#x27;-&#x27;)     &#123;        res = x-y;    &#125;    else    &#123;        cout &lt;&lt; &quot;非法输入&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n结果为：\n请输入计算式(用空格隔开，只能算加减):3 / 2非法输入结果为：0\n可以看到程序已经能判断输入是否有问题了，但是还有点小问题。在输入非法的时候，程序不应该输出结果。这时有三种解决方法\n\n\n将输出结果的代码放到每个代码块中\n\n\n在最后的else中加入一个return 0;直接停止代码的运行\n\n\n用一个标志位来判断是否调用输出语句\n\n\n单独使用if\nif可以被单独使用，作用就是表达式的值为true时，运行if后面的语句，表达式为false时，就什么也不做。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用标志位flag对是否输出结果进行判断。    bool flag = true;    //使用if else进行判断    if (op == &#x27;+&#x27;)      &#123;        res = x+y;    &#125;    else if(op == &#x27;-&#x27;)     &#123;        res = x-y;    &#125;    else    &#123;        cout &lt;&lt; &quot;非法输入&quot; &lt;&lt; endl;        flag = false;    &#125;    if (flag)        cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n运行结果：\n请输入计算式(用空格隔开，只能算加减):5 + 3结果为：8请输入计算式(用空格隔开，只能算加减):5 / 3非法输入\n可以看到通过使用标志位和单独使用if，就解决了之前的输入非法还会输出结果的问题。\nif的嵌套\nif的代码块里仍然可以使用if，这种方式就叫做嵌套。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    double x = 0, y = 0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用标志位flag对是否输出结果进行判断。    bool flag = true;    if (op==&#x27;+&#x27;)    &#123;        res = x+y;    &#125;else if(op == &#x27;-&#x27;)    &#123;        res = x-y;    &#125;else if(op == &#x27;*&#x27;)    &#123;        res = x*y;    &#125;else if(op == &#x27;/&#x27;)    &#123;        if (y != 0)        &#123;            res = x/y;        &#125;else        &#123;            cout &lt;&lt; &quot;除数不能为0&quot; &lt;&lt; endl;            flag = false;        &#125;    &#125;else    &#123;        cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;        flag = false;    &#125;    if (flag)    &#123;        cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res;    &#125;    return 0;&#125;\n结果为：\n请输入计算式(用空格隔开):3 + 5结果为：8请输入计算式(用空格隔开):6 / 3结果为：2请输入计算式(用空格隔开):6 / 0除数不能为0\n在这个示例中，在计算除法时，我们还要保证除数不为0，因此在除法的else if语句里，我们又加上了一个if...else，来保证除数不为0。\nswitch…case\nswitch…case可以让表达式与一系列常量进行比较，并根据表达式的值执行不同的操作。\n首先介绍switch…case的整体框架\nswitch(表达式)&#123;    case 常量A:        //执行语句        break;    case 常量B:        //执行语句        break;    ...    default:        //执行语句        break;&#125;\nswitch后面的括号中需要有一个表达式，表达式的值会被用来与下面的常量A、常量B…进行比较，如果相等，就会从当前常量下面的代码开始执行，执行到break;语句为止。如果没有常量与表达式的值相等，就会执行default下面的语句。\n\nswitch表达式的结果必须是整数类型（int、char、enum等）或可以隐式转换为整数类型的类型。不能直接使用浮点数（float、double）或字符串（string）作为switch表达式。\n\n要说明的是：break并不是switch结构的一部分，也就是说break;是可以被删掉的。break语句的作用是打断当前的switch结构的执行，让程序跳出switch。\nswitch语句并不像if…else一样，只执行符合条件的判断的下面的语句。switch更像是让代码跳到对应的标签处，依次向下执行(也就是说如果常量A下面的代码没有break，程序会继续执行常量B下面的代码，直到运行完switch或见到一个break)。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 2;    switch (a)    &#123;    case 1:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;1&quot; &lt;&lt; endl;        break;    case 2:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;2&quot; &lt;&lt; endl;        break;    case 3:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;3&quot; &lt;&lt; endl;        break;    case 4:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;4&quot; &lt;&lt; endl;        break;    default:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;default&quot; &lt;&lt; endl;        break;    &#125;    return 0;&#125;\n上面的代码运行结果为：\n标签为：2\n如果将break都去掉\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 2;    switch (a)    &#123;    case 1:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;1&quot; &lt;&lt; endl;        //break;    case 2:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;2&quot; &lt;&lt; endl;        //break;    case 3:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;3&quot; &lt;&lt; endl;        //break;    case 4:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;4&quot; &lt;&lt; endl;        //break;    default:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;default&quot; &lt;&lt; endl;        //break;    &#125;    return 0;&#125;\n运行结果为：\n标签为：2标签为：3标签为：4标签为：default\n这个结果也印证了上面所说的，break是用来打断程序继续执行switch。\n","categories":["C++"],"tags":["C++"]},{"title":"CPP运算符","url":"/2026/01/01/CPP%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"元\n首先介绍元，元表示操作的个数，也就是一个运算符需要几个操作数才能完成运算。例如赋值符号=,它的用法是a=3，在这个过程中，a是它的一个操作数，3也是它的操作数，所以=是二元运算符。再比如! flag，其中的!也是一个运算符(下面会讲)，但是它只有一个操作数’flag’，因此它是一元运算符。\n左值和右值\n在C++中，左值一般是指向一个内存单元的，它一般可修改，可寻址，可持久。\n右值一般是临时对象，它一般不可寻址，短暂存在，不可修改。\na = 7;\n在上面这个语句中，a指向内存中的一个地址，且可以长期存在，因此它是左值；而7则是一个临时的值，这个语句结束后就会被销毁，因此它是右值。\n示例代码\n在前面的章节中，已经简单的介绍过了几个运算符，这一节是更详细的展开。\n这一部分将围绕C++中的运算符展开，这里会先给出本节的完整的示例代码，方便复制粘贴。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //加减乘除和取模    cout &lt;&lt; &quot;===== 1. 加减乘除和取模运算符 =====&quot; &lt;&lt; endl;    int a = 10, b = 3;    cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; &quot; (加法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; &quot; (减法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; &quot; (乘法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; / &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a / b &lt;&lt; &quot; (除法，整数除法会截断小数部分)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; % &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a % b &lt;&lt; &quot; (取模，取余数)&quot; &lt;&lt; endl;        double c = 10.0, d = 3.0;    cout &lt;&lt; c &lt;&lt; &quot; / &quot; &lt;&lt; d &lt;&lt; &quot; = &quot; &lt;&lt; c / d &lt;&lt; &quot; (浮点数除法，保留小数)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //递增和递减运算符    cout &lt;&lt; &quot;===== 2. 递增和递减运算符 =====&quot; &lt;&lt; endl;    int num = 5;    cout &lt;&lt; &quot;初始值: num = &quot; &lt;&lt; num &lt;&lt; endl;        num++; // 等价于 num = num + 1    cout &lt;&lt; &quot;num++ 后: num = &quot; &lt;&lt; num &lt;&lt; endl;        num--; // 等价于 num = num - 1    cout &lt;&lt; &quot;num-- 后: num = &quot; &lt;&lt; num &lt;&lt; endl;    cout &lt;&lt; endl;        //递增(递减)运算符的前缀和后缀    cout &lt;&lt; &quot;===== 3. 递增(递减)运算符的前缀和后缀 =====&quot; &lt;&lt; endl;    int x = 10;        // 后缀形式：先使用值，再递增    cout &lt;&lt; &quot;后缀 x++: &quot;;    cout &lt;&lt; &quot;x++ = &quot; &lt;&lt; x++ &lt;&lt; &quot; (先输出x的值，再递增)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;递增后 x = &quot; &lt;&lt; x &lt;&lt; endl;        // 前缀形式：先递增，再使用值    cout &lt;&lt; &quot;前缀 ++x: &quot;;    cout &lt;&lt; &quot;++x = &quot; &lt;&lt; ++x &lt;&lt; &quot; (先递增，再输出x的值)&quot; &lt;&lt; endl;        int y = 20;    cout &lt;&lt; &quot;后缀 y--: &quot;;    cout &lt;&lt; &quot;y-- = &quot; &lt;&lt; y-- &lt;&lt; &quot; (先输出y的值，再递减)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;递减后 y = &quot; &lt;&lt; y &lt;&lt; endl;        cout &lt;&lt; &quot;前缀 --y: &quot;;    cout &lt;&lt; &quot;--y = &quot; &lt;&lt; --y &lt;&lt; &quot; (先递减，再输出y的值)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //相等运算符和不等运算符    cout &lt;&lt; &quot;===== 4. 相等运算符和不等运算符 =====&quot; &lt;&lt; endl;    int m = 15, n = 15, p = 20;        cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m == n ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m == p ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m != n ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m != p ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;        //关系运算符    cout &lt;&lt; &quot;===== 5. 关系运算符 =====&quot; &lt;&lt; endl;    int val1 = 25, val2 = 30;        cout &lt;&lt; val1 &lt;&lt; &quot; &gt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;        //逻辑运算符    cout &lt;&lt; &quot;===== 6. 逻辑运算符 =====&quot; &lt;&lt; endl;    bool flag1 = true, flag2 = false;        cout &lt;&lt; &quot;flag1 = &quot; &lt;&lt; (flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag2 = &quot; &lt;&lt; (flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        cout &lt;&lt; &quot;flag1 &amp;&amp; flag2 (逻辑与): &quot; &lt;&lt; (flag1 &amp;&amp; flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag1 || flag2 (逻辑或): &quot; &lt;&lt; (flag1 || flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag1 (逻辑非): &quot; &lt;&lt; (!flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag2 (逻辑非): &quot; &lt;&lt; (!flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        // 逻辑运算符的短路特性    int test = 0;    cout &lt;&lt; &quot;短路特性示例 (false &amp;&amp; ...): &quot; &lt;&lt; (false &amp;&amp; (test = 5)) &lt;&lt; endl;    cout &lt;&lt; &quot;test 的值: &quot; &lt;&lt; test &lt;&lt; &quot; (因为短路，赋值没有执行)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //按位运算符    cout &lt;&lt; &quot;===== 7. 按位运算符 =====&quot; &lt;&lt; endl;    unsigned int bits1 = 6;  // 二进制: 0110    unsigned int bits2 = 3;  // 二进制: 0011        cout &lt;&lt; bits1 &lt;&lt; &quot; &amp; &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 &amp; bits2) &lt;&lt; &quot; (按位与)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; | &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 | bits2) &lt;&lt; &quot; (按位或)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; ^ &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 ^ bits2) &lt;&lt; &quot; (按位异或)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;~&quot; &lt;&lt; bits1 &lt;&lt; &quot; = &quot; &lt;&lt; (~bits1) &lt;&lt; &quot; (按位取反，注意符号位)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &lt;&lt; 1 = &quot; &lt;&lt; (bits1 &lt;&lt; 1) &lt;&lt; &quot; (左移1位，相当于乘以2)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &gt;&gt; 1 = &quot; &lt;&lt; (bits1 &gt;&gt; 1) &lt;&lt; &quot; (右移1位，相当于除以2)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //复合赋值运算符    cout &lt;&lt; &quot;===== 8. 复合赋值运算符 =====&quot; &lt;&lt; endl;    int compound = 10;        cout &lt;&lt; &quot;初始值: compound = &quot; &lt;&lt; compound &lt;&lt; endl;    compound += 5;  // compound = compound + 5    cout &lt;&lt; &quot;compound += 5 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound -= 3;  // compound = compound - 3    cout &lt;&lt; &quot;compound -= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound *= 2;  // compound = compound * 2    cout &lt;&lt; &quot;compound *= 2 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound /= 4;  // compound = compound / 4    cout &lt;&lt; &quot;compound /= 4 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound %= 3;  // compound = compound % 3    cout &lt;&lt; &quot;compound %= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        int bitwise = 12; // 二进制: 1100    bitwise &amp;= 10;    // 10是1010，按位与后：1000 (8)    cout &lt;&lt; &quot;bitwise &amp;= 10 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise |= 3;     // 3是0011，按位或后：1011 (11)    cout &lt;&lt; &quot;bitwise |= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise ^= 1;     // 1是0001，按位异或后：1010 (10)    cout &lt;&lt; &quot;bitwise ^= 1 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &lt;&lt;= 2;    // 左移2位：101000 (40)    cout &lt;&lt; &quot;bitwise &lt;&lt;= 2 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &gt;&gt;= 3;    // 右移3位：101 (5)    cout &lt;&lt; &quot;bitwise &gt;&gt;= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;    cout &lt;&lt; endl;        //sizeof运算符    cout &lt;&lt; &quot;===== 9. sizeof运算符 =====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(double) = &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(bool) = &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;        int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; &quot;数组 arr 的大小: sizeof(arr) = &quot; &lt;&lt; sizeof(arr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = &quot;          &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; &quot; 个&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;sizeof(10) = &quot; &lt;&lt; sizeof(10) &lt;&lt; &quot; 字节 (字面量的大小)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(10 + 3.14) = &quot; &lt;&lt; sizeof(10 + 3.14) &lt;&lt; &quot; 字节 (表达式的结果类型大小)&quot; &lt;&lt; endl;        return 0;&#125;\n加减乘除与取模\n//加减乘除和取模cout &lt;&lt; &quot;===== 1. 加减乘除和取模运算符 =====&quot; &lt;&lt; endl;int a = 10, b = 3;cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; &quot; (加法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; &quot; (减法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; &quot; (乘法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; / &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a / b &lt;&lt; &quot; (除法，整数除法会截断小数部分)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; % &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a % b &lt;&lt; &quot; (取模，取余数)&quot; &lt;&lt; endl;double c = 10.0, d = 3.0;cout &lt;&lt; c &lt;&lt; &quot; / &quot; &lt;&lt; d &lt;&lt; &quot; = &quot; &lt;&lt; c / d &lt;&lt; &quot; (浮点数除法，保留小数)&quot; &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 1. 加减乘除和取模运算符 =====10 + 3 = 13 (加法)10 - 3 = 7 (减法)10 * 3 = 30 (乘法)10 / 3 = 3 (除法，整数除法会截断小数部分)10 % 3 = 1 (取模，取余数)10 / 3 = 3.33333 (浮点数除法，保留小数)\n这里的运算符与计算器上的一致，只需要注意\n\n\n如果是两个整数类型的变量或两个整数字面常量(也就是没有小数点)进行除法运算，小数部分会被直接舍去。\n\n\n如果其中一个是浮点数，那么计算出来的就是浮点数。\n\n\n递增与递减\n//递增和递减运算符cout &lt;&lt; &quot;===== 2. 递增和递减运算符 =====&quot; &lt;&lt; endl;int num = 5;cout &lt;&lt; &quot;初始值: num = &quot; &lt;&lt; num &lt;&lt; endl;num++; // 等价于 num = num + 1cout &lt;&lt; &quot;num++ 后: num = &quot; &lt;&lt; num &lt;&lt; endl;num--; // 等价于 num = num - 1cout &lt;&lt; &quot;num-- 后: num = &quot; &lt;&lt; num &lt;&lt; endl;cout &lt;&lt; endl;//递增(递减)运算符的前缀和后缀cout &lt;&lt; &quot;===== 3. 递增(递减)运算符的前缀和后缀 =====&quot; &lt;&lt; endl;int x = 10;// 后缀形式：先使用值，再递增cout &lt;&lt; &quot;后缀 x++: &quot;;cout &lt;&lt; &quot;x++ = &quot; &lt;&lt; x++ &lt;&lt; &quot; (先输出x的值，再递增)&quot; &lt;&lt; endl;cout &lt;&lt; &quot;递增后 x = &quot; &lt;&lt; x &lt;&lt; endl;// 前缀形式：先递增，再使用值cout &lt;&lt; &quot;前缀 ++x: &quot;;cout &lt;&lt; &quot;++x = &quot; &lt;&lt; ++x &lt;&lt; &quot; (先递增，再输出x的值)&quot; &lt;&lt; endl;int y = 20;cout &lt;&lt; &quot;后缀 y--: &quot;;cout &lt;&lt; &quot;y-- = &quot; &lt;&lt; y-- &lt;&lt; &quot; (先输出y的值，再递减)&quot; &lt;&lt; endl;cout &lt;&lt; &quot;递减后 y = &quot; &lt;&lt; y &lt;&lt; endl;cout &lt;&lt; &quot;前缀 --y: &quot;;cout &lt;&lt; &quot;--y = &quot; &lt;&lt; --y &lt;&lt; &quot; (先递减，再输出y的值)&quot; &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 2. 递增和递减运算符 =====初始值: num = 5num++ 后: num = 6num-- 后: num = 5===== 3. 递增(递减)运算符的前缀和后缀 =====后缀 x++: x++ = 10 (先输出x的值，再递增)递增后 x = 11前缀 ++x: ++x = 12 (先递增，再输出x的值)后缀 y--: y-- = 20 (先输出y的值，再递减)递减后 y = 19前缀 --y: --y = 18 (先递减，再输出y的值)\n先看第一部分的代码，可以看到++和--可以使变量+1或者-1，这就是自增和自减运算符的作用。\n再看第二段代码，可以看到自增和自减运算符可以放在变量前面和变量后面。放在变量前面会先进行递增(减)，然后被使用；放在变量后面会先被使用，然后再递增(减)。\n相等与不等\n//相等运算符和不等运算符cout &lt;&lt; &quot;===== 4. 相等运算符和不等运算符 =====&quot; &lt;&lt; endl;int m = 15, n = 15, p = 20;cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m == n ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m == p ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m != n ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m != p ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 4. 相等运算符和不等运算符 =====15 == 15 : 相等15 == 20 : 不相等15 != 15 : 相等15 != 20 : 不相等\n在C++中，=表示赋值，==表示判断左值和右值是否相等，相等返回true，否则返回false。\n!=则相反，如果左值和右值相等，则返回false，否则返回true。\n在代码中还可以看到一种运算符?  : ，这叫做三元运算符，因为它需要三个操作数，格式为\n条件表达式 ? 表达式1 : 表达式2\n它会首先计算条件表达式，如果条件表达式返回true，则计算并返回表达式1的值；如果条件表达式返回false，则计算并返回表达式2的值\n\n在C++中，表达式的值只要不是0，就可以表示true；表达式的值是0则表示false。\n\n关系运算符\n//关系运算符    cout &lt;&lt; &quot;===== 5. 关系运算符 =====&quot; &lt;&lt; endl;    int val1 = 25, val2 = 30;        cout &lt;&lt; val1 &lt;&lt; &quot; &gt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 5. 关系运算符 =====25 &gt; 30 : 假25 &lt; 30 : 真25 &gt;= 30 : 假25 &lt;= 30 : 真\n关系运算符返回的结果是true和false。只要左值和右值满足关系运算符的关系，就会返回true，否则返回false。代码中的&lt;表示小于号，&gt;表示大于号，&lt;=表示小于等于号，&gt;=表示大于等于号。\n逻辑运算符\n//逻辑运算符    cout &lt;&lt; &quot;===== 6. 逻辑运算符 =====&quot; &lt;&lt; endl;    bool flag1 = true, flag2 = false;        cout &lt;&lt; &quot;flag1 = &quot; &lt;&lt; (flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag2 = &quot; &lt;&lt; (flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        cout &lt;&lt; &quot;flag1 &amp;&amp; flag2 (逻辑与): &quot; &lt;&lt; (flag1 &amp;&amp; flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag1 || flag2 (逻辑或): &quot; &lt;&lt; (flag1 || flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag1 (逻辑非): &quot; &lt;&lt; (!flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag2 (逻辑非): &quot; &lt;&lt; (!flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        // 逻辑运算符的短路特性    int test = 0;    cout &lt;&lt; &quot;短路特性示例 (false &amp;&amp; ...): &quot; &lt;&lt; (false &amp;&amp; (test = 5)) &lt;&lt; endl;    cout &lt;&lt; &quot;test 的值: &quot; &lt;&lt; test &lt;&lt; &quot; (因为短路，赋值没有执行)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 6. 逻辑运算符 =====flag1 = trueflag2 = falseflag1 &amp;&amp; flag2 (逻辑与): falseflag1 || flag2 (逻辑或): true!flag1 (逻辑非): false!flag2 (逻辑非): true短路特性示例 (false &amp;&amp; ...): 0test 的值: 0 (因为短路，赋值没有执行)\n可以直接用布尔类型bool的变量来表示true和false。\n接下来介绍与、或、非。与&amp;&amp;表示符号两边的表达式都为true，才会返回true；或||(键盘上是shift+\\ )表示符号两边的表达式任一为true，就会返回true；非!表示符号后面的表达式的结果的相反结果，当后面的表达式结果为true时，就会返回false。\n接下来介绍一下逻辑运算符的短路特性，也就是说：逻辑运算符两边的表达式不是同时计算的，当第一个计算的表达式的结果可以决定最后结果时，另一个表达式就不会被计算。\n逻辑运算符&amp;&amp;和||都是先计算左边表达式的值，如果是下列情况：false &amp;&amp; ...、true || ...，则右侧的表达式不会被计算。\n按位运算符\n//按位运算符    cout &lt;&lt; &quot;===== 7. 按位运算符 =====&quot; &lt;&lt; endl;    unsigned int bits1 = 6;  // 二进制: 0110    unsigned int bits2 = 3;  // 二进制: 0011        cout &lt;&lt; bits1 &lt;&lt; &quot; &amp; &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 &amp; bits2) &lt;&lt; &quot; (按位与)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; | &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 | bits2) &lt;&lt; &quot; (按位或)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; ^ &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 ^ bits2) &lt;&lt; &quot; (按位异或)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;~&quot; &lt;&lt; bits1 &lt;&lt; &quot; = &quot; &lt;&lt; (~bits1) &lt;&lt; &quot; (按位取反，注意符号位)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &lt;&lt; 1 = &quot; &lt;&lt; (bits1 &lt;&lt; 1) &lt;&lt; &quot; (左移1位，相当于乘以2)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &gt;&gt; 1 = &quot; &lt;&lt; (bits1 &gt;&gt; 1) &lt;&lt; &quot; (右移1位，相当于除以2)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n6 &amp; 3 = 2 (按位与)6 | 3 = 7 (按位或)6 ^ 3 = 5 (按位异或)~6 = 4294967289 (按位取反，注意符号位)6 &lt;&lt; 1 = 12 (左移1位，相当于乘以2)6 &gt;&gt; 1 = 3 (右移1位，相当于除以2)\n数据在计算机中是用二进制存储的，数据在被标示成二进制后，就可以对每一位进行操作。\n\n\n按位与&amp;表示对数据的每一位都进行与操作，某一位上都为1的依然为1，否则这一位为0。\n\n\n按位或|表示对数据的每一位都进行或操作，某一位上任一数据是1则为1，全是0的位仍然是0。\n\n\n按位异或^表示对数据的每一位都进行异或操作，某一位上都为同为1或同为0的为0，否则这一位为1(相同为0，不同为1)。\n\n\n按位取反~表示对数据的每一位都进行取反操作，为1的位变为0，为0的位变成1。\n\n\n左移&lt;&lt;表示对数据的每一位都向左移动1位，末尾补0。这个操作相当于将原数据$\\times 2$。\n\n\n右移&gt;&gt;表示对数据的每一位都向右移动1位，开头补0。这个操作相当于将原数据$\\div 2$\n\n\n复合赋值运算符\n//复合赋值运算符    cout &lt;&lt; &quot;===== 8. 复合赋值运算符 =====&quot; &lt;&lt; endl;    int compound = 10;        cout &lt;&lt; &quot;初始值: compound = &quot; &lt;&lt; compound &lt;&lt; endl;    compound += 5;  // compound = compound + 5    cout &lt;&lt; &quot;compound += 5 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound -= 3;  // compound = compound - 3    cout &lt;&lt; &quot;compound -= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound *= 2;  // compound = compound * 2    cout &lt;&lt; &quot;compound *= 2 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound /= 4;  // compound = compound / 4    cout &lt;&lt; &quot;compound /= 4 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound %= 3;  // compound = compound % 3    cout &lt;&lt; &quot;compound %= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        int bitwise = 12; // 二进制: 1100    bitwise &amp;= 10;    // 10是1010，按位与后：1000 (8)    cout &lt;&lt; &quot;bitwise &amp;= 10 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise |= 3;     // 3是0011，按位或后：1011 (11)    cout &lt;&lt; &quot;bitwise |= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise ^= 1;     // 1是0001，按位异或后：1010 (10)    cout &lt;&lt; &quot;bitwise ^= 1 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &lt;&lt;= 2;    // 左移2位：101000 (40)    cout &lt;&lt; &quot;bitwise &lt;&lt;= 2 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &gt;&gt;= 3;    // 右移3位：101 (5)    cout &lt;&lt; &quot;bitwise &gt;&gt;= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 8. 复合赋值运算符 =====初始值: compound = 10compound += 5 后: compound = 15compound -= 3 后: compound = 12compound *= 2 后: compound = 24compound /= 4 后: compound = 6compound %= 3 后: compound = 0bitwise &amp;= 10 后: bitwise = 8bitwise |= 3 后: bitwise = 11bitwise ^= 1 后: bitwise = 10bitwise &lt;&lt;= 2 后: bitwise = 40bitwise &gt;&gt;= 3 后: bitwise = 5\n复合赋值就是将一些运算符与赋值运算符=连接在一起使用，这些运算符一般都是二元运算符，复合之后的效果相当于将变量自身的值进行对应的操作后再赋值给变量自身。\nsizeof\n//sizeof运算符    cout &lt;&lt; &quot;===== 9. sizeof运算符 =====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(double) = &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(bool) = &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;        int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; &quot;数组 arr 的大小: sizeof(arr) = &quot; &lt;&lt; sizeof(arr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = &quot;          &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; &quot; 个&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;sizeof(10) = &quot; &lt;&lt; sizeof(10) &lt;&lt; &quot; 字节 (字面量的大小)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(10 + 3.14) = &quot; &lt;&lt; sizeof(10 + 3.14) &lt;&lt; &quot; 字节 (表达式的结果类型大小)&quot; &lt;&lt; endl;\n运行结果为\n===== 9. sizeof运算符 =====sizeof(int) = 4 字节sizeof(double) = 8 字节sizeof(char) = 1 字节sizeof(bool) = 1 字节数组 arr 的大小: sizeof(arr) = 20 字节数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = 5 个sizeof(10) = 4 字节 (字面量的大小)sizeof(10 + 3.14) = 8 字节 (表达式的结果类型大小)\nsizeof在前面讲过，这里不再细讲，可以看看代码进行回忆。\n优先级\n正如加减乘除要先算乘除后算加减一样，C++中的运算符也是有优先级的区分的，下面是优先级的表格，数字越小表示优先级越高，数字越大表示优先级越低。\n\n\n\n等级\n名称\n运算符\n\n\n\n\n1\n作用域解析运算符\n::\n\n\n2\n成员选择、下标、后缀递增和后缀递减\n.、-&gt;、()、++、–\n\n\n3\nsizeof、前缀递增和递减、求补、逻辑NOT、单目加和减、取址和解除引用、new、new[]、delete、delete[]、类型转换、sizeof()\n++、–、~、!、+、-、&amp;、*、()\n\n\n4\n用于指针的成员选择\n.、-&gt;\n\n\n5\n乘、除、求模\n*、/、%\n\n\n6\n加、减\n+、-\n\n\n7\n移位（左移和右移）\n&lt;&lt;、&gt;&gt;\n\n\n8\n不等关系\n&lt;、&lt;=、&gt;、&gt;=\n\n\n9\n相等关系\n==、!=\n\n\n10\n按位AND\n&amp;\n\n\n11\n按位XOR\n^\n\n\n12\n按位OR\n|\n\n\n13\n逻辑AND\n&amp;&amp;\n\n\n14\n逻辑OR\n||\n\n\n15\n条件运算符\n?:\n\n\n16\n赋值运算符\n=、*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&amp;=、|=、^=\n\n\n17\n逗号运算符\n,\n\n\n\n这个表格非常的复杂，记忆起来非常困难，因此，一般我们不会根据这个表格进行编程，我们会将我们想要优先进行的运算用()包裹，这样一来，运行的顺序就会非常的直观，我们只需要记住优先级比()高的运算符即可。\n","categories":["C++"],"tags":["C++"]},{"title":"CPP变量与常量","url":"/2025/12/26/CPP%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/","content":"变量\n变量是在代码中可以被改变的数据，在使用变量前，要先规定变量的类型和名称，如果规定是整数型，那它就不能用来存储小数。变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。\n内存\n在计算机中，处理器负责执行应用程序，在此过程中，它会从 RAM（随机存取存储器）中读取程序的二进制指令及相关数据。RAM 可以看作是一系列连续的存储单元（“格子”），每个单元可以存放一个固定大小的数据项。需要注意的是，一个存储单元只能容纳一份数据，但同一份数据可以被复制到多个单元中。\n举个例子：假设你有一整套螺丝刀（我们将其视为一个完整的数据结构），但每个格子的容量只能容纳一把螺丝刀。这时，你需要将这套螺丝刀拆开，将每把螺丝刀依次放入相邻的格子中。这样一来，当你需要使用整套工具时，就可以快速按顺序取出这些螺丝刀，并重新组合成完整的工具集。\n这样的类比有助于理解：在内存中，复杂的数据（如数组、结构体等）通常是以连续或关联的方式分布在多个内存单元中的，以便处理器高效访问和处理。\n声明变量\n在C++中，声明变量的基本格式是 VariableType VariableName，例如 int a，其中 int 是变量的类型，a 是变量的名称。\n声明变量的作用是向系统申请一块与其类型相匹配大小的内存空间。一旦变量被声明，这块内存就会被“预留”给该变量，直到其生命周期结束（例如离开作用域或被显式释放）。在这期间，该内存不会被分配给其他变量。\n需要注意的是，如果在声明变量时没有显式初始化（即没有在声明时赋予初始值），那么该变量的值将是未定义的——它会包含该内存位置当前残留的任意内容。这并非“上一个程序”留下的数据（现代操作系统通常会为每个进程提供独立的虚拟地址空间，并在分配内存时清零或做安全处理），而更可能是之前在同一程序中该内存位置所存储的旧值，或者是未初始化的“垃圾值”。\n可以用一个类比来理解：想象一个格子原本放着一把螺丝刀，后来格子的主人不再使用它，但没有清空格子。如果新主人直接使用这个格子而不放新东西进去，那么他拿到的还是那把旧螺丝刀。因此，在使用变量前进行初始化，是避免意外行为和保证程序可靠性的良好实践。\n初始化变量\n下面是初始化变量的示例代码\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化变量    int a = 10;    //声明多个变量    int b1, b2;    //初始化多个变量    int c1 = 10, c2 = 20, c3 = 30;    return 0;&#125;\n在C++中，变量的初始化是在声明时进行的，可以同时声明多个相同类型的变量，也可以同时初始化多个变量，中间用逗号隔开。\n作用域\n变量的作用域是变量能够被使用的范围。一旦超出了这个作用域，变量就无法被使用。如果变量的作用域是函数，那么这个变量会在函数结束后被销毁。\n在上面的代码中，变量声明和初始化是在 main 函数中，一旦 main 函数执行完毕，变量就会自动销毁。而如果在main函数中调用另一个函数，在运行另一个函数时，main里面的变量无法被访问。可以尝试运行下面的代码，看看是否能编译成功。\n#include &lt;iostream&gt;using namespace std;int sum(int a, int b) &#123;    //使用main函数里的变量    x = x + y;    return a + b;&#125;int main() &#123;    int x = 1, y = 2;    cout &lt;&lt; sum(x, y) &lt;&lt; endl;    return 0;&#125;\n上面的代码会编译失败，因为x和y的作用域是main函数，在sum函数中无法使用。同理，main函数也无法使用sum函数中的变量。\n\n只有在函数运行结束后，变量才会被销毁，在上面的例子中，sum函数只是无法使用x和y，但它们并没有被释放。\n\n全局变量\n如果有一个变量在多个函数中都使用，那么就可以将其定义为全局变量。全局变量和普通变量一样，区别在于它是在函数外被声明的，并且可以在任意函数中访问。\n#include &lt;iostream&gt;using namespace std;int a = 10, b = 20;int sum()&#123;    return a + b;&#125;int main()&#123;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum() &lt;&lt; endl;    return 0;&#125;\n运行后可以看到运行结果：\na = 10b = 20sum = 30\n虽然main函数和sum函数没有定义变量a和b，但程序依然可以正确的编译运行，因为全局变量的作用域是整个程序，因此可以在任意函数中访问。\n如果在函数里重新声明变量，那么局部变量会屏蔽全局变量。\n#include &lt;iostream&gt;using namespace std;int a = 10, b = 20;int sum()&#123;    //重新声明变量a    int a = 30;    return a + b;&#125;int main()&#123;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum() &lt;&lt; endl;    //使用全局变量a    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n运行后可以看到运行结果：\na = 10b = 20sum = 50a = 10\n可以看到，在sum函数中重新声明了变量a，在 sum 函数中声明的局部变量 a 屏蔽了全局变量 a，因此在该函数内部引用 a 时，指的是局部变量，而非全局变量。在sum函数结束后，sum声明的变量a被销毁，因此a的值被恢复为10。\n命名规范\n在上面的代码中，变量的名字都是简单的字母，但是在实际项目中，每个变量都有自己的含义，这个时候，变量名应该具有意义，这样可以让自己和其他人更容易理解一个变量的作用。比如，如果要定义年龄变量，应该这么写int age = 18;，这样在调用的时候很方便理解变量含义。\n在C++中，变量名只能使用字母、数字、下划线，不能使用特殊字符，并且变量名不能以数字开头。C++变量区分大小写，因此变量名Age和age是不同的(函数名同理)。\n推荐一个大家约定俗成的变量命名规范：驼峰命名法。驼峰命名法就是将变量首字母小写，然后每个单词首字母大写，比如phoneNumber，首字母p小写，第二个单词首字母N大写。\n与变量的驼峰命名法类似，函数命名规范采用Pascal命名法，即每个单词首字母大写，比如GetPhoneNumber。\n变量类型\n整数类型\nC++中，整数类型有char、short、int、long、long long，它们的大小由具体实现决定，但 C++ 标准确保：sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)。在大多数现代系统上，char 为 8 位，short 为 16 位，int 为 32 位，long 为 32 或 64 位，long long 为 64 位(位数指的是二进制位数)。\n有符号整数\n在计算机中，整数的存储通过补码形式存储，如果补码二进制第一位是’0’，则表示这个整数是整数，如果补码二进制第一位是’1’，则表示这个整数是负数。因此，对于16位整数，只有15位表示数字的大小，最高位表示数字的正负。\n无符号整数\n无符号整数就是没有符号位的整数，最高位无论是0还是1，都是正数。因此，对于16位的无符号整数，16位都表示数字的大小。\n\n关于原码、反码、补码可以参考这篇博客二进制数的原码、反码、补码（详解），这部分内容推荐阅读。\n\n浮点类型\nC++中，浮点类型有float、double、long double，分别表示单精度、双精度、长双精度。\n字符类型\nC++中，字符类型一般用char，字符类型要用单引号括住，比如'a'。可以发现，在整数类型中也有char类型，这是因为在计算机中，字符是通过编码为整数存储在内存中的，所以char类型既是整数类型，也是字符类型。比较常见的编码形式有ASCII、UTF-8(支持绝大多数语言)、GBK(只支持中文和英文)等。\n\n要注意的是，由于字符的编码都是正整数，所以char类型的变量是无符号类型的整数\n\n布尔类型\n布尔类型用bool表示，只有两个值，true和false。\n下面是声明不同类型变量的示例：\n#include &lt;iostream&gt;using namespace std;int main() &#123;  int myNum1 = 5;               // 声明整数类型变量  short int myNum2 = 5;        // 短整型  unsigned int myNum3 = 5;     // 无符号整型  float myFloatNum = 5.99;     // 声明单精度浮点数类型变量  double myDoubleNum = 9.98;   // 声明双精度浮点数类型变量  char myLetter = &#x27;D&#x27;;         // 声明字符类型变量  bool myBoolean = true;       // 声明布尔类型变量  cout &lt;&lt; &quot;整数类型变量：&quot; &lt;&lt; myNum1 &lt;&lt; &quot;\\n&quot;;   //&#x27;\\n&#x27;表示换行  cout &lt;&lt; &quot;短整型变量：&quot; &lt;&lt; myNum2 &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;无符号整型变量：&quot; &lt;&lt; myNum3 &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;单精度浮点数类型变量：&quot; &lt;&lt; myFloatNum &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;双精度浮点数类型变量：&quot; &lt;&lt; myDoubleNum &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;字符类型变量：&quot; &lt;&lt; myLetter &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;布尔类型变量：&quot; &lt;&lt; myBoolean &lt;&lt; &quot;\\n\\n&quot;;  //给无符号整型赋值负数  myNum3 = -5;  cout &lt;&lt; &quot;无符号整型变量：&quot; &lt;&lt; myNum3 &lt;&lt; &quot;\\n\\n&quot;;  //给短整型赋值32800  myNum2 = 32800;  cout &lt;&lt; &quot;短整型变量：&quot; &lt;&lt; myNum2 &lt;&lt; &quot;\\n\\n&quot;;  return 0;&#125;\n运行结果为：\n整数类型变量：5短整型变量：5无符号整型变量：5单精度浮点数类型变量：5.99双精度浮点数类型变量：9.98字符类型变量：D布尔类型变量：1无符号整型变量：4294967291短整型变量：-32736\n前几行都是正确的结果，但是后两个的输出结果明显与赋值不同，无符号整型变量从-5变成了一个很大的正数，短整型从正数变为了负数。第一个结果的原因是，无符号整数没有符号位，但是-5有符号位，且为1，因此补码为11111111111111111111111111111101，也就是4294967291。第二个结果的原因是，短整型的范围是-32768到32767，因此当赋值超过这个范围时，会进行截断，截断后的值读取为-32736。\n\n这些结果是可以算出来的，并非随机的，可以参考上面的原码、反码、补码的介绍尝试计算。\n\n常用运算符和关键字\n下面介绍一下关于变量的常用的运算符和关键字\nsizeof\nsizeof()是C++提供的一个运算符，可用于确定变量的长度\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;              // 查看char所占字节数    cout &lt;&lt; &quot;sizeof(short) = &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;            // 查看short所占字节数    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;                // 查看int所占字节数    cout &lt;&lt; &quot;sizeof(long) = &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;              // 查看long所占字节数    cout &lt;&lt; &quot;sizeof(long long) = &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;    // 查看long long所占字节数    cout &lt;&lt; &quot;sizeof(float) = &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;            // 查看float所占字节数    int a;    cout &lt;&lt; &quot;sizeof(a) = &quot; &lt;&lt; sizeof(a) &lt;&lt; endl;                    // 查看变量a所占字节数    return 0;&#125;\n运行结果为：\nsizeof(char) = 1sizeof(short) = 2sizeof(int) = 4sizeof(long) = 4sizeof(long long) = 8sizeof(float) = 4sizeof(a) = 4\nsizeof()的返回值是字节数，而不是位数(1Byte = 8bit，Byte表示字节，bit表示位)。\nauto\nauto是C++提供的自动推断类型的关键字，比如\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //使用auto自动推测变量类型    auto a = 10;    auto b = 10.5;    auto c = &#x27;a&#x27;;    auto d = true;    cout &lt;&lt; &quot;sizeof(a)=&quot; &lt;&lt; sizeof(a) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(b)=&quot; &lt;&lt; sizeof(b) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(c)=&quot; &lt;&lt; sizeof(c) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(d)=&quot; &lt;&lt; sizeof(d) &lt;&lt; endl;    return 0;&#125;\n运行结果为\nsizeof(a)=4sizeof(b)=8sizeof(c)=1sizeof(d)=1\n根据之前的sizeof()的结果，可以发现，a 是int类型，b是double类型，c是char类型，d是bool类型。\ntypedef\nC++允许将变量类型替换为使用者认为方便的名称，为此可使用关键字 typedef。\n#include &lt;iostream&gt;using namespace std;typedef unsigned int uint;  // 将unsigned int定义为uintint main()&#123;    uint a = 10;    cout &lt;&lt; a &lt;&lt; endl;    a = -10;    cout &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n运行结果为：\n104294967286\n可以看到，uint声明出来的变量a，它的类型是unsigned int。这就是typedef的作用。\n常量\n常量是在程序中不会被改变的量，常量一旦声明，它的值就不能改变。常量在声明时一定要初始化，然后就不可被改变。\n字面常量\n在前面的程序中，字面常量几乎一直被使用，比如\ncout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;\n其中的&quot;Hello World!&quot;就是一个字面常量。或者在赋值时int a = 10;，这里面的10也是字面常量。\nconst\n可以通过const关键字将变量声明为常量，比如\n#include &lt;iostream&gt;using namespace std;int main()&#123;    const int a = 10;    cout &lt;&lt; a &lt;&lt; endl;    // a = 20; // error    return 0;&#125;\n如果将注释符号去掉，将出现编译的错误，支出不能给常量赋值。因此，常量是一种确保某些数据不能修改的强大方式。\nconstexpr\nC++中有一个关键字constexpr，这个关键字既可以修饰函数，又可以修饰变量。constexpr可以在编译期生效，这是它最大的特点。\n在按下编译运行时，代码经历了两个流程，一个是编译期，一个是运行期(有的软件会把编译和运行分开，可以仅执行编译而不运行，如DEV-C++)。编译期就是从按下编译到产生可执行文件(Windows是.exe文件)的阶段，运行期就是这个可执行文件开始运行到最后运行完成的阶段(相当于双击了.exe文件)。\n修饰函数\n返回常量表达式\n#include &lt;iostream&gt;using namespace std;// 用constexpr修饰下面这个函数// 可以看到，这个函数无论何时被调用返回固定值constexpr double GetPi() &#123;return 22.0/7;&#125;// 下面这个代码调用了GetPi()// 由于GetPi()是常量表达式// 下面这个函数也是无论何时调用都返回固定值constexpr double TwicePi() &#123;return GetPi()*2;&#125;int main() &#123;    cout &lt;&lt; GetPi() &lt;&lt; endl;    cout &lt;&lt; TwicePi() &lt;&lt; endl;    return 0;&#125;\n上面这个示例代码中，GetPi()无论何时被调用都会返回固定的值，且被constexpr修饰，因此，它变成了常量表达式。相当于把计算出来的结果直接放进了二进制文件中，它的作用相当于一个名字为GetPi()的常量。而TwicePi()使用了这个常量，因此它的值也是固定的，也成为了常量表达式。\n\n如果TwicePi()里面用了const定义的常量，那它就不是常量表达式，因为const是运行期生效，在编译期，TwicePi里面存在变量，编译期会认为这个函数的返回值会发生变化，因此将它当做普通函数。\n\n返回普通函数\n正如上面所说，若是编译器在编译期无法确定函数的返回值是确定的，编译器就会将函数作为普通函数进行编译。\n修饰变量\nconstexpr修饰变量的语法与const类似。\nconstexpr int a = 5;\n上面这行代码定义了一个编译期全局变量，在编译期，所有用到这个常量a的地方都被替换为了5写进了二进制文件中。\n\n综上所述，constexpr与const最大的区别在于值的确定时机，目前这个区别只能用来提高编译函数的效率，但是在后面的场景中，会出现二者不能混用的情况。\n\n\n强烈建议：在可使用也可以不使用constexpr时，一定要使用它\n\n枚举\n有些时候，变量只会有一些特定的值，比如星期，只会有7天，这时就可以使用枚举变量。\n#include &lt;iostream&gt;using namespace std;//彩虹的颜色enum RainbowColors&#123;    Red,    Orange,    Yellow,    Green,    Blue,    Indigo,    Violet&#125;;int main()&#123;    //声明变量    RainbowColors color = Green;    cout &lt;&lt; &quot;The color is &quot; &lt;&lt; color &lt;&lt; endl;    return 0;&#125;\n上面的代码中，RainbowColors类型的变量只有七个可取的颜色，不能取其他值，运行结果为\nThe color is 3\n在枚举变量中，变量的值是枚举类型的索引，从0开始，上面的代码中，Red是第一个变量，因此索引为0，Orange是第二个变量，索引为1，以此类推。\n若是希望索引不是从0开始，可以这样做\nenum RainbowColors&#123;    Red = 7,    Orange,    Yellow,    Green,    Blue,    Indigo,    Violet&#125;;\n这样，索引就会从7开始，Orange为8，以此类推。\nenum ResultCode &#123;    OK = 0,            // 成功    ERROR_PARAM = -1,  // 参数错误    ERROR_NET = -2,    // 网络错误    ERROR_AUTH = -3    // 权限错误&#125;;\n也可以这样给枚举里的枚举值赋值，这样枚举的索引将是被赋予的值，这种一般用在表示状态的类型里。\n// 允许值重复（特殊场景用，如「别名」）enum Flag &#123;    Enable = 1,    Open = 1,   // 与 Enable 等价，别名    Disable = 0,    Close = 0   // 与 Disable 等价&#125;;\n可以看到，枚举值的索引是可以重复的。\n\n枚举是一个很简单的用法，但是它在项目中又无处不在，因为它不仅可以规定变量的取值范围，还可以用语义化名称替代不知含义的数字，让人一眼可以看懂\n\ndefine\nC++允许使用预处理器指令define来定义常量，但是这种方式不建议使用，这里提出这种方式只是为了方便阅读一些使用了这种方式定义常量的代码。\n#define PI 3.14159\n上面这行代码的结果就是让PI等于3.14159。但是这与前面介绍的方法有很大的区别。预处理器会将代码中的所有的PI替换为3.14159，然后再让编译器进行编译，这种替换是文本替换，而不是智能替换，编译器不知道常量的类型，这可能会导致一些意料之外的错误。\n关键字\n有些单词被C++保留，不能用作变量名。对编译器来说，这些关键字有特殊含义，包括：if、while等。\n","categories":["C++"],"tags":["C++"]},{"title":"环境设置","url":"/2025/12/25/%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/","content":"C++学习环境配置\nVisual Studio安装\n想要系统学习C++，Visual Studio是一个一定会被用到的软件，它是由微软（Microsoft）开发的一款功能强大、高度集成的集成开发环境（Integrated Development Environment, IDE），广泛用于 Windows 平台上的应用程序开发。它不仅支持多种编程语言（如 C#、Python、JavaScript 等），还为 C 和 C++ 开发者提供了全面的工具链支持，包括智能代码编辑、调试器、性能分析器、版本控制集成以及项目管理功能。\n下载\n点击下载链接即可进入Visual Studio的官方下载界面 \n点击社区版的免费下载(红框部分)，即可下载Visual Studio下载器，这个下载器不大，很快就可以下载下来。下载成功后，双击下载下来的.exe文件，就会进入下面的界面   \n可以根据需要选择模块来进行下载，学习C++的不知道选什么的话，可以将图中的三个选上。然后选择安装位置，将安装路径改为C盘以外的盘，因为这个软件本身占用空间较大，放在C盘可能会使电脑卡顿，另一方面，如果电脑坏了，放在非系统盘可以把数据恢复。等它安装好即可使用(有些电脑可能要先重启在使用)。\nVScode安装\n虽然Visual Studio功能强大，但是本身占用的空间比较大，而且，它一般是面向于项目，对于只想学C++的人来说，它过于笨重，因此我们可以用VScode来替代它，等到要做项目的时候在使用Visual Studio。\nVScode是微软开发的一款轻量级但功能强大的源代码编辑器，支持 Windows、macOS 和 Linux 三大主流操作系统。虽然 VS Code 本身并非传统意义上的集成开发环境（IDE），但通过安装扩展（Extensions），它可以轻松转变为功能完备的 C++ 开发工具。配合官方提供的 C/C++ 扩展，VS Code 能提供智能代码补全（IntelliSense）、语法高亮、代码导航、重构支持、调试集成（通过 GDB 或 LLDB）等专业级功能。同时，它原生支持 CMake、Makefile 以及任务（Tasks）和启动（Launch）配置，使项目构建与调试流程高度自动化。\n对于 C++ 初学者或希望在多平台（如 Linux 或嵌入式开发）下工作的开发者来说，VS Code 是一个灵活且高效的选择。它不捆绑特定编译器，而是依赖系统已安装的工具链（如 GCC、Clang 或 MinGW），因此配置更具自由度，也更贴近真实开发环境。此外，其内置终端、Git 集成、主题自定义和远程开发能力（如 Remote - SSH、WSL）进一步提升了开发体验。\n下载\n可以在vscode官方网站下载软件，如果下载速度比较慢的话，可以用迅雷下载，或者通过国内镜像下载。\n插件\n打开VScode后，在界面的左边打开插件界面 \n打开后可以看到已经安装的插件，红框框住的就是要下载的插件 \n在上面的搜索栏中搜索插件的名字，即可进行下载，这里还推荐一个与C++无关的插件\n这个插件可以让你的文件有不同的图标，让界面看起来更美观，提升工作效率。效果如下图所示。\n\n配置C/C++编译器\n目前最常用的 C/C++ 编译器主要有 GCC、MSVC 和 Clang。其中，GCC 和 Clang 具备良好的跨平台支持，而 MSVC 主要面向 Windows 平台，在其他系统上的使用较为受限。GCC 在 Linux 系统及嵌入式开发中被广泛采用，是这些领域事实上的标准工具链。考虑到 C++ 的主要应用场景（如系统编程、嵌入式开发、服务器后端等）大多集中在 Linux 和嵌入式环境，因此选择 GCC 作为 C++ 编译器是一个自然且实用的选择。\n安装MinGW\n到MinGW的GitHub主页下载MinGW \n如果无法进入GitHub，可以通过镜像下载，选择下载安装包可参考上一张图\n下载好后解压下载的压缩包，可以得到一个文件夹\n双击打开，进入里面的bin文件夹，复制文件夹的地址\n下一步配置环境变量，按下WIN+R，输入sysdm.cpl，然后按下回车，然后点击高级，点击环境变量，找到Path，点击新建，将刚才复制的地址粘贴进去\n按下WIN+R，输入cmd，然后按下回车，输入\ngcc -vg++ -v\n出现下面的消息说明安装成功。\n配置VScode\n在任意地方建立一个空文件夹，这个空文件夹可以用来作为学习C++时存储代码的文件夹，自行起一个名字(路径里最好不要有中文，因为有些软件是不支持中文路径的，中文路径可能导致软件运行出错，VScode虽然没有这个问题，但还是要养成使用英文路径的习惯)。有两种在该文件夹打开VScode的方法：\n通过命令行打开\n鼠标点击地址栏，输入cmd\n按下回车，会打开命令行，此时命令行的地址就在当前文件夹，输入\ncode .\n按下回车，就在VScode中打开了当前文件夹，在Linux系统中，也可以通过这种方式打开当前文件夹\n右键打开\n可以直接在文件夹空白处右键，选择通过Code打开，即可直接在VScode中打开当前文件夹。\n创建一个C++文件\n点击左上角的资源管理器，点击新建文件，输入文件的名字，在后面加上.cpp后缀，.cpp表示这是一个C++代码文件，就像C代码文件后缀是.c，python代码文件后缀是.py一样。\n在创建的C++文件里输入以下代码\n#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n插件设置\n点开插件界面，右键点击Code Runner，点击设置\n找到Run in Terminal，将它选上。\n运行代码\n回到cpp文件界面，点击鼠标右键，点击Run Code，即可运行\n运行后结果如图所示\n如果中文出现乱码，可以修改settings.json，在Code Runner插件中找到在settings.json中编辑\n在settings.json中进行修改\n可以直接将下面这三行代码替换图中指的三行\n&quot;c&quot;: &quot;cd $dir &amp;&amp; gcc -fexec-charset=GBK $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,&quot;zig&quot;: &quot;zig run&quot;,&quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ -fexec-charset=GBK $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,\n说明\n这种配置方法是最简单的方法，不能使用断点调试，如果想要使用断点调试，可以参考vscode配置C/C++环境\n参考资料\nvscode配置C/C++环境\n","categories":["C++"],"tags":["C++","tools"]},{"title":"CPP类和对象","url":"/2026/01/04/CPP%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/","content":"引入\n前面说到的内容几乎都是C语言部分的内容，从这篇文章开始，才进入到了面向对象部分。\n前面提到的，面向对象的语言有三大特性：封装、继承和多态。这篇文章讲的就是其中的封装部分。\n这部分内容实在太多，我认为先将这篇文章的框架和思路给出更有利于这部分的学习。\n首先，我会先介绍C++中的类(Class)和对象。类在用法上可以类比为变量类型，而由类这个变量类型声明的变量就是这个类的对象(Object)。而从意义上来说，类相当于一个抽象的概念，对象则是它的具体实现，比如当我提到’车’这个词，你想到的肯定是一种交通工具，而不是某辆具体的车，比如’迈巴赫S500’。在这个例子中，'车’就相当于类，'迈巴赫S500’就是这个类的一个对象。说到这里就不难看出，'对象’这个词翻译的似乎不是那么准确，从它的英文来看反而更直观。类里面的变量叫做成员变量，类里面的函数叫做成员函数(也可以叫做方法)。比如，'车’里面的变量可以有:‘座椅材质’,'空间大小’等，里面的函数有:‘换挡’,'刹车’等。也就是说，成员变量是类的属性，方法是类的行为。\n接着，我会介绍如何使用类，并引出类中的一些特殊方法：构造函数、析构函数、拷贝构造函数、移动构造函数。\n然后，我会介绍如何创建一些特殊的类，比如不能被复制的类、只能有一个实例的类等。并介绍如果用一些关键字修饰类里面的变量或函数会发生什么。\n最后，我会介绍一些也具有封装特性的类型，比如结构体，共用体，还会介绍友元的概念，并说明该在什么时候使用它们。\n类和对象\n声明类\n类就像函数一样，使用前要先声明，声明类的语法如下\nclass [className]&#123;    //成员变量    [typeName variableName];    //成员方法    [typeName functionName()&#123;&#125;];&#125;;//这里有;\n上面的[]表示这里是可以被替换的。\n创建对象\n声明了类之后，要创建它的实例对象才能使用，语法如下\n[className] [objectName];\n可以看到，创建对象的语法与声明变量的语法类似，要将类名放在前面，后面加上这个对象的名字，就创建了了这个类的一个对象。\n访问成员\n在完成类的声明和创建对象之后，就需要使用这个对象里的成员变量和方法。可以使用.来访问对象里的成员变量和方法。如果是通过new创建的对象或者是对象的指针，则需要使用-&gt;来访问对象。下面是一个声明类、创建对象和访问成员的示例\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//声明类class Human&#123;public:    // 成员变量    string name;    string sex;    int age;    //成员函数    void IntroduceSelf()&#123;        cout &lt;&lt; &quot;我的名字是&quot;+name &lt;&lt; &quot;性别&quot;+sex &lt;&lt; &quot;今年&quot; &lt;&lt; age &lt;&lt;&quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;//生命结束后要加个&#x27;;&#x27;int main()&#123;    //创建对象    Human firstPerson;    //修改属性    //只需要在对象的后面加一个&#x27;.&#x27;，后面加上要访问的成员变量或函数即可使用    firstPerson.name = &quot;亚当&quot;;    firstPerson.sex = &quot;男&quot;;    firstPerson.age = 30;    //调用方法    firstPerson.IntroduceSelf();    //指针访问    Human* p = &amp;firstPerson;    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;name &lt;&lt; endl;    cout &lt;&lt; &quot;性别：&quot; &lt;&lt; p-&gt;sex &lt;&lt; endl;    cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; p-&gt;age &lt;&lt; endl;    //通过指针调用方法    p-&gt;IntroduceSelf();    return 0;&#125;\n运行结果如下\n我的名字是亚当性别男今年30岁姓名：亚当性别：男年龄：30我的名字是亚当性别男今年30岁\n可以看到通过对象和.进行访问与通过对象指针和-&gt;进行访问的结果是一样的。区别只在于使用的是对象还是对象的指针。\n访问修饰符\n可以看到上面的代码中，在声明类的第一行，有一个public:，这个表示下面的所有成员变量和成员函数都是公开的，也就是可以通过对象访问所有的成员变量和方法。\n还有两种修饰符：protected和private。其中，protected表示属性不能被外部访问，但是可以被子类访问。private表示属性不能被外部和子类访问，只能内部访问。\n一般来说，成员变量都会被设置为private，而只有一些对外提供的接口会被设置为public。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//声明类class Human&#123;private:    // 成员变量    string name;    string sex;    int age;public:    //成员函数    void setName(string name)&#123;        this-&gt;name = name;    &#125;    string getName()&#123;        return this-&gt;name;    &#125;    void setSex(string sex)&#123;        this-&gt;sex = sex;    &#125;    string getSex()&#123;        return this-&gt;sex;    &#125;    void setAge(int age)&#123;        this-&gt;age = age;    &#125;    int getAge()&#123;        return this-&gt;age;    &#125;    void IntroduceSelf()&#123;        cout &lt;&lt; &quot;我的名字是&quot;+this-&gt;name &lt;&lt; &quot;性别&quot;+this-&gt;sex &lt;&lt; &quot;今年&quot; &lt;&lt; this-&gt;age &lt;&lt;&quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;//生命结束后要加个&#x27;;&#x27;int main()&#123;    //创建对象    Human firstPerson;    //修改属性    //只需要在对象的后面加一个&#x27;.&#x27;，后面加上要访问的成员变量或函数即可使用    firstPerson.setName( &quot;亚当&quot; );    firstPerson.setSex(&quot;男&quot;);    firstPerson.setAge(30);    //调用方法    firstPerson.IntroduceSelf();    //指针访问    Human* p = &amp;firstPerson;    cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; p-&gt;getName() &lt;&lt; endl;    cout &lt;&lt; &quot;性别：&quot; &lt;&lt; p-&gt;getSex() &lt;&lt; endl;    cout &lt;&lt; &quot;年龄：&quot; &lt;&lt; p-&gt;getAge() &lt;&lt; endl;    //通过指针调用方法    p-&gt;IntroduceSelf();    return 0;&#125;\n这个代码的运行结果与第一个代码相同，只是将成员变量的属性设置为了private，并对外提供了一些接口(API)来访问，比如setName(),getName()等。\n这样做的好处是，在给变量赋值时，可以先判断数值是否合理，比如\nfirstPerson.age = 1000; //这种情况下，年龄就不合理，但是仍然成功被赋值//如果setAge按下面的方式写，就可以避免上面的情况void setAge(int age)&#123;    if (age &lt;=0 || age &gt;= 120)&#123;        cout &lt;&lt; &quot;赋值不合理&quot; &lt;&lt; endl;        return;    &#125;else    &#123;        this-&gt;age = age;    &#125;&#125;\n\n上面的代码仅仅是为了演示，因此尽可能的简化了代码量，更好的做法是将性别这一属性定义为枚举类型。\n\nthis\n可以注意到在方法中给成员变量赋值时，用到了this-&gt;，this是指向对象自己的指针，因为传递的参数与成员变量命名一致，因此在函数的作用域内，成员变量不会生效，必须要用this来指明是在给成员变量赋值。\n构造函数\n构造函数是对象在被创建时自动调用的函数，这个函数的作用一般是对对象的属性(成员变量)进行初始化。\n构造函数与类同名，且没有返回值，比如\nclass Human&#123;public:    Human()&#123;        //code    &#125;&#125;;\n构造函数也可以在类里面声明，类外面定义，比如\nclass Human&#123;public:    //声明构造函数    Human();&#125;;//定义构造函数Human::Human()&#123;    //code&#125;\n构造函数可以被重载，比如\nclass Human&#123;private:    // 成员变量    string name;    string sex;    int age;public:    //构造函数    Human()&#123;        //code    &#125;    Human(string name)&#123;        //code    &#125;    Human(string name, string sex, int age)&#123;        //code    &#125;&#125;;\n在上面的代码中，三个Human()都是构造函数，编译器会创建对象时传入的参数的数量和类型决定使用哪个构造函数。\n构造函数可以有默认值，比如\nclass Human&#123;private:    // 成员变量    string name;    string sex;    int age;public:    //构造函数    Human(string name, string sex = &quot;男&quot;, int age = 18)&#123;        //code    &#125;&#125;;\n有默认值的构造函数与普通函数一样，带默认值的参数要放在后面，上面的代码中，可以只传递一个姓名参数，剩下两个参数会使用默认值。\n\n在最开始的示例中，虽然没有手动创建构造函数，但是C++会有一个默认的构造函数，这个函数没有参数，也不会执行任何代码。但是如果自己写了一个构造函数，那么这个默认的构造函数也就不存在了。这个机制只是为了保证每个类都有构造函数。\n\n使用构造函数\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;//声明类class Human&#123;private:    // 成员变量    string name;    string sex;    int age;public:    //构造函数    Human()&#123;&#125;    Human(string name)&#123;        this-&gt;name = name;    &#125;    Human(string name, string sex, int age)&#123;        this-&gt;name = name;        this-&gt;sex = sex;        this-&gt;age = age;    &#125;    //成员函数    void IntroduceSelf()&#123;        cout &lt;&lt; &quot;我的名字是&quot;+this-&gt;name &lt;&lt; &quot;性别&quot;+this-&gt;sex &lt;&lt; &quot;今年&quot; &lt;&lt; this-&gt;age &lt;&lt;&quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;//生命结束后要加个&#x27;;&#x27;int main()&#123;    //创建对象    Human firstPerson(&quot;亚当&quot;);    Human secondPerson(&quot;夏娃&quot;, &quot;女&quot;, 18);    secondPerson.IntroduceSelf();        return 0;&#125;\n可以看到，虽然两个对象传递的参数数量和类型都不同，但是两个实例都能被创建。\n上面的代码可以正确运行，但是这个时候，firstPerson只有name，而其他的成员变量都是垃圾值，如果在代码中加一行\nfirstPerson.IntroduceSelf();\n这个时候，代码就会输出垃圾值。前面说过，最好不要使用未被赋值的变量，为了解决这个问题，构造函数可以这样写\n//构造函数    Human()&#123;        this-&gt;name = &quot;&quot;;        this-&gt;sex = &quot;&quot;;        this-&gt;age = 0;    &#125;    Human(string name)&#123;        this-&gt;name = name;        this-&gt;sex = &quot;&quot;;        this-&gt;age = 0;    &#125;    Human(string name, string sex, int age)&#123;        this-&gt;name = name;        this-&gt;sex = sex;        this-&gt;age = age;    &#125;\n这样，没有被赋值的成员变量里就是无意义值，整个程序也会变得安全很多。\n更好的做法是，除了上面的保护措施，还要在需要用到这些变量的方法中检验变量值的合法性。比如\n//成员函数void IntroduceSelf()&#123;    if(this-&gt;name != &quot;&quot; &amp;&amp; this-&gt;sex != &quot;&quot; &amp;&amp; this-&gt;age !=0)        cout &lt;&lt; &quot;我的名字是&quot;+this-&gt;name &lt;&lt; &quot;性别&quot;+this-&gt;sex &lt;&lt; &quot;今年&quot; &lt;&lt; this-&gt;age &lt;&lt;&quot;岁&quot; &lt;&lt; endl;    else        cout &lt;&lt; &quot;属性不全&quot; &lt;&lt; endl;&#125;\n初始化列表\n构造函数除了前面那几种与函数相同的写法，还有一种特殊写法初始化列表\nclass Human&#123;private:    // 成员变量    string name;    string sex;    int age;public:    Human(string humanName, string humanSex, int humanAge): name(humanName), sex(humanSex),age(humanAge)&#123;        //code    &#125;&#125;;\n这种写法就是将成员变量初始化为括号里的值。这种写法不仅简单，且有着独特的作用。\n列表初始化相当于int age = humanAge;，而在{}里赋值相当于int age; age = humanAge;。在现在的例子中，二者似乎并无区别，但是别忘了，C++中有两种必须进行初始化的情况：常量和引用。比如\nclass Human&#123;private:    // 成员变量    string name;    const string sex;    int age;public:    //构造函数    Human(string humanName, string humanSex, int humanAge)&#123;        name = humanName;        sex = humanSex;        age = humanAge;    &#125;    //成员函数    void IntroduceSelf()&#123;        cout &lt;&lt; &quot;我的名字是&quot;+this-&gt;name &lt;&lt; &quot;性别&quot;+this-&gt;sex &lt;&lt; &quot;今年&quot; &lt;&lt; this-&gt;age &lt;&lt;&quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;\n\n成员变量不能用constexpr修饰，只能用const\n如果类是这样声明的，那么编译会报错，因为常量必须初始化。必须用初始化列表\n\nclass Human&#123;private:    // 成员变量    string name;    const string sex;    int age;public:    //构造函数    Human(string humanName, string humanSex, int humanAge):sex(humanSex)&#123;        name = humanName;        //sex = humanSex;        age = humanAge;    &#125;&#125;;\n\n尽可能的使用初始化列表，尤其是对于后面会讲到的STL容器或模板，因为先构建再赋值比直接初始化会花费更大的开销\n\n\n静态成员变量不能使用列表初始化，需要复杂逻辑赋值(比如要使用if等语句进行判断后再赋值)的不能使用列表初始化\n\n析构函数\n析构函数与构造函数相反，析构函数是对象被销毁的时候自动调用的函数，它的主要作用就是重置变量以及释放动态分配的内存和其他资源。\n析构函数的语法与构造函数类似，只是在前面加上了一个~\nclass Human&#123;private:    string name;    string sex;    int age;public:    //构造函数    Human()&#123;        //code    &#125;    //析构函数    ~Human()&#123;        //code    &#125;&#125;;\n与构造函数类似，析构函数也可以在类中声明，在类外实现。\nclass Human&#123;private:    string name;    string sex;    int age;public:    Human();    ~Human();&#125;;//构造函数Human::Human()&#123;    //code&#125;//析构函数Human::~Human()&#123;    //code&#125;\n下面是一个使用析构函数的示例\n#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Human&#123;private:    char* name;    char* sex;    int age;public:    //构造函数    Human(const char* const humanName, const char* const humanSex, int humanAge)&#123;        name = new char[strlen(humanName)+1];        sex = new char[strlen(humanSex) + 1];        strcpy(name, humanName);        strcpy(sex, humanSex);        age = humanAge;    &#125;    //析构函数    ~Human()&#123;        delete[] name;        delete[] sex;        cout &lt;&lt; &quot;析构函数调用完毕&quot; &lt;&lt; endl;    &#125;    //成员函数    void IntroduceSelf()&#123;        cout &lt;&lt; &quot;我是 &quot; &lt;&lt; name &lt;&lt; &quot;，性别&quot; &lt;&lt; sex &lt;&lt; &quot;，年龄&quot; &lt;&lt; age &lt;&lt; &quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    Human firstPerson(&quot;亚当&quot;, &quot;男&quot;, 30);    firstPerson.IntroduceSelf();    return 0;&#125;\n运行结果是\n我是 亚当，性别男，年龄30岁析构函数调用完毕\n可以看到，两条delete语句已经被成功调用。\n\n析构函数中不要写任何与释放资源无关的内容，比如cout，上面的代码只是为了展示析构函数被调用了。\n\n\n不要使用C风格的字符串，请使用C++风格的字符串，string会自己管理资源的释放，不用在析构函数中释放。\n\n拷贝构造函数\n浅拷贝\n#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Human&#123;private:    char* name;    char* sex;    int age;public:    //构造函数    Human(const char* const humanName, const char* const humanSex, int humanAge)&#123;        name = new char[strlen(humanName)+1];        sex = new char[strlen(humanSex) + 1];        strcpy(name, humanName);        strcpy(sex, humanSex);        age = humanAge;    &#125;    //析构函数    ~Human()&#123;        delete[] name;        delete[] sex;        cout &lt;&lt; &quot;析构函数调用完毕&quot; &lt;&lt; endl;    &#125;    //成员函数    void IntroduceSelf()&#123;        cout &lt;&lt; &quot;我是 &quot; &lt;&lt; name &lt;&lt; &quot;，性别&quot; &lt;&lt; sex &lt;&lt; &quot;，年龄&quot; &lt;&lt; age &lt;&lt; &quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;void Talk(Human human)&#123;    human.IntroduceSelf();&#125;int main()&#123;    Human firstPerson(&quot;亚当&quot;, &quot;男&quot;, 30);    Talk(firstPerson);    firstPerson.IntroduceSelf();    return 0;&#125;\n上面这个代码的运行结果是:\n我是 亚当，性别男，年龄30岁析构函数调用完毕我是 €/E[?，性别鄜E[?，年龄30岁\n可以看到，只有Talk函数里的IntroduceSelf输出的结果是正确的，在Talk调用结束后，析构函数也被调用，然后执行的IntroduceSelf里的姓名和性别就成为了乱码。\n这是因为传递参数的时候，human将firstPerson的所以变量都复制了，包括两个char*的指针，这就导致两个对象指向了同一个地址。而Talk函数运行结束后，human被销毁，自动调用了析构函数，导致firstPerson里面的两个变量也被释放，所以再调用IntroduceSelf会出现错误的结果。关系如图所示\n这就是浅拷贝，浅拷贝只将变量的值原封不动的拷贝过去，导致出现两个指针指向同一个地址的情况。\n使用拷贝构造函数\n为了解决浅拷贝的问题，我们可以使用拷贝构造函数将浅拷贝变成深拷贝。拷贝构造函数的语法是\nclass MyClass&#123;    // 拷贝构造函数    MyClass(const MyClass&amp; copySource)&#123;        // code    &#125;&#125;;\n所以上面的代码可以改成\n#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;class Human&#123;private:    char* name;    char* sex;    int age;public:    //构造函数    Human(const char* const humanName, const char* const humanSex, int humanAge)&#123;        name = new char[strlen(humanName)+1];        sex = new char[strlen(humanSex) + 1];        strcpy(name, humanName);        strcpy(sex, humanSex);        age = humanAge;    &#125;    //析构函数    ~Human()&#123;        delete[] name;        delete[] sex;        cout &lt;&lt; &quot;析构函数调用完毕&quot; &lt;&lt; endl;    &#125;    //拷贝构造函数    Human(const Human&amp; copySource)&#123;        name = nullptr;        sex = nullptr;        if (copySource.name != nullptr)        &#123;            name = new char[strlen(copySource.name)+1];            strcpy(name, copySource.name);        &#125;        if (copySource.sex != nullptr)        &#123;            sex = new char[strlen(copySource.sex) + 1];            strcpy(sex, copySource.sex);        &#125;                age = copySource.age;    &#125;    //成员函数    void IntroduceSelf()&#123;        cout &lt;&lt; &quot;我是 &quot; &lt;&lt; name &lt;&lt; &quot;，性别&quot; &lt;&lt; sex &lt;&lt; &quot;，年龄&quot; &lt;&lt; age &lt;&lt; &quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;void Talk(Human human)&#123;    human.IntroduceSelf();&#125;int main()&#123;    Human firstPerson(&quot;亚当&quot;, &quot;男&quot;, 30);    Talk(firstPerson);    firstPerson.IntroduceSelf();    return 0;&#125;\n运行结果为\n我是 亚当，性别男，年龄30岁析构函数调用完毕我是 亚当，性别男，年龄30岁析构函数调用完毕\n这个就是深拷贝，两个对象的指针指向不同的地址，不会导致析构函数出现问题，在函数中修改传递的对象的值也不会影响原对象。\n移动构造函数\n前面简单的说过左值和右值，这里再做一下说明\n左值（lvalue）\n左值是有名称、可以取地址的表达式\n\n\n变量名\n\n\n函数返回左值引用\n\n\n*ptr\n\n\n特点：有持久身份，生命周期较长\n右值（rvalue）\n\n\n纯右值（prvalue）：临时对象、字面量、函数返回非引用类型\n\n\n将亡值（xvalue）：通过std::move()转换得到的表达式\n\n\n特点：没有持久身份，即将销毁\n移动构造函数\n如果一个对象右值，你想要用它创建一个和它一样的左值，这个时候就可以使用赋值符号进行复制。但是如果对象过大，复制就会花费比较大的开销。一个更好的方案是，直接将这个右值的资源移动到左值。这个时候，就可以使用移动构造函数，语法是\nclass MyClass&#123;    //移动构造函数    MyClass(MyClass&amp;&amp; moveSource)&#123;        //code    &#125;&#125;;\n下面给出示例代码\n#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;utility&gt; // for std::moveusing namespace std;class Human &#123;private:    char* name;    char* sex;    int age;public:    // 构造函数    Human(const char* const humanName, const char* const humanSex, int humanAge)         : name(nullptr), sex(nullptr), age(humanAge) &#123;        name = new char[strlen(humanName) + 1];        sex = new char[strlen(humanSex) + 1];                strcpy(name, humanName);        strcpy(sex, humanSex);    &#125;        // 析构函数    ~Human() &#123;        delete[] name;        delete[] sex;        //cout &lt;&lt; &quot;析构函数调用完毕&quot; &lt;&lt; endl;    &#125;        // 拷贝构造函数    Human(const Human&amp; copySource) : name(nullptr), sex(nullptr), age(copySource.age) &#123;        if (copySource.name != nullptr) &#123;            name = new char[strlen(copySource.name) + 1];            strcpy(name, copySource.name);        &#125;        if (copySource.sex != nullptr) &#123;            sex = new char[strlen(copySource.sex) + 1];            strcpy(sex, copySource.sex);        &#125;        cout &lt;&lt; &quot;拷贝构造函数调用&quot; &lt;&lt; endl;    &#125;    // 移动构造函数 - 新增    Human(Human&amp;&amp; moveSource)        : name(moveSource.name), sex(moveSource.sex), age(moveSource.age) &#123;        // 将原对象的指针置为nullptr，防止析构时释放        moveSource.name = nullptr;        moveSource.sex = nullptr;        cout &lt;&lt; &quot;移动构造函数调用&quot; &lt;&lt; endl;    &#125;    // 成员函数    void IntroduceSelf() const &#123; // 添加const修饰符        cout &lt;&lt; &quot;我是 &quot; &lt;&lt; (name ? name : &quot;无名&quot;)              &lt;&lt; &quot;，性别&quot; &lt;&lt; (sex ? sex : &quot;未知&quot;)              &lt;&lt; &quot;，年龄&quot; &lt;&lt; age &lt;&lt; &quot;岁&quot; &lt;&lt; endl;    &#125;&#125;;void Talk(Human human) &#123;    human.IntroduceSelf();&#125;// 演示移动语义的函数Human CreateHuman() &#123;    Human tempPerson(&quot;临时人&quot;, &quot;女&quot;, 25);    return tempPerson; // 返回临时对象，会触发移动构造&#125;int main() &#123;    cout &lt;&lt; &quot;=== 演示拷贝构造 ===&quot; &lt;&lt; endl;    Human firstPerson(&quot;亚当&quot;, &quot;男&quot;, 30);    Talk(firstPerson); // 这里会调用拷贝构造函数    firstPerson.IntroduceSelf();        cout &lt;&lt; &quot;\\n=== 演示移动构造 ===&quot; &lt;&lt; endl;    Human secondPerson(CreateHuman()); // 这里会调用移动构造函数    secondPerson.IntroduceSelf();        cout &lt;&lt; &quot;\\n=== 演示std::move ===&quot; &lt;&lt; endl;    Human thirdPerson(&quot;夏娃&quot;, &quot;女&quot;, 28);    Human fourthPerson = move(thirdPerson); // 显式移动    fourthPerson.IntroduceSelf();    // thirdPerson现在处于有效但未定义状态，不应再使用        return 0;&#125;\n结果为\n=== 演示拷贝构造 ===拷贝构造函数调用我是 亚当，性别男，年龄30岁我是 亚当，性别男，年龄30岁=== 演示移动构造 ===移动构造函数调用我是 临时人，性别女，年龄25岁=== 演示std::move ===移动构造函数调用我是 夏娃，性别女，年龄28岁\n在上面的示例中，如果你的编译器在演示移动构造那里没有输出移动构造函数调用，那应该是因为你的编译器自动优化了你的代码，应用了RVO优化，直接在secondPerson的内存位置构造对象，而不是先创建临时对象再移动它。\n还可以注意到，不只有构造函数可以使用列表初始化，拷贝构造函数和移动构造函数也可以使用列表初始化。\n特殊类\n不允许复制的类\n有些时候，我们可能需要一个不应该被复制的类。当你的类管理独占资源时，比如文件句柄、数据库连接、网络套接字等，这些资源不能被多个对象共享。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class NonCopyable&#123;private:    //禁用拷贝构造函数和拷贝赋值    NonCopyable(const NonCopyable&amp;) = delete;    NonCopyable&amp; operator=(const NonCopyable&amp;) = delete;public:    NonCopyable()&#123;cout &lt;&lt; &quot;调用构造函数&quot; &lt;&lt; endl;&#125;    ~NonCopyable()&#123;cout &lt;&lt; &quot;调用析构函数&quot; &lt;&lt; endl;&#125;&#125;;int main()&#123;    NonCopyable n1;    //如果取消下面这行代码的注释，程序会报错    //NonCopyable n2 = n1;    return 0;&#125;\n可以看到上面的代码无法被拷贝复制，原因是我们把拷贝构造函数和拷贝赋值放在了private中(拷贝赋值是运算符重载的语法，这里可以先复制使用)，这样就无法调用拷贝构造函数进行拷贝。\n单例类\n确保一个类只有一个实例，并提供全局访问点（如配置管理器、日志系统）。与上面的无法复制的类不同，无法复制的类可以创建多个不同的实例，但是单例类只能有一个实例。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Singleton&#123;private:    //提供一个静态实例指针    static Singleton* instance;    //将构造函数设为private    Singleton()&#123;cout &lt;&lt; &quot;调用了私有的构造函数&quot; &lt;&lt; endl;&#125;public:    //定义一个返回指针的方法，必须是静态的    static Singleton* getInstance()&#123;        if (instance == nullptr)        &#123;            //调用构造函数            instance = new Singleton();        &#125;        return instance;    &#125;&#125;;//要把指针初始化为nullptrSingleton* Singleton::instance = nullptr;int main()&#123;    cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;    //创建一个实例    Singleton* obj1 = Singleton::getInstance();    cout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;    //创建第二个实例    Singleton* obj2 = Singleton::getInstance();    cout &lt;&lt; (obj1==obj2 ? &quot;obj1的地址与obj2相同&quot; : &quot;obj1的地址和obj2不同&quot;) &lt;&lt; endl;    return 0;&#125;\n运行结果为\n--------------------调用了私有的构造函数--------------------obj1的地址与obj2相同\n上面的代码有很多细节需要注意。首先是要创建private的静态实例指针和构造函数，在成员变量前加static表示这个类的所有实例共用一个成员变量，创建私有的构造函数是为了防止能够直接创建这个类的实例，这样才能够保证这个类不会被外部构造。\n然后是创建一个静态的返回静态实例指针的方法static Singleton* getInstance()，这个方法里要先判断静态实例指针是否是空指针，如果是空指针，就调用构造函数instance = new Singleton();，因为这个方法也是类的成员，所以可以访问私有的构造函数。然后将它作为这个函数的返回值，让所有通过这个函数获得的指针都是同一个指针。这个函数必须要设置成static，因为只有static的成员函数才能在创建对象前被调用。\n最后是要初始化这个静态实例指针为nullptr，可以通过这个语句Singleton* Singleton::instance = nullptr;，虽然instance是private，但是由于它是静态的，所以instance并不属于对象，静态成员变量属于类，对它的初始化属于类的一部分。\n禁止在栈中实例化的类\nC++程序的内存空间\nC++的代码在执行时，会将内存分成五个区：代码区、全局区、常量区、栈区、堆区\n代码区（Text Segment）\n作用：存放程序的执行代码（机器指令）特点：\n\n\n只读，防止程序意外修改自己的指令\n\n\n通常在程序加载时分配，程序结束时释放\n\n\n多个进程可以共享同一份代码\n\n\n全局/静态区（Data Segment）\n作用：存放全局变量、静态变量特点：\n\n\n程序启动时分配，程序结束时释放\n\n\n生命周期贯穿整个程序运行期间\n\n\n线程共享\n\n\n常量区（常量存储区）\n作用：存放字符串常量和const修饰的全局/静态变量特点：\n\n\n只读，修改会导致程序崩溃\n\n\n通常与全局/静态区相邻\n\n\n栈区（Stack）\n作用：存放函数参数、局部变量、返回地址等特点：\n\n\n后进先出（LIFO）结构\n\n\n自动分配和释放（函数调用时分配，函数返回时释放）\n\n\n速度快，但空间有限（通常几MB）\n\n\n不会出现内存碎片\n\n\n堆区（Heap）\n作用：动态内存分配特点：\n\n\n需要手动分配和释放（new/delete, malloc/free）\n\n\n生命周期由程序员控制\n\n\n空间较大\n\n\n速度较慢，可能出现内存碎片\n\n\n禁止在栈中实例化的类\n有些类的大小可能比较大，如果直接使用MyClass myclass();就会将对象创建在栈上，但是栈的空间比较小，无法容纳这么大的对象，程序就会崩溃。这个时候就需要创建成禁止在栈中实例化的类。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class HeapOnly&#123;private:    //析构函数    ~HeapOnly()&#123;&#125;public:    //销毁函数    void destroy()&#123;        delete this;        cout &lt;&lt; &quot;已销毁&quot; &lt;&lt; endl;    &#125;&#125;;int main()&#123;    //下面这行代码会报错    //HeapOnly a;    //使用new创建    HeapOnly* p = new HeapOnly;    //需要手动销毁    p-&gt;destroy();    return 0;&#125;\n可以看到，这种类需要\n\n\n将析构函数设置为私有的\n\n\n要创建公有的销毁函数\n\n\n创建的时候必须用new创建在堆区\n\n\n使用构造函数进行类型转换\n看下面的代码\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class MyClass&#123;private:    int num;public:    MyClass(int n) : num(n)&#123;        cout &lt;&lt; &quot;调用了构造函数&quot; &lt;&lt; endl;    &#125;    void show()&#123;        cout &lt;&lt; &quot;数字是&quot; &lt;&lt; num &lt;&lt; endl;    &#125;&#125;;void Talk(MyClass c)&#123;    c.show();&#125;int main()&#123;    Talk(10);    return 0;&#125;\n在调用Talk函数时，传递的参数并不是MyClass类型，但还是正确的调用了show方法。这是因为构造函数接受一个整数为参数，因此整数10被类型转换为了MyClass。如果想要避免这种情况，可以在构造函数前面使用explicit关键字，这个关键字禁止隐式转换，只允许进行显式转换。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class MyClass&#123;private:    int num;public:    explicit MyClass(int n) : num(n)&#123;        cout &lt;&lt; &quot;调用了构造函数&quot; &lt;&lt; endl;    &#125;    void show()&#123;        cout &lt;&lt; &quot;数字是&quot; &lt;&lt; num &lt;&lt; endl;    &#125;&#125;;void Talk(MyClass c)&#123;    c.show();&#125;int main()&#123;    //下面这行代码的注释去掉就会报错，因为不再被转换为MyClass    //Talk(10);    MyClass a(10);    Talk(a);    return 0;&#125;\n结构体\n结构体struct来自C语言，它的用法与类一样，仅在默认访问权限和默认继承方式上有区别。\n结构体的默认访问权限和默认继承方式都是public，也就是说，如果不写public或private这些访问修饰符，那么它就默认使用public。\n类的默认访问权限和默认继承方式都是private，也就是说，如果不写public或private这些访问修饰符，那么它就默认使用private。\n类和结构体的使用可以做如下区分\n\n\n意图表达：\n\n\n\n\n用 struct 表示&quot;这是数据&quot;\n\n\n用 class 表示&quot;这是对象，有行为和状态&quot;\n\n\n\n\n不要过度设计：如果只是简单的数据聚合，用 struct 更清晰\n\n\n考虑未来扩展：如果将来可能需要封装，一开始就用 class\n\n\n友元\n友元是C++中一种特殊的机制，它允许外部函数或类访问某个类的私有成员。虽然这看起来破坏了封装性，但在某些场景下是必要的设计选择。\n核心概念\n\n\n单向关系：A是B的友元，不代表B是A的友元\n\n\n非传递性：A是B的友元，B是C的友元，不代表A是C的友元\n\n\n谨慎使用：友元会破坏封装性，只在必要时使用\n\n\n常用情况\n\n\n操作符重载（最常见用途）\n\n\n序列化/反序列化（数据持久化）\n\n\n数学库中的向量运算\n\n\n观察者模式（设计模式）\n\n\n何时使用友元：\n\n\n操作符重载：特别是&lt;&lt;, &gt;&gt;, +, ==等\n\n\n工具类：序列化、调试、日志记录等\n\n\n紧密协作的类：如迭代器和容器\n\n\n性能关键代码：避免getter/setter的开销\n\n\n基础语法\n#include &lt;iostream&gt;using namespace std;// 前向声明（如果友元类在后面定义需要）class FriendClass;class MyClass &#123;private:    int privateData;      // 私有成员变量    string secretMessage; // 另一个私有成员    public:    // 构造函数    MyClass(int data, const string&amp; message)         : privateData(data), secretMessage(message) &#123;&#125;        // 公有方法（普通访问方式）    void showPublicInfo() const &#123;        cout &lt;&lt; &quot;公有方法访问: &quot; &lt;&lt; privateData &lt;&lt; endl;    &#125;        // 声明友元函数 - 可以访问所有私有成员    friend void friendFunction(const MyClass&amp; obj);        // 声明友元类 - 整个类都可以访问私有成员    friend class FriendClass;        // 注意：友元关系不会被继承，也不是对称的&#125;;// 友元函数的实现 - 不是类的成员函数，但可以访问私有成员void friendFunction(const MyClass&amp; obj) &#123;    // 友元函数可以直接访问私有成员    cout &lt;&lt; &quot;友元函数访问私有数据: &quot; &lt;&lt; obj.privateData &lt;&lt; endl;    cout &lt;&lt; &quot;友元函数访问私有消息: &quot; &lt;&lt; obj.secretMessage &lt;&lt; endl;&#125;// 友元类的定义class FriendClass &#123;public:    // 友元类的成员函数可以访问MyClass的私有成员    void accessPrivateData(const MyClass&amp; obj) &#123;        cout &lt;&lt; &quot;友元类访问私有数据: &quot; &lt;&lt; obj.privateData &lt;&lt; endl;        cout &lt;&lt; &quot;友元类访问私有消息: &quot; &lt;&lt; obj.secretMessage &lt;&lt; endl;    &#125;        // 友元类也可以有自己的私有成员    void modifyData(MyClass&amp; obj, int newData) &#123;        obj.privateData = newData; // 可以修改私有成员        cout &lt;&lt; &quot;友元类修改后的数据: &quot; &lt;&lt; obj.privateData &lt;&lt; endl;    &#125;&#125;;int main() &#123;    MyClass obj(42, &quot;这是秘密消息&quot;);        cout &lt;&lt; &quot;=== 通过公有方法访问 ===&quot; &lt;&lt; endl;    obj.showPublicInfo();        cout &lt;&lt; &quot;\\n=== 通过友元函数访问 ===&quot; &lt;&lt; endl;    friendFunction(obj); // 调用友元函数        cout &lt;&lt; &quot;\\n=== 通过友元类访问 ===&quot; &lt;&lt; endl;    FriendClass friendObj;    friendObj.accessPrivateData(obj);        cout &lt;&lt; &quot;\\n=== 友元类修改私有数据 ===&quot; &lt;&lt; endl;    friendObj.modifyData(obj, 100);        cout &lt;&lt; &quot;\\n=== 验证修改结果 ===&quot; &lt;&lt; endl;    obj.showPublicInfo(); // 验证私有数据确实被修改了        return 0;&#125;\n可以看到，友元的语法就是在方法或成员变量前面加上friend。\n\n记住：“友元不是敌人，但应该谨慎交友” —— 只给真正需要的函数或类友元权限，并明确其职责边界。\n\n共用体\n共用体（union） 是C++中一种特殊的数据类型，它允许多个不同类型的成员共享同一块内存空间。共用体在同一时刻只能保存其中一个成员的值。\n核心概念\n内存共享：所有成员共享同一块内存大小确定：共用体的大小等于其最大成员的大小单一状态：同一时刻只能有一个成员是有效的手动管理：程序员需要自己跟踪当前存储的是哪个成员\n示例\n#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;// 定义共用体union Data &#123;    int i;           // 整数    float f;         // 浮点数      char str[20];    // 字符串        // C++11起可以有构造函数和析构函数    Data() &#123;&#125;        // 默认构造函数    ~Data() &#123;&#125;       // 析构函数&#125;;int main() &#123;    Data data;        // 存储整数    data.i = 10;    cout &lt;&lt; &quot;整数值: &quot; &lt;&lt; data.i &lt;&lt; endl;        // 存储浮点数 - 会覆盖之前的整数值    data.f = 220.5;    cout &lt;&lt; &quot;浮点数值: &quot; &lt;&lt; data.f &lt;&lt; endl;        // 存储字符串 - 会覆盖之前的浮点数值    strcpy(data.str, &quot;C++ Programming&quot;);    cout &lt;&lt; &quot;字符串值: &quot; &lt;&lt; data.str &lt;&lt; endl;        return 0;&#125;\nstd::variant\n在C++17及之后的标准，有了一个新的联合体方案，下面是联合体的更好的实践\n#include &lt;iostream&gt;#include &lt;variant&gt;#include &lt;string&gt;using namespace std;// 使用std::variant作为类型安全的共用体using JsonValue = variant&lt;int, double, string, bool&gt;;void printJsonValue(const JsonValue&amp; value) &#123;    visit([](auto&amp;&amp; arg) &#123;        cout &lt;&lt; &quot;值: &quot; &lt;&lt; arg &lt;&lt; &quot; (类型: &quot;              &lt;&lt; typeid(decltype(arg)).name() &lt;&lt; &quot;)&quot; &lt;&lt; endl;    &#125;, value);&#125;int main() &#123;    JsonValue values[] = &#123;        42,                 // int        3.14159,           // double          &quot;JSON string&quot;,     // string        true               // bool    &#125;;        for (const auto&amp; val : values) &#123;        printJsonValue(val);    &#125;        return 0;&#125;\n最佳实践建议\n\n\n优先使用std::variant（C++17）：类型安全，自动管理生命周期\n\n\n明确标记当前类型：使用标签字段跟踪当前存储的类型\n\n\n避免非POD类型：除非你完全理解构造/析构的管理\n\n\n考虑内存对齐：共用体的对齐要求等于其最严格对齐成员的对齐要求\n\n\n使用场景：嵌入式系统、协议解析、内存受限环境\n\n\n使用constexpr\n核心概念\n\n\n编译时计算：在编译阶段而非运行时计算结果\n\n\n类型安全：比宏更安全，保留类型检查\n\n\n性能优化：消除运行时开销\n\n\n适用场景：数学计算、配置常量、模板元编程\n\n\n示例\n#include &lt;iostream&gt;using namespace std;// constexpr类 - 所有成员函数和构造函数都必须是constexprclass MathConstants &#123;private:    static constexpr double PI = 3.1415926535; // 编译时常量    public:    // constexpr构造函数    constexpr MathConstants() = default;        // constexpr成员函数    constexpr double getPi() const &#123; return PI; &#125;        // 编译时计算的函数    constexpr double circleArea(double radius) const &#123;        return PI * radius * radius;    &#125;&#125;;// constexpr对象 - 必须用constexpr构造函数初始化constexpr MathConstants mathObj; // 编译时创建的对象int main() &#123;    // 编译时常量    constexpr double radius = 5.0;        // 编译时计算 - 结果在编译时确定    constexpr double area = mathObj.circleArea(radius);        cout &lt;&lt; &quot;圆的面积 (编译时计算): &quot; &lt;&lt; area &lt;&lt; endl;        // 验证：可以在数组大小等需要常量的场合使用    int array[static_cast&lt;int&gt;(area)]; // 编译时确定数组大小        return 0;&#125;\n\nconstexpr成员函数不能修改非静态成员\n\n注意\n推荐使用场景：\n\n\n数学常量和计算：PI、e、阶乘、斐波那契等\n\n\n配置参数：数组大小、缓冲区大小、超时时间\n\n\n编译时验证：配置检查、类型约束\n\n\n模板元编程：作为模板参数\n\n\n性能关键代码：消除运行时开销\n\n\n避免使用场景：\n\n\n需要运行时输入：用户输入、文件读取\n\n\n有副作用的操作：I/O操作、内存分配\n\n\n复杂对象：包含动态内存分配的类\n\n\n多态行为：虚函数不能是constexpr\n\n\n","categories":["C++"],"tags":["C++"]},{"title":"CPP函数","url":"/2026/01/03/CPP%E5%87%BD%E6%95%B0/","content":"函数是一段可重用的代码块，用于执行特定任务。它接收输入（参数），执行操作，并可能返回结果。函数的核心价值在于封装和复用，让我们的代码更加模块化、可维护。\n函数声明与定义\n函数需要先声明后使用。函数声明告诉编译器函数的存在，而函数定义则包含函数的具体实现。\n// 函数声明（通常放在头文件中）int add(int a, int b);// 函数定义（通常放在源文件中）int add(int a, int b) &#123;    return a + b;&#125;\n声明：只包含函数签名，以分号结束，告诉编译器&quot;这个函数存在&quot;。定义：包含函数体（花括号内的代码），告诉编译器&quot;这个函数具体做什么&quot;\n使用函数\n函数的调用\n函数调用是使用函数的过程。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 形参：name 和 agevoid greet(string name, int age) &#123;    cout &lt;&lt; &quot;你好，&quot; &lt;&lt; name &lt;&lt; &quot;! 你今年&quot; &lt;&lt; age &lt;&lt; &quot;岁。&quot; &lt;&lt; endl;&#125;int main() &#123;    // 实参：&quot;小明&quot; 和 25    greet(&quot;小明&quot;, 25);  // 输出：你好，小明! 你今年25岁。        string myName = &quot;小红&quot;;    int myAge = 30;    greet(myName, myAge);  // 输出：你好，小红! 你今年30岁。        return 0;&#125;\n在上面的代码中，greet(&quot;小明&quot;, 25); 和greet(myName, myAge);就是在调用greet函数。\n调用函数时，要有函数名greet，后面紧跟一个()，括号里要传入函数需要的参数，参数在函数声明时就已经决定string name, int age，因此调用greet函数时，括号里必须有两个参数，第一个是string类型的，第二个是int类型的，且顺序不能颠倒(传递的参数可以是变量，也可以是常量，但是类型一定要正确)。\n形参\n形参（形式参数）是函数定义中的变量。在上面的示例中，形参就是name和age，他们在函数声明时被声明，它们的作用域仅在函数greet中。\n\n在函数中修改形参，对调用函数时传入的参数不会有影响，也就是在函数中修改age时，main中的myAge并不会被改变\n\n实参\n实参（实际参数）是调用时传递的具体值。在上面的示例中，实参就是&quot;小明&quot;，25，myName，myAge\n\n上面这种修改形参不会改变实参的方式，在C++中叫做值传递\n\n没有返回值的函数\n在上面的示例中，greet函数的返回值类型是void，这个类型并不在之前讲到的变量类型中。在C++中，void表示’空’，也就是什么也没有。\n在函数中，将返回值类型设置为void表示这个函数没有返回值，也就是说，这个函数不能被放在=的右侧。\n没有参数的函数\n在C++中，完全可以声明并定义一个没有参数的函数，它可以与没有返回值的函数联合使用，用来完成初始化的工作。\n#include &lt;iostream&gt;using namespace std;void initializeSystem() &#123;    cout &lt;&lt; &quot;系统正在初始化...&quot; &lt;&lt; endl;    // 这里可以添加初始化代码    cout &lt;&lt; &quot;系统初始化成功！&quot; &lt;&lt; endl;&#125;int main() &#123;    initializeSystem();  // 调用另一个无参数无返回值函数        return 0;&#125;\n上面这个代码中，就使用了没有返回值没有参数的函数，用来初始化系统。这里只是一个示例，在嵌入式系统中，这种写法更为常见。\n使用场景：\n\n\n显示菜单\n\n\n初始化全局状态\n\n\n执行一次性操作\n\n\n清理资源\n\n\n带默认值的函数参数\n如果要写一个计算圆的面积的函数，一般来说，圆周率取3.14就可以满足要求了，但是有些时候又要更高的精度。这个时候，将它作为函数的一个参数，让用户自行决定使用多高精度的圆周率即可。但是如果不追求高精度，每次调用函数都要输入一次3.14，这对普通用户而言就太麻烦了。这个时候，可以使用带默认值的函数参数。\n#include &lt;iostream&gt;using namespace std;//计算圆的面积，其中参数Pi是带默认参数的double Area(double r, double Pi = 3.14)&#123;    return Pi * r * r;&#125;int main()&#123;    double r = 3;    cout &lt;&lt; &quot;面积为(用默认参数):&quot;&lt;&lt; Area(r) &lt;&lt; endl;    cout &lt;&lt; &quot;面积为(用自定参数):&quot;&lt;&lt; Area(r, 3.1416) &lt;&lt; endl;    return 0;&#125;\n可以看到，在使用了带默认值的参数后，调用函数时可以不传递这个参数，它会使用默认值进行计算；也可以传递自己想使用的值，程序就会用传递的参数进行计算。\n\n\n\n默认参数必须放在非默认参数之后\n\n\n不能跳过中间参数（不能只提供第一个和第三个参数）\n\n\n默认参数在函数声明中指定（如果声明和定义分离）\n\n\n\n递归函数\n前面的代码中，函数自己不会调用自己，如果专门设计一个可以调用自己的函数，那它就被称为递归函数。递归需要两个关键部分：基准条件（base case）和递归条件（recursive case）。\n递归函数适合用于问题本身具有明显递归结构或可自然分解为相同子问题的场景，即：大问题可以拆分为若干个与原问题形式完全相同、规模更小的子问题。也可以用于处理层级结构或嵌套结构或需要在多个选择中不断“尝试—撤销—再尝试”的场景。\n#include &lt;iostream&gt;using namespace std;// 计算阶乘的递归函数unsigned long long factorial(int n) &#123;    // 基准条件    if (n &lt;= 1) &#123;        return 1;    &#125;    // 递归条件    return n * factorial(n - 1);&#125;// 计算斐波那契数列int fibonacci(int n) &#123;    if (n &lt;= 1) &#123;        return n;    &#125;    return fibonacci(n - 1) + fibonacci(n - 2);&#125;int main() &#123;    cout &lt;&lt; &quot;5! = &quot; &lt;&lt; factorial(5) &lt;&lt; endl;      // 输出：120    cout &lt;&lt; &quot;斐波那契数列第8项 = &quot; &lt;&lt; fibonacci(8) &lt;&lt; endl;  // 输出：21        return 0;&#125;\n以阶乘为例，当调用factorial(5)时，调用栈会依次展开：\n\n\nfactorial(5) 调用 factorial(4)\n\n\nfactorial(4) 调用 factorial(3)\n\n\nfactorial(3) 调用 factorial(2)\n\n\nfactorial(2) 调用 factorial(1)\n\n\nfactorial(1) 返回 1\n\n\n然后逐层返回：2×1=2, 3×2=6, 4×6=24, 5×24=120\n\n\n递归也有着诸多缺陷：\n\n\n栈溢出（stack overflow）如果递归太深\n\n\n性能问题\n\n\n因此在实际应用中，考虑使用迭代或尾递归优化。\nreturn\n在函数定义中，并非只能有一条return语句，可以在函数的任何地方返回，如果愿意，还可包含多条return语句\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPrime(int n) &#123;    if (n &lt;= 1) return false;           // 提前返回    if (n == 2 || n == 3) return true;  // 提前返回        for (int i = 2; i * i &lt;= n; i++) &#123;        if (n % i == 0) &#123;            return false;  // 发现因子，提前返回        &#125;    &#125;        return true;  // 所有检查通过，是质数&#125;int main() &#123;    cout &lt;&lt; &quot;7是质数: &quot; &lt;&lt; isPrime(7) &lt;&lt; endl;     // 输出：1 (true)    cout &lt;&lt; &quot;15是质数: &quot; &lt;&lt; isPrime(15) &lt;&lt; endl;   // 输出：0 (false)        return 0;&#125;\n使用return可以中断函数的运行，如果是无返回值的函数，可以使用return;返回。\n函数重载\n函数重载允许在同一个作用域内定义多个同名函数，但参数列表不同（参数类型、数量或顺序不同）。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 重载函数：不同参数类型void print(int value) &#123;    cout &lt;&lt; &quot;整数: &quot; &lt;&lt; value &lt;&lt; endl;&#125;void print(double value) &#123;    cout &lt;&lt; &quot;浮点数: &quot; &lt;&lt; value &lt;&lt; endl;&#125;void print(string value) &#123;    cout &lt;&lt; &quot;字符串: &quot; &lt;&lt; value &lt;&lt; endl;&#125;// 重载函数：不同参数数量void log(string message) &#123;    cout &lt;&lt; &quot;[信息] &quot; &lt;&lt; message &lt;&lt; endl;&#125;void log(string message, string level) &#123;    cout &lt;&lt; &quot;[&quot; &lt;&lt; level &lt;&lt; &quot;] &quot; &lt;&lt; message &lt;&lt; endl;&#125;int main() &#123;    print(42);           // 调用 print(int)    print(3.14159);      // 调用 print(double)    print(&quot;你好&quot;);       // 调用 print(string)        log(&quot;系统已启动&quot;);                // 调用 log(string)    log(&quot;数据库连接成功&quot;, &quot;成功&quot;);    // 调用 log(string, string)        return 0;&#125;\n函数重载必须保证函数名和返回类型相同，只有参数可以不同。\n多态\n这里可以引出面向对象语言的三大特性之一：多态。多态的字面意思是多种形态，后面会专门介绍，这里只需要知道函数重载就是其中的一种情况。\n多态分为两种：\n\n\n编译时多态：通过函数重载和运算符重载实现，编译器在编译时就确定调用哪个函数。\n\n\n运行时多态：通过虚函数和继承实现，程序在运行时根据对象的实际类型决定调用哪个函数。\n\n\n传递数组\n数组的传递是以指针的方式传递的。指针简单来说就是地址，前面提到，数组在内存中是连续存储的，因此，只要知道数组的第一个元素的地址，后面的任意元素的地址都可以计算出来。将指针传递给函数，就是将数组的首地址传递给了函数，函数就可以对数组进行操作\n\n这里要注意，操作数组就是在操作地址，所以在函数里修改数组会把原来的数组也修改了。还需要注意，由于传递数组的本质是传递指针，所以数组失去了大小的信息，所以要显式传递数组的大小。\n\n#include &lt;iostream&gt;using namespace std;// 方法1：传递数组指针（最常见）void printArray(int arr[], int size) &#123;    cout &lt;&lt; &quot;数组内容: &quot;;    for (int i = 0; i &lt; size; i++) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;// 方法2：传递指针和大小（更明确）int* arr表示声明了一个int类型的指针，名字叫做arrvoid processArray(int* arr, int size) &#123;    cout &lt;&lt; &quot;处理大小为&quot; &lt;&lt; size &lt;&lt; &quot;的数组: &quot;;    for (int i = 0; i &lt; size; i++) &#123;        arr[i] *= 2;  // 修改原始数组    &#125;&#125;int main() &#123;    int numbers[] = &#123;1, 2, 3, 4, 5&#125;;    int size = sizeof(numbers) / sizeof(numbers[0]);        cout &lt;&lt; &quot;原始数组: &quot;;    printArray(numbers, size);  //运行结果：1 2 3 4 5        processArray(numbers, size);        cout &lt;&lt; &quot;修改后的数组: &quot;;    printArray(numbers, size);  //运行结果：2 4 6 8 10        return 0;&#125;\n按引用传递\nC++的值传递相当于运行了一次赋值，这就导致参数实际上是被复制了一份，对于一些数据结构，对它进行赋值拷贝需要很大的开销，为了避免这些开销，可以使用引用传递。\n引用传递就好像给实参起了一个别名，这样使用这个别名也相当于操作了这个实参，因此引用传递的参数如果在函数中被修改，那么实参也会对应的被修改。\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;// 按值传递：不会修改原始变量void modifyByValue(int x) &#123;    x = 100;    cout &lt;&lt; &quot;在modifyByValue函数内: x = &quot; &lt;&lt; x &lt;&lt; endl;&#125;// 按引用传递：会修改原始变量void modifyByReference(int&amp; x) &#123;    x = 200;    cout &lt;&lt; &quot;在modifyByReference函数内: x = &quot; &lt;&lt; x &lt;&lt; endl;&#125;// 常量引用：既避免拷贝，又保护数据不被修改void printString(const string&amp; str) &#123;    cout &lt;&lt; &quot;字符串长度: &quot; &lt;&lt; str.length() &lt;&lt; endl;    cout &lt;&lt; &quot;内容: &quot; &lt;&lt; str &lt;&lt; endl;&#125;// 引用传递大对象：显著提高效率void processVector(vector&lt;int&gt;&amp; vec) &#123;    cout &lt;&lt; &quot;处理包含&quot; &lt;&lt; vec.size() &lt;&lt; &quot;个元素的向量&quot; &lt;&lt; endl;    for (int&amp; num : vec) &#123;        num *= 2;    &#125;&#125;int main() &#123;    int value = 10;        cout &lt;&lt; &quot;调用modifyByValue前: value = &quot; &lt;&lt; value &lt;&lt; endl;    modifyByValue(value);    cout &lt;&lt; &quot;调用modifyByValue后: value = &quot; &lt;&lt; value &lt;&lt; endl;        cout &lt;&lt; &quot;\\n调用modifyByReference前: value = &quot; &lt;&lt; value &lt;&lt; endl;    modifyByReference(value);    cout &lt;&lt; &quot;调用modifyByReference后: value = &quot; &lt;&lt; value &lt;&lt; endl;        string text = &quot;你好，C++！&quot;;    printString(text);  // 不会修改text，且避免了拷贝        vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;    processVector(numbers);    cout &lt;&lt; &quot;修改后的向量: &quot;;    for (int num : numbers) &#123;        cout &lt;&lt; num &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;\n按引用传递与指针传递不同，指针可以重新指向另一个地址，但是引用一旦被赋值，就不能再引用其他变量。\n按引用传参的优势：\n\n\n避免大对象的拷贝开销\n\n\n允许函数修改调用者的变量\n\n\n可以返回多个值（通过多个引用参数）\n\n\n常量引用（const &amp;）的最佳实践：\n\n\n当函数不需要修改参数时，使用const引用\n\n\n既获得引用的效率，又保证数据的安全性\n\n\n适用于字符串、容器、自定义对象等大对象\n\n\n三种传递方式的区别\n\n\n\n\n按值传递\n按引用传递\n按指针传递\n\n\n\n\n参数复制\n需要复制实参\n不需要复制实参\n复制指针\n\n\n内存消耗\n可能较大\n较小\n较小\n\n\n安全性\n安全\n较安全\n不安全\n\n\n\n处理器操作\n函数的调用在计算机内部，就是一个入栈出栈的操作。\n栈\n栈是C++在操作程序的时候规定的一片空间，栈的特点是先入后出。这就像放盘子和拿盘子一样，你会将最先洗完的盘子放在最下面，最后洗完的盘子放在上面；在使用盘子时则相反，你会先拿上面的盘子使用。\n函数与栈\n看下面的示例代码\n#include &lt;iostream&gt;using namespace std;void functionB(int y) &#123;    cout &lt;&lt; &quot;在functionB函数内, y = &quot; &lt;&lt; y &lt;&lt; endl;&#125;void functionA(int x) &#123;    cout &lt;&lt; &quot;在functionA函数内, x = &quot; &lt;&lt; x &lt;&lt; endl;    functionB(x + 10);&#125;int main() &#123;    cout &lt;&lt; &quot;开始执行main函数&quot; &lt;&lt; endl;    functionA(5);    cout &lt;&lt; &quot;回到main函数&quot; &lt;&lt; endl;    return 0;&#125;\n运行结果：\n开始执行main函数在functionA函数内, x = 5在functionB函数内, y = 15回到main函数\n上面这个代码在计算机的流程如图所示可以看到栈指针一直指向栈顶，在栈指针指向的位置可以插入下一个元素。\n当程序开始运行，会依次进行下面的步骤：\n\n\n首先运行main函数，将main压入栈\n\n\nmain中调用了functionA，此时将functionA压入栈\n\n\nfunctionA中调用了functionB，此时将functionB压入栈\n\n\nfunctionB运行结束，将functionB弹出\n\n\nfunctionA运行结束，将functionA弹出\n\n\nmain运行结束，将main弹出\n\n\n程序运行结束\n\n\n\n从上面的步骤可以看出，调用函数与直接将逻辑写在main函数里相比，调用函数会有额外的开销，因此要避免频繁地调用函数的行为。\n\n\n但是如果一段逻辑会被多次使用，仍然建议把它封装为函数。这是因为在每个需要使用这段逻辑的地方重写代码不仅费时费力，还会让程序占用更多的空间。\n\n内联函数\n内联函数（inline）是一种编译器优化，将函数调用替换为函数体本身，避免函数调用开销。语法就是在普通函数定义方式的前面加上inline\n#include &lt;iostream&gt;#include &lt;chrono&gt;using namespace std;using namespace chrono;// 普通函数int addRegular(int a, int b) &#123;    return a + b;&#125;// 内联函数inline int addInline(int a, int b) &#123;    return a + b;&#125;int main() &#123;    //计时器    const int iterations = 10000000;    auto start1 = high_resolution_clock::now();        // 测试普通函数    int sum1 = 0;    for (int i = 0; i &lt; iterations; i++) &#123;        sum1 += addRegular(i, i + 1);    &#125;    //结束计时    auto end1 = high_resolution_clock::now();    auto duration1 = duration_cast&lt;milliseconds&gt;(end1 - start1);        //计时器    auto start2 = high_resolution_clock::now();    // 测试内联函数    int sum2 = 0;    for (int i = 0; i &lt; iterations; i++) &#123;        sum2 += addInline(i, i + 1);    &#125;    //结束计时    auto end2 = high_resolution_clock::now();    auto duration2 = duration_cast&lt;milliseconds&gt;(end2 - start2);        cout &lt;&lt; &quot;普通函数耗时: &quot; &lt;&lt; duration1.count() &lt;&lt; &quot; 毫秒&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;内联函数耗时: &quot; &lt;&lt; duration2.count() &lt;&lt; &quot; 毫秒&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;结果: &quot; &lt;&lt; sum1 &lt;&lt; &quot;, &quot; &lt;&lt; sum2 &lt;&lt; endl;        return 0;&#125;\n结果为：\n普通函数耗时: 15 毫秒内联函数耗时: 14 毫秒结果: 276447232, 276447232\n这段程序在运行时并不一定总是内联函数耗时更短，导致这种现象的原因有很多种可能。首先inline只是给编译器的建议，编译器并不一定会采取内联的方式，而不加内联的普通函数也有可能被编译器自动优化为内联函数，这是编译器自带的优化。再往底层考虑也会有多种可能，甚至硬件的状态也会影响结果。尽管如此，仍然建议将非常简单的函数声明为内联函数。\n\n这是一种用内存换时间的方案\n\n自动推断返回类型\n前面我们说过可以用auto关键字自动推断变量类型，在C++14之后，函数的返回类型也可以使用auto自动推断。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;// 基本用法：auto推断返回类型auto add(int a, int b) &#123;    return a + b;  // 编译器推断返回类型为int&#125;// 复杂类型推断auto getMinMax(const vector&lt;int&gt;&amp; vec) &#123;    if (vec.empty()) &#123;        return make_pair(0, 0);  // 返回pair&lt;int, int&gt;    &#125;    auto minmax = minmax_element(vec.begin(), vec.end());    return make_pair(*minmax.first, *minmax.second);&#125;int main() &#123;    cout &lt;&lt; &quot;add(5, 3) = &quot; &lt;&lt; add(5, 3) &lt;&lt; endl;        vector&lt;int&gt; numbers = &#123;3, 1, 4, 1, 5, 9, 2, 6&#125;;    auto result = getMinMax(numbers);    cout &lt;&lt; &quot;最小值: &quot; &lt;&lt; result.first &lt;&lt; &quot;, 最大值: &quot; &lt;&lt; result.second &lt;&lt; endl;        return 0;&#125;\n可以看到，当函数返回复杂的类型时，可以使用auto自动推断，这在模板编程中特别有用。\n\n注意：递归函数必须显式指定返回类型\n\nLambda函数\n本节只会简单介绍Lambda函数，因为完全学习它需要一些还未学到的知识做支撑。但是为了能够更加系统的建立起知识网络，这里还是要简单学习。\nlambda函数的基本语法为\n[capture](parameters) -&gt; return_type &#123;    // 函数体&#125;\n下面是一个使用示例\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;int main() &#123;    vector&lt;int&gt; numbers = &#123;5, 2, 8, 1, 9, 3, 7, 4&#125;;        cout &lt;&lt; &quot;原始向量: &quot;;    for (int num : numbers)         cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;        // 简单的lambda：捕获空，参数为两个int，返回bool    sort(numbers.begin(), numbers.end(), [](int a, int b) &#123;        return a &lt; b;    &#125;);        cout &lt;&lt; &quot;升序排序后: &quot;;    for (int num : numbers) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n其中，lambda函数是[](int a, int b){ return a &lt; b; }这部分，它成为了sort函数的一个参数。很明显可以看出，这个lambda函数的作用是当a&lt;b时，返回true，也就是让动态数组升序排列。运行结果为\n原始向量: 5 2 8 1 9 3 7 4 升序排序后: 1 2 3 4 5 7 8 9","categories":["C++"],"tags":["C++"]},{"title":"C++程序组成","url":"/2025/12/25/%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%88%90/","content":"C++程序组成\nC++ 的语法与 C 语言高度相似，最初确实是作为 C 语言的扩展而诞生的。然而，随着时间的发展，C++ 已演变为一门独立且功能丰富的编程语言。作为一门支持面向对象编程（OOP）的语言，C++ 引入了许多 C 语言所不具备的特性，其中最具代表性的是面向对象的三大核心特征：封装、继承和多态。此外，C++ 的标准库也与 C 语言有显著不同，例如提供了标准模板库（STL）、更安全的字符串和容器类型等。因此，即便已经掌握了 C 语言，也不应轻视 C++ 的复杂性和深度，而应将其视为一门全新的语言来系统学习。\nC++程序基本构成\n以下面这个简单的C++程序为例\n//头文件#include &lt;iostream&gt;//主函数int main()&#123;    //功能    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    //返回值    return 0;&#125;  \n首先是头文件#include &lt;iostream&gt;，#include &lt;&gt;是C++引入头文件的语法，iostream则是头文件的文件名，头文件可以理解为实现了某些功能的文件，引入头文件才能在自己的代码中使用这些功能。iostream是C++提供的标准库。\n下面是主函数部分，语法为\nint main()&#123;    return 0;&#125;  \n主函数是程序的入口点，首先是int main()，这是函数头，int表示这个函数的返回值的类型是整数，main是函数的名字，main 函数可以定义为带参数的形式int main(int argc, char* argv[])，用于接收命令行参数。花括号{}括住的部分是这个函数的代码块，return 0;表示返回一个数字0，这个返回值是个整数，与int main()中的int对应。一般来说，函数返回了0表示程序成功执行并正常退出，非零返回值（包括 -1）通常表示程序执行出错或异常退出。\n接下来是编写函数功能的代码\nstd::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;\n这两行代码的含义是输出两行文本到命令行，第一行是&quot;Hello World&quot;，第二行是&quot;你好，世界&quot;。\nstd是一个命名空间，它的作用是：避免全局作用域中的名称冲突，例如当代码里有两个地方分别写了同一个相同名称的函数(函数是完成某个固定功能的代码块，通过名称区分)，但是他们的代码不同，那么在使用这个函数时，编译器会不知道到底调用哪里的函数，这时就可以使用命名空间来区分它们。\nstd::cout的含义就是使用std命名空间中的cout函数(这里其实并不正确，cout是std中定义的一个流，但是现在这样更好理解)。&lt;&lt;是流插入运算符，意思是把运算符后面的内容插入到运算符前面的流中。std::endl作用是换行和刷新输出缓冲区。\n要使用std::cout和std::endl必须包含头文件#include &lt;iostream&gt;，因为它们定义在iostream文件中。\n\n需要注意的是：C++中每一条语句后面都要加分号;，可以看到在代码中，只有#include &lt;iostream&gt;并没有加分号，因为预处理指令并不是 C++ 语句。\n\n最后介绍一下C++的注释，//是注释符号，//后面一整行的内容都是注释部分，注释在程序中起到解释代码含义的作用，它并不会被编译器编译，也就是说，在编译器的眼中，这个代码是这个样子的\n#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n另外，也可以使用多行注释，格式是/* 这里写注释 */，例如\n#include &lt;iostream&gt;/*我可以跨多行，只要在这两个符号中间的都是注释*/int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;//我只负责这一行    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n命名空间\n在前面介绍代码的基本结构时，已经简单介绍过命名空间，总而言之，命名空间是为了避免全局作用域中的名称冲突，这里面的名称冲突并不仅仅包含函数名，也包括变量名，也包括流等等。\n在学习C++时，写的代码比较简单，一般不会出现命名冲突，这个时候可以简化写法\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    return 0;&#125;\n可以看到，使用了using namespace std声明了std这个命名空间后，写cout和endl时就不需要在前面明确std了。\n但是这样有时会无法确定std命名空间中的其他名称是否会发生冲突，因此更推荐的用法是\n#include &lt;iostream&gt;//using namespace std;using std::cout, std::endl;int main()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    return 0;&#125;\n这个示例中，通过使用using，也实现了简化写法的功能。二者的区别是：前者可以在使用std中定义的所有内容都无需加std::；后者只有cout和endl可以不加std::。\n函数\n函数能够将应用程序划分成多个功能单元，程序员通常需要编写自己的函数。\n下面是一个使用函数的示例\n#include &lt;iostream&gt;using std::cout, std::endl;//声明函数int sum(int a, int b);int main()&#123;    int x=1,y=2;        //这里是定义了两个整数类型的变量，并给他们赋值为1和2    cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; sum(x,y) &lt;&lt; endl; //函数可以在其他语句中被调用    int result = sum(x,y);              //函数的返回值可以被赋值给变量    cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; result &lt;&lt; endl;   //将变量输出    cout &lt;&lt; &quot;1+2=&quot; &lt;&lt; sum(1,2) &lt;&lt; endl; //传递给函数的不一定是变量，也可以是常量    return 0;&#125;//定义函数，函数需要传递两个整数(int)int sum(int a, int b)&#123;    int res = a+b;  //使用两个变量进行求和运算    return res;     //返回计算结果&#125;\n使用函数前要先声明函数，可以理解为这是在告诉编译器：我有这样一个函数，名字是sum，返回值是整数类型，需要传递两个整数类型的参数，虽然我现在还没有告诉你它里面具体做了什么，但是我在后面会告诉你，你不要报错。\n在后面要定义函数，用{}包裹住的是这个函数的实现步骤。\n\n若函数定义在 main 之前，则无需单独声明。\n\nIO操作\nI表示输入，O表示输出。在写代码时，不能仅仅考虑输出结果(通过cout输出)，还要考虑如何读取用户的输入，读取输入的语法与输出结果类似。\n#include &lt;iostream&gt;//定义IOfunc函数int IOfunc()&#123;    int a, b;    std::cout &lt;&lt; &quot;请输入两个整数（用空格分开）：&quot;;    //读取用户输入的整数，将其放到变量a和b中    std::cin &gt;&gt; a &gt;&gt; b;    std::cout &lt;&lt; &quot;您输入的第一个数是：&quot; &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;您输入的第二个数是：&quot; &lt;&lt; b &lt;&lt; std::endl;    return 0;&#125;int main()&#123;    //调用IOfunc函数    IOfunc();    return 0;&#125;\n运行结果为\n请输入两个整数（用空格分开）：3 99您输入的第一个数是：3您输入的第二个数是：99\n读取输入使用std::cin，后面使用提取运算符&gt;&gt;，将输入流中的数据提取到变量中。输入的数据之间要通过空格隔开，按下回车就相当于输入完毕，代码才会继续向后执行。\n运算符\nC++中有多种运算符，例如前面用到的&lt;&lt;和&gt;&gt;，这里先介绍常用的算术运算符\n\n\n\n运算符\n描述\n实例\n\n\n\n\n+\n把两个操作数相加\nA+B（10+20）将得到30\n\n\n-\n从第一个操作数中减去第二个操作数\nA-B（10-20）将得到-10\n\n\n*\n把两个操作数相乘\nA*B（10x20）将得到200\n\n\n/\n分子除以分母\nB/A（20/10）将得到2\n\n\n%\n取模运算符，整除后的余数\nB%A（20%10）将得到0\n\n\n++\n自增运算符，整数值增加1\nA++将得到11\n\n\n--\n自减运算符，整数值减少1\nA--将得到9\n\n\n\n\n=并不是相等的运算符，在C++中，这表示赋值，也就是将=右边赋值给=左边。\n\n","categories":["C++"],"tags":["C++"]}]