[{"title":"CPP运算符","url":"/2026/01/01/CPP%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"元\n首先介绍元，元表示操作的个数，也就是一个运算符需要几个操作数才能完成运算。例如赋值符号=,它的用法是a=3，在这个过程中，a是它的一个操作数，3也是它的操作数，所以=是二元运算符。再比如! flag，其中的!也是一个运算符(下面会讲)，但是它只有一个操作数’flag’，因此它是一元运算符。\n左值和右值\n在C++中，左值一般是指向一个内存单元的，它一般可修改，可寻址，可持久。\n右值一般是临时对象，它一般不可寻址，短暂存在，不可修改。\na = 7;\n在上面这个语句中，a指向内存中的一个地址，且可以长期存在，因此它是左值；而7则是一个临时的值，这个语句结束后就会被销毁，因此它是右值。\n示例代码\n在前面的章节中，已经简单的介绍过了几个运算符，这一节是更详细的展开。\n这一部分将围绕C++中的运算符展开，这里会先给出本节的完整的示例代码，方便复制粘贴。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //加减乘除和取模    cout &lt;&lt; &quot;===== 1. 加减乘除和取模运算符 =====&quot; &lt;&lt; endl;    int a = 10, b = 3;    cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; &quot; (加法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; &quot; (减法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; &quot; (乘法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; / &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a / b &lt;&lt; &quot; (除法，整数除法会截断小数部分)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; % &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a % b &lt;&lt; &quot; (取模，取余数)&quot; &lt;&lt; endl;        double c = 10.0, d = 3.0;    cout &lt;&lt; c &lt;&lt; &quot; / &quot; &lt;&lt; d &lt;&lt; &quot; = &quot; &lt;&lt; c / d &lt;&lt; &quot; (浮点数除法，保留小数)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //递增和递减运算符    cout &lt;&lt; &quot;===== 2. 递增和递减运算符 =====&quot; &lt;&lt; endl;    int num = 5;    cout &lt;&lt; &quot;初始值: num = &quot; &lt;&lt; num &lt;&lt; endl;        num++; // 等价于 num = num + 1    cout &lt;&lt; &quot;num++ 后: num = &quot; &lt;&lt; num &lt;&lt; endl;        num--; // 等价于 num = num - 1    cout &lt;&lt; &quot;num-- 后: num = &quot; &lt;&lt; num &lt;&lt; endl;    cout &lt;&lt; endl;        //递增(递减)运算符的前缀和后缀    cout &lt;&lt; &quot;===== 3. 递增(递减)运算符的前缀和后缀 =====&quot; &lt;&lt; endl;    int x = 10;        // 后缀形式：先使用值，再递增    cout &lt;&lt; &quot;后缀 x++: &quot;;    cout &lt;&lt; &quot;x++ = &quot; &lt;&lt; x++ &lt;&lt; &quot; (先输出x的值，再递增)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;递增后 x = &quot; &lt;&lt; x &lt;&lt; endl;        // 前缀形式：先递增，再使用值    cout &lt;&lt; &quot;前缀 ++x: &quot;;    cout &lt;&lt; &quot;++x = &quot; &lt;&lt; ++x &lt;&lt; &quot; (先递增，再输出x的值)&quot; &lt;&lt; endl;        int y = 20;    cout &lt;&lt; &quot;后缀 y--: &quot;;    cout &lt;&lt; &quot;y-- = &quot; &lt;&lt; y-- &lt;&lt; &quot; (先输出y的值，再递减)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;递减后 y = &quot; &lt;&lt; y &lt;&lt; endl;        cout &lt;&lt; &quot;前缀 --y: &quot;;    cout &lt;&lt; &quot;--y = &quot; &lt;&lt; --y &lt;&lt; &quot; (先递减，再输出y的值)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //相等运算符和不等运算符    cout &lt;&lt; &quot;===== 4. 相等运算符和不等运算符 =====&quot; &lt;&lt; endl;    int m = 15, n = 15, p = 20;        cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m == n ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m == p ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m != n ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m != p ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;        //关系运算符    cout &lt;&lt; &quot;===== 5. 关系运算符 =====&quot; &lt;&lt; endl;    int val1 = 25, val2 = 30;        cout &lt;&lt; val1 &lt;&lt; &quot; &gt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;        //逻辑运算符    cout &lt;&lt; &quot;===== 6. 逻辑运算符 =====&quot; &lt;&lt; endl;    bool flag1 = true, flag2 = false;        cout &lt;&lt; &quot;flag1 = &quot; &lt;&lt; (flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag2 = &quot; &lt;&lt; (flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        cout &lt;&lt; &quot;flag1 &amp;&amp; flag2 (逻辑与): &quot; &lt;&lt; (flag1 &amp;&amp; flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag1 || flag2 (逻辑或): &quot; &lt;&lt; (flag1 || flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag1 (逻辑非): &quot; &lt;&lt; (!flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag2 (逻辑非): &quot; &lt;&lt; (!flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        // 逻辑运算符的短路特性    int test = 0;    cout &lt;&lt; &quot;短路特性示例 (false &amp;&amp; ...): &quot; &lt;&lt; (false &amp;&amp; (test = 5)) &lt;&lt; endl;    cout &lt;&lt; &quot;test 的值: &quot; &lt;&lt; test &lt;&lt; &quot; (因为短路，赋值没有执行)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //按位运算符    cout &lt;&lt; &quot;===== 7. 按位运算符 =====&quot; &lt;&lt; endl;    unsigned int bits1 = 6;  // 二进制: 0110    unsigned int bits2 = 3;  // 二进制: 0011        cout &lt;&lt; bits1 &lt;&lt; &quot; &amp; &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 &amp; bits2) &lt;&lt; &quot; (按位与)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; | &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 | bits2) &lt;&lt; &quot; (按位或)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; ^ &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 ^ bits2) &lt;&lt; &quot; (按位异或)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;~&quot; &lt;&lt; bits1 &lt;&lt; &quot; = &quot; &lt;&lt; (~bits1) &lt;&lt; &quot; (按位取反，注意符号位)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &lt;&lt; 1 = &quot; &lt;&lt; (bits1 &lt;&lt; 1) &lt;&lt; &quot; (左移1位，相当于乘以2)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &gt;&gt; 1 = &quot; &lt;&lt; (bits1 &gt;&gt; 1) &lt;&lt; &quot; (右移1位，相当于除以2)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //复合赋值运算符    cout &lt;&lt; &quot;===== 8. 复合赋值运算符 =====&quot; &lt;&lt; endl;    int compound = 10;        cout &lt;&lt; &quot;初始值: compound = &quot; &lt;&lt; compound &lt;&lt; endl;    compound += 5;  // compound = compound + 5    cout &lt;&lt; &quot;compound += 5 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound -= 3;  // compound = compound - 3    cout &lt;&lt; &quot;compound -= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound *= 2;  // compound = compound * 2    cout &lt;&lt; &quot;compound *= 2 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound /= 4;  // compound = compound / 4    cout &lt;&lt; &quot;compound /= 4 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound %= 3;  // compound = compound % 3    cout &lt;&lt; &quot;compound %= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        int bitwise = 12; // 二进制: 1100    bitwise &amp;= 10;    // 10是1010，按位与后：1000 (8)    cout &lt;&lt; &quot;bitwise &amp;= 10 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise |= 3;     // 3是0011，按位或后：1011 (11)    cout &lt;&lt; &quot;bitwise |= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise ^= 1;     // 1是0001，按位异或后：1010 (10)    cout &lt;&lt; &quot;bitwise ^= 1 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &lt;&lt;= 2;    // 左移2位：101000 (40)    cout &lt;&lt; &quot;bitwise &lt;&lt;= 2 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &gt;&gt;= 3;    // 右移3位：101 (5)    cout &lt;&lt; &quot;bitwise &gt;&gt;= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;    cout &lt;&lt; endl;        //sizeof运算符    cout &lt;&lt; &quot;===== 9. sizeof运算符 =====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(double) = &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(bool) = &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;        int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; &quot;数组 arr 的大小: sizeof(arr) = &quot; &lt;&lt; sizeof(arr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = &quot;          &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; &quot; 个&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;sizeof(10) = &quot; &lt;&lt; sizeof(10) &lt;&lt; &quot; 字节 (字面量的大小)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(10 + 3.14) = &quot; &lt;&lt; sizeof(10 + 3.14) &lt;&lt; &quot; 字节 (表达式的结果类型大小)&quot; &lt;&lt; endl;        return 0;&#125;\n加减乘除与取模\n//加减乘除和取模cout &lt;&lt; &quot;===== 1. 加减乘除和取模运算符 =====&quot; &lt;&lt; endl;int a = 10, b = 3;cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; &quot; (加法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; &quot; (减法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; &quot; (乘法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; / &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a / b &lt;&lt; &quot; (除法，整数除法会截断小数部分)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; % &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a % b &lt;&lt; &quot; (取模，取余数)&quot; &lt;&lt; endl;double c = 10.0, d = 3.0;cout &lt;&lt; c &lt;&lt; &quot; / &quot; &lt;&lt; d &lt;&lt; &quot; = &quot; &lt;&lt; c / d &lt;&lt; &quot; (浮点数除法，保留小数)&quot; &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 1. 加减乘除和取模运算符 =====10 + 3 = 13 (加法)10 - 3 = 7 (减法)10 * 3 = 30 (乘法)10 / 3 = 3 (除法，整数除法会截断小数部分)10 % 3 = 1 (取模，取余数)10 / 3 = 3.33333 (浮点数除法，保留小数)\n这里的运算符与计算器上的一致，只需要注意\n\n\n如果是两个整数类型的变量或两个整数字面常量(也就是没有小数点)进行除法运算，小数部分会被直接舍去。\n\n\n如果其中一个是浮点数，那么计算出来的就是浮点数。\n\n\n递增与递减\n//递增和递减运算符cout &lt;&lt; &quot;===== 2. 递增和递减运算符 =====&quot; &lt;&lt; endl;int num = 5;cout &lt;&lt; &quot;初始值: num = &quot; &lt;&lt; num &lt;&lt; endl;num++; // 等价于 num = num + 1cout &lt;&lt; &quot;num++ 后: num = &quot; &lt;&lt; num &lt;&lt; endl;num--; // 等价于 num = num - 1cout &lt;&lt; &quot;num-- 后: num = &quot; &lt;&lt; num &lt;&lt; endl;cout &lt;&lt; endl;//递增(递减)运算符的前缀和后缀cout &lt;&lt; &quot;===== 3. 递增(递减)运算符的前缀和后缀 =====&quot; &lt;&lt; endl;int x = 10;// 后缀形式：先使用值，再递增cout &lt;&lt; &quot;后缀 x++: &quot;;cout &lt;&lt; &quot;x++ = &quot; &lt;&lt; x++ &lt;&lt; &quot; (先输出x的值，再递增)&quot; &lt;&lt; endl;cout &lt;&lt; &quot;递增后 x = &quot; &lt;&lt; x &lt;&lt; endl;// 前缀形式：先递增，再使用值cout &lt;&lt; &quot;前缀 ++x: &quot;;cout &lt;&lt; &quot;++x = &quot; &lt;&lt; ++x &lt;&lt; &quot; (先递增，再输出x的值)&quot; &lt;&lt; endl;int y = 20;cout &lt;&lt; &quot;后缀 y--: &quot;;cout &lt;&lt; &quot;y-- = &quot; &lt;&lt; y-- &lt;&lt; &quot; (先输出y的值，再递减)&quot; &lt;&lt; endl;cout &lt;&lt; &quot;递减后 y = &quot; &lt;&lt; y &lt;&lt; endl;cout &lt;&lt; &quot;前缀 --y: &quot;;cout &lt;&lt; &quot;--y = &quot; &lt;&lt; --y &lt;&lt; &quot; (先递减，再输出y的值)&quot; &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 2. 递增和递减运算符 =====初始值: num = 5num++ 后: num = 6num-- 后: num = 5===== 3. 递增(递减)运算符的前缀和后缀 =====后缀 x++: x++ = 10 (先输出x的值，再递增)递增后 x = 11前缀 ++x: ++x = 12 (先递增，再输出x的值)后缀 y--: y-- = 20 (先输出y的值，再递减)递减后 y = 19前缀 --y: --y = 18 (先递减，再输出y的值)\n先看第一部分的代码，可以看到++和--可以使变量+1或者-1，这就是自增和自减运算符的作用。\n再看第二段代码，可以看到自增和自减运算符可以放在变量前面和变量后面。放在变量前面会先进行递增(减)，然后被使用；放在变量后面会先被使用，然后再递增(减)。\n相等与不等\n//相等运算符和不等运算符cout &lt;&lt; &quot;===== 4. 相等运算符和不等运算符 =====&quot; &lt;&lt; endl;int m = 15, n = 15, p = 20;cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m == n ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m == p ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m != n ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m != p ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 4. 相等运算符和不等运算符 =====15 == 15 : 相等15 == 20 : 不相等15 != 15 : 相等15 != 20 : 不相等\n在C++中，=表示赋值，==表示判断左值和右值是否相等，相等返回true，否则返回false。\n!=则相反，如果左值和右值相等，则返回false，否则返回true。\n在代码中还可以看到一种运算符?  : ，这叫做三元运算符，因为它需要三个操作数，格式为\n条件表达式 ? 表达式1 : 表达式2\n它会首先计算条件表达式，如果条件表达式返回true，则计算并返回表达式1的值；如果条件表达式返回false，则计算并返回表达式2的值\n\n在C++中，表达式的值只要不是0，就可以表示true；表达式的值是0则表示false。\n\n关系运算符\n//关系运算符    cout &lt;&lt; &quot;===== 5. 关系运算符 =====&quot; &lt;&lt; endl;    int val1 = 25, val2 = 30;        cout &lt;&lt; val1 &lt;&lt; &quot; &gt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 5. 关系运算符 =====25 &gt; 30 : 假25 &lt; 30 : 真25 &gt;= 30 : 假25 &lt;= 30 : 真\n关系运算符返回的结果是true和false。只要左值和右值满足关系运算符的关系，就会返回true，否则返回false。代码中的&lt;表示小于号，&gt;表示大于号，&lt;=表示小于等于号，&gt;=表示大于等于号。\n逻辑运算符\n//逻辑运算符    cout &lt;&lt; &quot;===== 6. 逻辑运算符 =====&quot; &lt;&lt; endl;    bool flag1 = true, flag2 = false;        cout &lt;&lt; &quot;flag1 = &quot; &lt;&lt; (flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag2 = &quot; &lt;&lt; (flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        cout &lt;&lt; &quot;flag1 &amp;&amp; flag2 (逻辑与): &quot; &lt;&lt; (flag1 &amp;&amp; flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag1 || flag2 (逻辑或): &quot; &lt;&lt; (flag1 || flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag1 (逻辑非): &quot; &lt;&lt; (!flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag2 (逻辑非): &quot; &lt;&lt; (!flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        // 逻辑运算符的短路特性    int test = 0;    cout &lt;&lt; &quot;短路特性示例 (false &amp;&amp; ...): &quot; &lt;&lt; (false &amp;&amp; (test = 5)) &lt;&lt; endl;    cout &lt;&lt; &quot;test 的值: &quot; &lt;&lt; test &lt;&lt; &quot; (因为短路，赋值没有执行)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 6. 逻辑运算符 =====flag1 = trueflag2 = falseflag1 &amp;&amp; flag2 (逻辑与): falseflag1 || flag2 (逻辑或): true!flag1 (逻辑非): false!flag2 (逻辑非): true短路特性示例 (false &amp;&amp; ...): 0test 的值: 0 (因为短路，赋值没有执行)\n可以直接用布尔类型bool的变量来表示true和false。\n接下来介绍与、或、非。与&amp;&amp;表示符号两边的表达式都为true，才会返回true；或||(键盘上是shift+\\ )表示符号两边的表达式任一为true，就会返回true；非!表示符号后面的表达式的结果的相反结果，当后面的表达式结果为true时，就会返回false。\n接下来介绍一下逻辑运算符的短路特性，也就是说：逻辑运算符两边的表达式不是同时计算的，当第一个计算的表达式的结果可以决定最后结果时，另一个表达式就不会被计算。\n逻辑运算符&amp;&amp;和||都是先计算左边表达式的值，如果是下列情况：false &amp;&amp; ...、true || ...，则右侧的表达式不会被计算。\n按位运算符\n//按位运算符    cout &lt;&lt; &quot;===== 7. 按位运算符 =====&quot; &lt;&lt; endl;    unsigned int bits1 = 6;  // 二进制: 0110    unsigned int bits2 = 3;  // 二进制: 0011        cout &lt;&lt; bits1 &lt;&lt; &quot; &amp; &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 &amp; bits2) &lt;&lt; &quot; (按位与)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; | &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 | bits2) &lt;&lt; &quot; (按位或)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; ^ &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 ^ bits2) &lt;&lt; &quot; (按位异或)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;~&quot; &lt;&lt; bits1 &lt;&lt; &quot; = &quot; &lt;&lt; (~bits1) &lt;&lt; &quot; (按位取反，注意符号位)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &lt;&lt; 1 = &quot; &lt;&lt; (bits1 &lt;&lt; 1) &lt;&lt; &quot; (左移1位，相当于乘以2)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &gt;&gt; 1 = &quot; &lt;&lt; (bits1 &gt;&gt; 1) &lt;&lt; &quot; (右移1位，相当于除以2)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n6 &amp; 3 = 2 (按位与)6 | 3 = 7 (按位或)6 ^ 3 = 5 (按位异或)~6 = 4294967289 (按位取反，注意符号位)6 &lt;&lt; 1 = 12 (左移1位，相当于乘以2)6 &gt;&gt; 1 = 3 (右移1位，相当于除以2)\n数据在计算机中是用二进制存储的，数据在被标示成二进制后，就可以对每一位进行操作。\n\n\n按位与&amp;表示对数据的每一位都进行与操作，某一位上都为1的依然为1，否则这一位为0。\n\n\n按位或|表示对数据的每一位都进行或操作，某一位上任一数据是1则为1，全是0的位仍然是0。\n\n\n按位异或^表示对数据的每一位都进行异或操作，某一位上都为同为1或同为0的为0，否则这一位为1(相同为0，不同为1)。\n\n\n按位取反~表示对数据的每一位都进行取反操作，为1的位变为0，为0的位变成1。\n\n\n左移&lt;&lt;表示对数据的每一位都向左移动1位，末尾补0。这个操作相当于将原数据$\\times 2$。\n\n\n右移&gt;&gt;表示对数据的每一位都向右移动1位，开头补0。这个操作相当于将原数据$\\div 2$\n\n\n复合赋值运算符\n//复合赋值运算符    cout &lt;&lt; &quot;===== 8. 复合赋值运算符 =====&quot; &lt;&lt; endl;    int compound = 10;        cout &lt;&lt; &quot;初始值: compound = &quot; &lt;&lt; compound &lt;&lt; endl;    compound += 5;  // compound = compound + 5    cout &lt;&lt; &quot;compound += 5 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound -= 3;  // compound = compound - 3    cout &lt;&lt; &quot;compound -= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound *= 2;  // compound = compound * 2    cout &lt;&lt; &quot;compound *= 2 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound /= 4;  // compound = compound / 4    cout &lt;&lt; &quot;compound /= 4 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound %= 3;  // compound = compound % 3    cout &lt;&lt; &quot;compound %= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        int bitwise = 12; // 二进制: 1100    bitwise &amp;= 10;    // 10是1010，按位与后：1000 (8)    cout &lt;&lt; &quot;bitwise &amp;= 10 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise |= 3;     // 3是0011，按位或后：1011 (11)    cout &lt;&lt; &quot;bitwise |= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise ^= 1;     // 1是0001，按位异或后：1010 (10)    cout &lt;&lt; &quot;bitwise ^= 1 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &lt;&lt;= 2;    // 左移2位：101000 (40)    cout &lt;&lt; &quot;bitwise &lt;&lt;= 2 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &gt;&gt;= 3;    // 右移3位：101 (5)    cout &lt;&lt; &quot;bitwise &gt;&gt;= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 8. 复合赋值运算符 =====初始值: compound = 10compound += 5 后: compound = 15compound -= 3 后: compound = 12compound *= 2 后: compound = 24compound /= 4 后: compound = 6compound %= 3 后: compound = 0bitwise &amp;= 10 后: bitwise = 8bitwise |= 3 后: bitwise = 11bitwise ^= 1 后: bitwise = 10bitwise &lt;&lt;= 2 后: bitwise = 40bitwise &gt;&gt;= 3 后: bitwise = 5\n复合赋值就是将一些运算符与赋值运算符=连接在一起使用，这些运算符一般都是二元运算符，复合之后的效果相当于将变量自身的值进行对应的操作后再赋值给变量自身。\nsizeof\n//sizeof运算符    cout &lt;&lt; &quot;===== 9. sizeof运算符 =====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(double) = &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(bool) = &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;        int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; &quot;数组 arr 的大小: sizeof(arr) = &quot; &lt;&lt; sizeof(arr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = &quot;          &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; &quot; 个&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;sizeof(10) = &quot; &lt;&lt; sizeof(10) &lt;&lt; &quot; 字节 (字面量的大小)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(10 + 3.14) = &quot; &lt;&lt; sizeof(10 + 3.14) &lt;&lt; &quot; 字节 (表达式的结果类型大小)&quot; &lt;&lt; endl;\n运行结果为\n===== 9. sizeof运算符 =====sizeof(int) = 4 字节sizeof(double) = 8 字节sizeof(char) = 1 字节sizeof(bool) = 1 字节数组 arr 的大小: sizeof(arr) = 20 字节数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = 5 个sizeof(10) = 4 字节 (字面量的大小)sizeof(10 + 3.14) = 8 字节 (表达式的结果类型大小)\nsizeof在前面讲过，这里不再细讲，可以看看代码进行回忆。\n优先级\n正如加减乘除要先算乘除后算加减一样，C++中的运算符也是有优先级的区分的，下面是优先级的表格，数字越小表示优先级越高，数字越大表示优先级越低。\n\n\n\n等级\n名称\n运算符\n\n\n\n\n1\n作用域解析运算符\n::\n\n\n2\n成员选择、下标、后缀递增和后缀递减\n.、-&gt;、()、++、–\n\n\n3\nsizeof、前缀递增和递减、求补、逻辑NOT、单目加和减、取址和解除引用、new、new[]、delete、delete[]、类型转换、sizeof()\n++、–、~、!、+、-、&amp;、*、()\n\n\n4\n用于指针的成员选择\n.、-&gt;\n\n\n5\n乘、除、求模\n*、/、%\n\n\n6\n加、减\n+、-\n\n\n7\n移位（左移和右移）\n&lt;&lt;、&gt;&gt;\n\n\n8\n不等关系\n&lt;、&lt;=、&gt;、&gt;=\n\n\n9\n相等关系\n==、!=\n\n\n10\n按位AND\n&amp;\n\n\n11\n按位XOR\n^\n\n\n12\n按位OR\n|\n\n\n13\n逻辑AND\n&amp;&amp;\n\n\n14\n逻辑OR\n||\n\n\n15\n条件运算符\n?:\n\n\n16\n赋值运算符\n=、*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&amp;=、|=、^=\n\n\n17\n逗号运算符\n,\n\n\n\n这个表格非常的复杂，记忆起来非常困难，因此，一般我们不会根据这个表格进行编程，我们会将我们想要优先进行的运算用()包裹，这样一来，运行的顺序就会非常的直观，我们只需要记住优先级比()高的运算符即可。\n","categories":["C++"],"tags":["C++"]},{"title":"CPP数组与字符串","url":"/2025/12/31/CPP%E6%95%B0%E7%BB%84/","content":"静态数组\n如果有5个类型相同，意义相近的变量，你可以用下列代码进行声明。\nint firstNum, secondNum, thirdNum, fourthNum, fifthNum;\n但是如果是100个变量，这样写的效率就极低了，此时我们可以使用数组对这些变量进行存储。\n声明和初始化\n数组的声明语法与变量类似，区别只是多了个[]用来表示要存储多少个变量。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明一个能存储5个整数类型变量的数组    int array1[5];    //声明并初始化数组    char array2[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    //声明并初始化数组    char array3[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    return 0;&#125;\n上面的代码中，array1是能存储5个int类型的变量的数组，array2是能存储5个char类型变量的数组，并且array2通过{}和,的方式进行了初始化。array3在初始化时给出了数组里的所有元素，所以编译器自动推导了数组的长度，此时[]可以不写元素的数量。\n数组的初始化就是在{}里面，用,把每个变量的值隔开。\n\n虽然都是存储5个变量，但是array1占用的空间是$5 \\times sizeof(int)$，array2占用的空间是$5 \\times sizeof(char)$\n\n\n[]里面的数必须是整数\n\n访问数组元素\n访问数组中的某个元素，就是在[]中填入元素的索引。注意：数组的索引从0开始。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化数组    char array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    cout &lt;&lt; array1[0] &lt;&lt; array1[1] &lt;&lt; endl;    char ch1 = array1[4];    cout &lt;&lt; ch1 &lt;&lt; endl;    char ch2 = array1[5];    cout &lt;&lt; ch2 &lt;&lt; endl;    return 0;&#125;\n上面的代码的运行结果是\nabz\n可以看到array1[0]输出的结果是第一个元素a，array1[1]输出的结果是第二个元素b。这也证明了刚才所说的：数组的索引从0开始。\n在示例代码中，数组索引的取值范围是0-4，而ch2尝试读取索引为5的数组元素，运行结果是什么也没有显示。这种访问或修改数组索引范围之外的操作叫做数组越界。\n数组越界在C++中是未定义的行为，未定义的意思就是：C++没有规定如果出现了这种情况该怎么做。因此当程序中不小心出现了数组越界的问题，他导致的后果可能并不相同，这是由编译器决定的。导致的后果包括但不限于：\n\n\n程序报错\n\n\n输出一个垃圾值\n\n\n程序崩溃\n\n\n修改数组元素\n修改数组元素的方法与修改变量的值也类似。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化数组    char array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    cout &lt;&lt; array1[0] &lt;&lt; endl;    array1[0] = &#x27;d&#x27;;    cout &lt;&lt; array1[0] &lt;&lt; endl;    return 0;&#125;\n运行结果为\nad\n可以看到array1[0]存储的值已经被更改了。\n通过上面的代码不难看出，对数组的操作与对变量的操作是类似的，只不过需要加上一个包含索引值的[]来表示你要对数组中的哪个元素进行操作。\n数组的存储\n在程序中创建一个数组时，需要指定数组的长度(长度是数组中元素的个数)，编译时，计算机会将一个连续的空间分配给这个数组，比如下面这行代码。\nchar array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;\n运行后，数组在内存中的结构如下图所示 \n假设这个数组的首地址(地址可以理解为内存的门牌号)为0x01(0x表示后面的数字是十六进制)，可以看到’a’的起始地址为0x01，'b’的起始地址为0x02，这是因为char类型只占1字节。\n在这张图片中，不难发现五个元素的地址是紧挨着的。这是因为数组是由计算机分配的连续的空间，而计算机读取变量值靠的是地址，数组的数据挨在一起，那么计算机只要知道第一个元素的地址，后面的元素的地址可以靠公式$address = firstAddress + index\\times sizeof(variableType)$计算得到。其中address表示我们要找的元素的地址，firstAddress表示数组第一个元素的地址，index表示要找的元素的索引(从0开始)，variableType表示变量类型。\n正是因为无论多大的数组都可以靠这个公式轻松计算得到元素的地址，计算机访问数组的速度极快，且与数组大小无关。\n多维数组\n上面说到的数组都是一维数组，数组也可以定义为多维的。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化多维数组    //声明一个2行3列的数组    //第一行为1，2，3；第二行为4，5，6    int array1[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;     //声明一个3行2列的数组    //第一行为1，2；第二行为3，4；第三行为5，6    int array2[3][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;    //声明一个三维数组    int array3[2][3][4] = &#123;&#123;&#123;1, 2, 3, 4&#125;, &#123;4, 3, 2, 1&#125;, &#123;2, 3, 4, 1&#125;&#125;,                             &#123;&#123;1, 1, 1, 1&#125;, &#123;2, 2, 2, 2&#125;, &#123;3, 3, 3, 3&#125;&#125;&#125;;    //访问多维数组    cout &lt;&lt; array1[0][0] &lt;&lt; endl;    cout &lt;&lt; array2[2][1] &lt;&lt; endl;    cout &lt;&lt; array3[1][1][3] &lt;&lt; endl;    //修改多维数组    array1[0][0] = 2025;    array2[2][1] = 12;    array3[1][1][3] = 31;    cout &lt;&lt; array1[0][0] &lt;&lt; endl;    cout &lt;&lt; array2[2][1] &lt;&lt; endl;    cout &lt;&lt; array3[1][1][3] &lt;&lt; endl;    return 0;&#125;\n结果为\n16220251231\n判断数组是几维的最直接的方法就是看声明和使用数组时要用到几个[]，除了维度变得更高，使用方法几乎与一维数组一样。需要注意的是：多维数组在形式上是多维的，但是存储的方式仍然是一维的。\n以二维数组为例，如果数组的声明为int a[2][2];，则它的表现形式和存储形式如图所示\n因此初始化可以有两种形式\nint a[2][2] = &#123;1, 2, 3, 4&#125;;\nint a[2][2] = &#123;&#123;1, 2&#125;,                &#123;3, 4&#125;&#125;;\n第一种初始化是从内存角度出发的方式，这样可以一眼看出元素在内存中的存储形式。第二种初始化则更符合人的习惯，这样可以看出数组的表现形式。推荐使用第二种赋值方式，对于更高维的数组来说，这样的赋值方式不容易出错。\n注意事项\n对于标准的C++来说，数组的大小必须在编译期就确定，因此[]里只能是字面常量或者编译期常量表达式。\nint array1[3];  //这是用字面常量规定数组长度constexpr int MAX_SIZE = 3;int array2[MAX_SIZE];   //这是用常量表达式规定数组的长度\n也就是说，对于标准C++来说，不能用变量来规定数组的长度。\n// 错误的使用方式，因为变量是运行期确定值int a = 3;int array1[a];\n但是如果真的这样使用，编译器未必会报错，并且可以正确的完成声明的步骤。\n这是因为一些编译器（如GCC）提供了扩展支持，支持变长数组（VLA），但这并非C++的标准语法。\n动态数组\nC++提供的方案\n静态数组虽然读取速度快，但是也有自身的局限性。静态数组需要在程序开始运行前就确定数组的大小，且确定后就无法修改大小。如果一个图书馆要存储图书的数据，那肯定不能使用大小要开始就确定的静态数组，毕竟没有人知道这个图书馆最后会存储多少本书。\n这个时候就可以使用动态数组，动态数组长度不固定，可以随意添加或删除数据。并且C++提供了这种数据类型，不需要自己去实现。\n#include &lt;iostream&gt;//使用C++提供的动态数组，必须包含头文件vector#include &lt;vector&gt;using namespace std;int main()&#123;    //声明动态数组，初始长度为3，并把元素全部初始化为10    vector&lt;int&gt; dynArray(3, 10);    cout &lt;&lt; &quot;dynArray的元素个数：&quot; &lt;&lt; dynArray.size() &lt;&lt; endl;    cout &lt;&lt; dynArray[0] &lt;&lt; endl;    cout &lt;&lt; dynArray[1] &lt;&lt; endl;    cout &lt;&lt; dynArray[2] &lt;&lt; endl;    //在数组后面添加一个元素    dynArray.push_back(333);    cout &lt;&lt; &quot;dynArray的元素个数：&quot; &lt;&lt; dynArray.size() &lt;&lt; endl;    cout &lt;&lt; dynArray[0] &lt;&lt; endl;    cout &lt;&lt; dynArray[1] &lt;&lt; endl;    cout &lt;&lt; dynArray[2] &lt;&lt; endl;    cout &lt;&lt; dynArray[3] &lt;&lt; endl;    return 0;&#125;\n结果为\ndynArray的元素个数：3101010dynArray的元素个数：4101010333\n以上是C++提供的动态数组的基本操作方式，更详细的操作会在后面的STL中介绍。\n动态数组原理\n动态数组首先通过malloc函数分配初始所占空间，malloc函数只有一个参数，就是要分配的空间的大小(字节)，也就是上面代码vector&lt;int&gt; dynArray(3, 10);中的参数3，这时dynArray的空间大小为$3\\times sizeof(int)$。\n后面使用方法push_back插入了一个数据，这时，C++会调用realloc函数重新为数组分配空间，realloc函数有两个参数，一个是原本数组的地址，另一个是改变容量后的空间大小。调用了这个函数后，动态数组的空间增大，并加入了一个新元素。\n字符串\n字符串顾名思义就是许多个字符连接起来，也就是我们平时使用的文本。\n在代码中，经常会遇到需要用文本和用户交互的情况，这种情况下，如果用char就需要定义很多字符型变量。为了解决这个问题，类C语言专门制定了字符串的规范。\nC风格字符串\nC风格字符串是C语言中使用的字符串的格式，C语言的做法是用字符型数组存储字符串，并在最后加上一个'\\0'表示字符串的结尾。下面是一个C语言的示例，它与C++有些许不同，但是整体结构非常相似。\n#include &lt;stdio.h&gt;int main()&#123;    char stringArr[] = &quot;Hello World&quot;;    printf(stringArr);    return 0;&#125;\n上述代码中，stringArr看似只有11个元素，但实际上有12个元素，可以等价为\nchar stringArr[] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;\\0&#x27;&#125;;\n这个字符串最后的'\\0'是字符串的结束字符。计算机并不认识字符串，在计算机眼中，这些只是一串二进制数，那在输出文本的时候，如何判断字符串已经结束了呢？\n答案就是当计算机看到结束字符’\\0’时，就知道字符串已经结束了。如果丢掉这个结束字符，计算机就不知道字符串已经结束了，会继续向后输出，导致数组越界。\n因此，C语言的字符串实际上是一个非常危险的设计。\nC++风格字符串\n无论是处理文本输入，还是执行拼接字符串操作，使用C++风格的字符串都是更高效、更安全的选择。\n不同于C语言的字符串数组，C++的std::string是动态的，在文本更长时它的容量将增大。\n下面是C++字符串的一些常用操作。\n#include &lt;iostream&gt;//使用字符串时，加上string头文件#include &lt;string&gt;using std::cout, std::endl, std::cin;int main()&#123;    //声明并初始化字符串    std::string helloString(&quot;Hello World&quot;);    cout &lt;&lt; helloString &lt;&lt; endl;    //读取输入的字符串    std::string firstLine;    cout &lt;&lt; &quot;请输入第一行数据：&quot;;    getline(cin, firstLine);    std::string secondLine;    cout &lt;&lt; &quot;请输入第二行数据：&quot;;    getline(cin, secondLine);    //输出读取到的内容    cout &lt;&lt; &quot;\\n输入的内容为：\\n&quot;;    cout &lt;&lt; firstLine &lt;&lt; endl;    cout &lt;&lt; secondLine &lt;&lt; endl;    //拼接两个字符串    std::string contactString = firstLine + &quot; &quot; + secondLine;    cout &lt;&lt; &quot;拼接后的字符串： &quot; &lt;&lt; contactString &lt;&lt; endl;    //复制字符串    std::string copyString;    copyString = helloString;    cout &lt;&lt; &quot;复制出来的字符串： &quot; &lt;&lt; copyString &lt;&lt; endl;    //计算字符串的长度    cout &lt;&lt; &quot;helloString的字符数量为： &quot; &lt;&lt; helloString.length() &lt;&lt; endl;    return 0;&#125;\n运行结果为\nHello World请输入第一行数据：你好请输入第二行数据：世界输入的内容为：你好世界拼接后的字符串： 你好 世界复制出来的字符串： Hello WorldhelloString的字符数量为： 11\n上面这些是常用的对字符串的操作，更详细的内容将在后面的STL部分介绍。\n","categories":["C++"],"tags":["C++"]},{"title":"C++程序组成","url":"/2025/12/25/%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%88%90/","content":"C++程序组成\nC++ 的语法与 C 语言高度相似，最初确实是作为 C 语言的扩展而诞生的。然而，随着时间的发展，C++ 已演变为一门独立且功能丰富的编程语言。作为一门支持面向对象编程（OOP）的语言，C++ 引入了许多 C 语言所不具备的特性，其中最具代表性的是面向对象的三大核心特征：封装、继承和多态。此外，C++ 的标准库也与 C 语言有显著不同，例如提供了标准模板库（STL）、更安全的字符串和容器类型等。因此，即便已经掌握了 C 语言，也不应轻视 C++ 的复杂性和深度，而应将其视为一门全新的语言来系统学习。\nC++程序基本构成\n以下面这个简单的C++程序为例\n//头文件#include &lt;iostream&gt;//主函数int main()&#123;    //功能    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    //返回值    return 0;&#125;  \n首先是头文件#include &lt;iostream&gt;，#include &lt;&gt;是C++引入头文件的语法，iostream则是头文件的文件名，头文件可以理解为实现了某些功能的文件，引入头文件才能在自己的代码中使用这些功能。iostream是C++提供的标准库。\n下面是主函数部分，语法为\nint main()&#123;    return 0;&#125;  \n主函数是程序的入口点，首先是int main()，这是函数头，int表示这个函数的返回值的类型是整数，main是函数的名字，main 函数可以定义为带参数的形式int main(int argc, char* argv[])，用于接收命令行参数。花括号{}括住的部分是这个函数的代码块，return 0;表示返回一个数字0，这个返回值是个整数，与int main()中的int对应。一般来说，函数返回了0表示程序成功执行并正常退出，非零返回值（包括 -1）通常表示程序执行出错或异常退出。\n接下来是编写函数功能的代码\nstd::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;\n这两行代码的含义是输出两行文本到命令行，第一行是&quot;Hello World&quot;，第二行是&quot;你好，世界&quot;。\nstd是一个命名空间，它的作用是：避免全局作用域中的名称冲突，例如当代码里有两个地方分别写了同一个相同名称的函数(函数是完成某个固定功能的代码块，通过名称区分)，但是他们的代码不同，那么在使用这个函数时，编译器会不知道到底调用哪里的函数，这时就可以使用命名空间来区分它们。\nstd::cout的含义就是使用std命名空间中的cout函数(这里其实并不正确，cout是std中定义的一个流，但是现在这样更好理解)。&lt;&lt;是流插入运算符，意思是把运算符后面的内容插入到运算符前面的流中。std::endl作用是换行和刷新输出缓冲区。\n要使用std::cout和std::endl必须包含头文件#include &lt;iostream&gt;，因为它们定义在iostream文件中。\n\n需要注意的是：C++中每一条语句后面都要加分号;，可以看到在代码中，只有#include &lt;iostream&gt;并没有加分号，因为预处理指令并不是 C++ 语句。\n\n最后介绍一下C++的注释，//是注释符号，//后面一整行的内容都是注释部分，注释在程序中起到解释代码含义的作用，它并不会被编译器编译，也就是说，在编译器的眼中，这个代码是这个样子的\n#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n另外，也可以使用多行注释，格式是/* 这里写注释 */，例如\n#include &lt;iostream&gt;/*我可以跨多行，只要在这两个符号中间的都是注释*/int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;//我只负责这一行    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n命名空间\n在前面介绍代码的基本结构时，已经简单介绍过命名空间，总而言之，命名空间是为了避免全局作用域中的名称冲突，这里面的名称冲突并不仅仅包含函数名，也包括变量名，也包括流等等。\n在学习C++时，写的代码比较简单，一般不会出现命名冲突，这个时候可以简化写法\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    return 0;&#125;\n可以看到，使用了using namespace std声明了std这个命名空间后，写cout和endl时就不需要在前面明确std了。\n但是这样有时会无法确定std命名空间中的其他名称是否会发生冲突，因此更推荐的用法是\n#include &lt;iostream&gt;//using namespace std;using std::cout, std::endl;int main()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    return 0;&#125;\n这个示例中，通过使用using，也实现了简化写法的功能。二者的区别是：前者可以在使用std中定义的所有内容都无需加std::；后者只有cout和endl可以不加std::。\n函数\n函数能够将应用程序划分成多个功能单元，程序员通常需要编写自己的函数。\n下面是一个使用函数的示例\n#include &lt;iostream&gt;using std::cout, std::endl;//声明函数int sum(int a, int b);int main()&#123;    int x=1,y=2;        //这里是定义了两个整数类型的变量，并给他们赋值为1和2    cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; sum(x,y) &lt;&lt; endl; //函数可以在其他语句中被调用    int result = sum(x,y);              //函数的返回值可以被赋值给变量    cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; result &lt;&lt; endl;   //将变量输出    cout &lt;&lt; &quot;1+2=&quot; &lt;&lt; sum(1,2) &lt;&lt; endl; //传递给函数的不一定是变量，也可以是常量    return 0;&#125;//定义函数，函数需要传递两个整数(int)int sum(int a, int b)&#123;    int res = a+b;  //使用两个变量进行求和运算    return res;     //返回计算结果&#125;\n使用函数前要先声明函数，可以理解为这是在告诉编译器：我有这样一个函数，名字是sum，返回值是整数类型，需要传递两个整数类型的参数，虽然我现在还没有告诉你它里面具体做了什么，但是我在后面会告诉你，你不要报错。\n在后面要定义函数，用{}包裹住的是这个函数的实现步骤。\n\n若函数定义在 main 之前，则无需单独声明。\n\nIO操作\nI表示输入，O表示输出。在写代码时，不能仅仅考虑输出结果(通过cout输出)，还要考虑如何读取用户的输入，读取输入的语法与输出结果类似。\n#include &lt;iostream&gt;//定义IOfunc函数int IOfunc()&#123;    int a, b;    std::cout &lt;&lt; &quot;请输入两个整数（用空格分开）：&quot;;    //读取用户输入的整数，将其放到变量a和b中    std::cin &gt;&gt; a &gt;&gt; b;    std::cout &lt;&lt; &quot;您输入的第一个数是：&quot; &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;您输入的第二个数是：&quot; &lt;&lt; b &lt;&lt; std::endl;    return 0;&#125;int main()&#123;    //调用IOfunc函数    IOfunc();    return 0;&#125;\n运行结果为\n请输入两个整数（用空格分开）：3 99您输入的第一个数是：3您输入的第二个数是：99\n读取输入使用std::cin，后面使用提取运算符&gt;&gt;，将输入流中的数据提取到变量中。输入的数据之间要通过空格隔开，按下回车就相当于输入完毕，代码才会继续向后执行。\n运算符\nC++中有多种运算符，例如前面用到的&lt;&lt;和&gt;&gt;，这里先介绍常用的算术运算符\n\n\n\n运算符\n描述\n实例\n\n\n\n\n+\n把两个操作数相加\nA+B（10+20）将得到30\n\n\n-\n从第一个操作数中减去第二个操作数\nA-B（10-20）将得到-10\n\n\n*\n把两个操作数相乘\nA*B（10x20）将得到200\n\n\n/\n分子除以分母\nB/A（20/10）将得到2\n\n\n%\n取模运算符，整除后的余数\nB%A（20%10）将得到0\n\n\n++\n自增运算符，整数值增加1\nA++将得到11\n\n\n--\n自减运算符，整数值减少1\nA--将得到9\n\n\n\n\n=并不是相等的运算符，在C++中，这表示赋值，也就是将=右边赋值给=左边。\n\n","categories":["C++"],"tags":["C++"]},{"title":"环境设置","url":"/2025/12/25/%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/","content":"C++学习环境配置\nVisual Studio安装\n想要系统学习C++，Visual Studio是一个一定会被用到的软件，它是由微软（Microsoft）开发的一款功能强大、高度集成的集成开发环境（Integrated Development Environment, IDE），广泛用于 Windows 平台上的应用程序开发。它不仅支持多种编程语言（如 C#、Python、JavaScript 等），还为 C 和 C++ 开发者提供了全面的工具链支持，包括智能代码编辑、调试器、性能分析器、版本控制集成以及项目管理功能。\n下载\n点击下载链接即可进入Visual Studio的官方下载界面 \n点击社区版的免费下载(红框部分)，即可下载Visual Studio下载器，这个下载器不大，很快就可以下载下来。下载成功后，双击下载下来的.exe文件，就会进入下面的界面   \n可以根据需要选择模块来进行下载，学习C++的不知道选什么的话，可以将图中的三个选上。然后选择安装位置，将安装路径改为C盘以外的盘，因为这个软件本身占用空间较大，放在C盘可能会使电脑卡顿，另一方面，如果电脑坏了，放在非系统盘可以把数据恢复。等它安装好即可使用(有些电脑可能要先重启在使用)。\nVScode安装\n虽然Visual Studio功能强大，但是本身占用的空间比较大，而且，它一般是面向于项目，对于只想学C++的人来说，它过于笨重，因此我们可以用VScode来替代它，等到要做项目的时候在使用Visual Studio。\nVScode是微软开发的一款轻量级但功能强大的源代码编辑器，支持 Windows、macOS 和 Linux 三大主流操作系统。虽然 VS Code 本身并非传统意义上的集成开发环境（IDE），但通过安装扩展（Extensions），它可以轻松转变为功能完备的 C++ 开发工具。配合官方提供的 C/C++ 扩展，VS Code 能提供智能代码补全（IntelliSense）、语法高亮、代码导航、重构支持、调试集成（通过 GDB 或 LLDB）等专业级功能。同时，它原生支持 CMake、Makefile 以及任务（Tasks）和启动（Launch）配置，使项目构建与调试流程高度自动化。\n对于 C++ 初学者或希望在多平台（如 Linux 或嵌入式开发）下工作的开发者来说，VS Code 是一个灵活且高效的选择。它不捆绑特定编译器，而是依赖系统已安装的工具链（如 GCC、Clang 或 MinGW），因此配置更具自由度，也更贴近真实开发环境。此外，其内置终端、Git 集成、主题自定义和远程开发能力（如 Remote - SSH、WSL）进一步提升了开发体验。\n下载\n可以在vscode官方网站下载软件，如果下载速度比较慢的话，可以用迅雷下载，或者通过国内镜像下载。\n插件\n打开VScode后，在界面的左边打开插件界面 \n打开后可以看到已经安装的插件，红框框住的就是要下载的插件 \n在上面的搜索栏中搜索插件的名字，即可进行下载，这里还推荐一个与C++无关的插件\n这个插件可以让你的文件有不同的图标，让界面看起来更美观，提升工作效率。效果如下图所示。\n\n配置C/C++编译器\n目前最常用的 C/C++ 编译器主要有 GCC、MSVC 和 Clang。其中，GCC 和 Clang 具备良好的跨平台支持，而 MSVC 主要面向 Windows 平台，在其他系统上的使用较为受限。GCC 在 Linux 系统及嵌入式开发中被广泛采用，是这些领域事实上的标准工具链。考虑到 C++ 的主要应用场景（如系统编程、嵌入式开发、服务器后端等）大多集中在 Linux 和嵌入式环境，因此选择 GCC 作为 C++ 编译器是一个自然且实用的选择。\n安装MinGW\n到MinGW的GitHub主页下载MinGW \n如果无法进入GitHub，可以通过镜像下载，选择下载安装包可参考上一张图\n下载好后解压下载的压缩包，可以得到一个文件夹\n双击打开，进入里面的bin文件夹，复制文件夹的地址\n下一步配置环境变量，按下WIN+R，输入sysdm.cpl，然后按下回车，然后点击高级，点击环境变量，找到Path，点击新建，将刚才复制的地址粘贴进去\n按下WIN+R，输入cmd，然后按下回车，输入\ngcc -vg++ -v\n出现下面的消息说明安装成功。\n配置VScode\n在任意地方建立一个空文件夹，这个空文件夹可以用来作为学习C++时存储代码的文件夹，自行起一个名字(路径里最好不要有中文，因为有些软件是不支持中文路径的，中文路径可能导致软件运行出错，VScode虽然没有这个问题，但还是要养成使用英文路径的习惯)。有两种在该文件夹打开VScode的方法：\n通过命令行打开\n鼠标点击地址栏，输入cmd\n按下回车，会打开命令行，此时命令行的地址就在当前文件夹，输入\ncode .\n按下回车，就在VScode中打开了当前文件夹，在Linux系统中，也可以通过这种方式打开当前文件夹\n右键打开\n可以直接在文件夹空白处右键，选择通过Code打开，即可直接在VScode中打开当前文件夹。\n创建一个C++文件\n点击左上角的资源管理器，点击新建文件，输入文件的名字，在后面加上.cpp后缀，.cpp表示这是一个C++代码文件，就像C代码文件后缀是.c，python代码文件后缀是.py一样。\n在创建的C++文件里输入以下代码\n#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n插件设置\n点开插件界面，右键点击Code Runner，点击设置\n找到Run in Terminal，将它选上。\n运行代码\n回到cpp文件界面，点击鼠标右键，点击Run Code，即可运行\n运行后结果如图所示\n如果中文出现乱码，可以修改settings.json，在Code Runner插件中找到在settings.json中编辑\n在settings.json中进行修改\n可以直接将下面这三行代码替换图中指的三行\n&quot;c&quot;: &quot;cd $dir &amp;&amp; gcc -fexec-charset=GBK $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,&quot;zig&quot;: &quot;zig run&quot;,&quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ -fexec-charset=GBK $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,\n说明\n这种配置方法是最简单的方法，不能使用断点调试，如果想要使用断点调试，可以参考vscode配置C/C++环境\n参考资料\nvscode配置C/C++环境\n","categories":["C++"],"tags":["C++","tools"]},{"title":"CPP变量与常量","url":"/2025/12/26/CPP%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/","content":"变量\n变量是在代码中可以被改变的数据，在使用变量前，要先规定变量的类型和名称，如果规定是整数型，那它就不能用来存储小数。变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。\n内存\n在计算机中，处理器负责执行应用程序，在此过程中，它会从 RAM（随机存取存储器）中读取程序的二进制指令及相关数据。RAM 可以看作是一系列连续的存储单元（“格子”），每个单元可以存放一个固定大小的数据项。需要注意的是，一个存储单元只能容纳一份数据，但同一份数据可以被复制到多个单元中。\n举个例子：假设你有一整套螺丝刀（我们将其视为一个完整的数据结构），但每个格子的容量只能容纳一把螺丝刀。这时，你需要将这套螺丝刀拆开，将每把螺丝刀依次放入相邻的格子中。这样一来，当你需要使用整套工具时，就可以快速按顺序取出这些螺丝刀，并重新组合成完整的工具集。\n这样的类比有助于理解：在内存中，复杂的数据（如数组、结构体等）通常是以连续或关联的方式分布在多个内存单元中的，以便处理器高效访问和处理。\n声明变量\n在C++中，声明变量的基本格式是 VariableType VariableName，例如 int a，其中 int 是变量的类型，a 是变量的名称。\n声明变量的作用是向系统申请一块与其类型相匹配大小的内存空间。一旦变量被声明，这块内存就会被“预留”给该变量，直到其生命周期结束（例如离开作用域或被显式释放）。在这期间，该内存不会被分配给其他变量。\n需要注意的是，如果在声明变量时没有显式初始化（即没有在声明时赋予初始值），那么该变量的值将是未定义的——它会包含该内存位置当前残留的任意内容。这并非“上一个程序”留下的数据（现代操作系统通常会为每个进程提供独立的虚拟地址空间，并在分配内存时清零或做安全处理），而更可能是之前在同一程序中该内存位置所存储的旧值，或者是未初始化的“垃圾值”。\n可以用一个类比来理解：想象一个格子原本放着一把螺丝刀，后来格子的主人不再使用它，但没有清空格子。如果新主人直接使用这个格子而不放新东西进去，那么他拿到的还是那把旧螺丝刀。因此，在使用变量前进行初始化，是避免意外行为和保证程序可靠性的良好实践。\n初始化变量\n下面是初始化变量的示例代码\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化变量    int a = 10;    //声明多个变量    int b1, b2;    //初始化多个变量    int c1 = 10, c2 = 20, c3 = 30;    return 0;&#125;\n在C++中，变量的初始化是在声明时进行的，可以同时声明多个相同类型的变量，也可以同时初始化多个变量，中间用逗号隔开。\n作用域\n变量的作用域是变量能够被使用的范围。一旦超出了这个作用域，变量就无法被使用。如果变量的作用域是函数，那么这个变量会在函数结束后被销毁。\n在上面的代码中，变量声明和初始化是在 main 函数中，一旦 main 函数执行完毕，变量就会自动销毁。而如果在main函数中调用另一个函数，在运行另一个函数时，main里面的变量无法被访问。可以尝试运行下面的代码，看看是否能编译成功。\n#include &lt;iostream&gt;using namespace std;int sum(int a, int b) &#123;    //使用main函数里的变量    x = x + y;    return a + b;&#125;int main() &#123;    int x = 1, y = 2;    cout &lt;&lt; sum(x, y) &lt;&lt; endl;    return 0;&#125;\n上面的代码会编译失败，因为x和y的作用域是main函数，在sum函数中无法使用。同理，main函数也无法使用sum函数中的变量。\n\n只有在函数运行结束后，变量才会被销毁，在上面的例子中，sum函数只是无法使用x和y，但它们并没有被释放。\n\n全局变量\n如果有一个变量在多个函数中都使用，那么就可以将其定义为全局变量。全局变量和普通变量一样，区别在于它是在函数外被声明的，并且可以在任意函数中访问。\n#include &lt;iostream&gt;using namespace std;int a = 10, b = 20;int sum()&#123;    return a + b;&#125;int main()&#123;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum() &lt;&lt; endl;    return 0;&#125;\n运行后可以看到运行结果：\na = 10b = 20sum = 30\n虽然main函数和sum函数没有定义变量a和b，但程序依然可以正确的编译运行，因为全局变量的作用域是整个程序，因此可以在任意函数中访问。\n如果在函数里重新声明变量，那么局部变量会屏蔽全局变量。\n#include &lt;iostream&gt;using namespace std;int a = 10, b = 20;int sum()&#123;    //重新声明变量a    int a = 30;    return a + b;&#125;int main()&#123;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum() &lt;&lt; endl;    //使用全局变量a    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n运行后可以看到运行结果：\na = 10b = 20sum = 50a = 10\n可以看到，在sum函数中重新声明了变量a，在 sum 函数中声明的局部变量 a 屏蔽了全局变量 a，因此在该函数内部引用 a 时，指的是局部变量，而非全局变量。在sum函数结束后，sum声明的变量a被销毁，因此a的值被恢复为10。\n命名规范\n在上面的代码中，变量的名字都是简单的字母，但是在实际项目中，每个变量都有自己的含义，这个时候，变量名应该具有意义，这样可以让自己和其他人更容易理解一个变量的作用。比如，如果要定义年龄变量，应该这么写int age = 18;，这样在调用的时候很方便理解变量含义。\n在C++中，变量名只能使用字母、数字、下划线，不能使用特殊字符，并且变量名不能以数字开头。C++变量区分大小写，因此变量名Age和age是不同的(函数名同理)。\n推荐一个大家约定俗成的变量命名规范：驼峰命名法。驼峰命名法就是将变量首字母小写，然后每个单词首字母大写，比如phoneNumber，首字母p小写，第二个单词首字母N大写。\n与变量的驼峰命名法类似，函数命名规范采用Pascal命名法，即每个单词首字母大写，比如GetPhoneNumber。\n变量类型\n整数类型\nC++中，整数类型有char、short、int、long、long long，它们的大小由具体实现决定，但 C++ 标准确保：sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)。在大多数现代系统上，char 为 8 位，short 为 16 位，int 为 32 位，long 为 32 或 64 位，long long 为 64 位(位数指的是二进制位数)。\n有符号整数\n在计算机中，整数的存储通过补码形式存储，如果补码二进制第一位是’0’，则表示这个整数是整数，如果补码二进制第一位是’1’，则表示这个整数是负数。因此，对于16位整数，只有15位表示数字的大小，最高位表示数字的正负。\n无符号整数\n无符号整数就是没有符号位的整数，最高位无论是0还是1，都是正数。因此，对于16位的无符号整数，16位都表示数字的大小。\n\n关于原码、反码、补码可以参考这篇博客二进制数的原码、反码、补码（详解），这部分内容推荐阅读。\n\n浮点类型\nC++中，浮点类型有float、double、long double，分别表示单精度、双精度、长双精度。\n字符类型\nC++中，字符类型一般用char，字符类型要用单引号括住，比如'a'。可以发现，在整数类型中也有char类型，这是因为在计算机中，字符是通过编码为整数存储在内存中的，所以char类型既是整数类型，也是字符类型。比较常见的编码形式有ASCII、UTF-8(支持绝大多数语言)、GBK(只支持中文和英文)等。\n\n要注意的是，由于字符的编码都是正整数，所以char类型的变量是无符号类型的整数\n\n布尔类型\n布尔类型用bool表示，只有两个值，true和false。\n下面是声明不同类型变量的示例：\n#include &lt;iostream&gt;using namespace std;int main() &#123;  int myNum1 = 5;               // 声明整数类型变量  short int myNum2 = 5;        // 短整型  unsigned int myNum3 = 5;     // 无符号整型  float myFloatNum = 5.99;     // 声明单精度浮点数类型变量  double myDoubleNum = 9.98;   // 声明双精度浮点数类型变量  char myLetter = &#x27;D&#x27;;         // 声明字符类型变量  bool myBoolean = true;       // 声明布尔类型变量  cout &lt;&lt; &quot;整数类型变量：&quot; &lt;&lt; myNum1 &lt;&lt; &quot;\\n&quot;;   //&#x27;\\n&#x27;表示换行  cout &lt;&lt; &quot;短整型变量：&quot; &lt;&lt; myNum2 &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;无符号整型变量：&quot; &lt;&lt; myNum3 &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;单精度浮点数类型变量：&quot; &lt;&lt; myFloatNum &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;双精度浮点数类型变量：&quot; &lt;&lt; myDoubleNum &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;字符类型变量：&quot; &lt;&lt; myLetter &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;布尔类型变量：&quot; &lt;&lt; myBoolean &lt;&lt; &quot;\\n\\n&quot;;  //给无符号整型赋值负数  myNum3 = -5;  cout &lt;&lt; &quot;无符号整型变量：&quot; &lt;&lt; myNum3 &lt;&lt; &quot;\\n\\n&quot;;  //给短整型赋值32800  myNum2 = 32800;  cout &lt;&lt; &quot;短整型变量：&quot; &lt;&lt; myNum2 &lt;&lt; &quot;\\n\\n&quot;;  return 0;&#125;\n运行结果为：\n整数类型变量：5短整型变量：5无符号整型变量：5单精度浮点数类型变量：5.99双精度浮点数类型变量：9.98字符类型变量：D布尔类型变量：1无符号整型变量：4294967291短整型变量：-32736\n前几行都是正确的结果，但是后两个的输出结果明显与赋值不同，无符号整型变量从-5变成了一个很大的正数，短整型从正数变为了负数。第一个结果的原因是，无符号整数没有符号位，但是-5有符号位，且为1，因此补码为11111111111111111111111111111101，也就是4294967291。第二个结果的原因是，短整型的范围是-32768到32767，因此当赋值超过这个范围时，会进行截断，截断后的值读取为-32736。\n\n这些结果是可以算出来的，并非随机的，可以参考上面的原码、反码、补码的介绍尝试计算。\n\n常用运算符和关键字\n下面介绍一下关于变量的常用的运算符和关键字\nsizeof\nsizeof()是C++提供的一个运算符，可用于确定变量的长度\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;              // 查看char所占字节数    cout &lt;&lt; &quot;sizeof(short) = &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;            // 查看short所占字节数    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;                // 查看int所占字节数    cout &lt;&lt; &quot;sizeof(long) = &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;              // 查看long所占字节数    cout &lt;&lt; &quot;sizeof(long long) = &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;    // 查看long long所占字节数    cout &lt;&lt; &quot;sizeof(float) = &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;            // 查看float所占字节数    int a;    cout &lt;&lt; &quot;sizeof(a) = &quot; &lt;&lt; sizeof(a) &lt;&lt; endl;                    // 查看变量a所占字节数    return 0;&#125;\n运行结果为：\nsizeof(char) = 1sizeof(short) = 2sizeof(int) = 4sizeof(long) = 4sizeof(long long) = 8sizeof(float) = 4sizeof(a) = 4\nsizeof()的返回值是字节数，而不是位数(1Byte = 8bit，Byte表示字节，bit表示位)。\nauto\nauto是C++提供的自动推断类型的关键字，比如\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //使用auto自动推测变量类型    auto a = 10;    auto b = 10.5;    auto c = &#x27;a&#x27;;    auto d = true;    cout &lt;&lt; &quot;sizeof(a)=&quot; &lt;&lt; sizeof(a) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(b)=&quot; &lt;&lt; sizeof(b) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(c)=&quot; &lt;&lt; sizeof(c) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(d)=&quot; &lt;&lt; sizeof(d) &lt;&lt; endl;    return 0;&#125;\n运行结果为\nsizeof(a)=4sizeof(b)=8sizeof(c)=1sizeof(d)=1\n根据之前的sizeof()的结果，可以发现，a 是int类型，b是double类型，c是char类型，d是bool类型。\ntypedef\nC++允许将变量类型替换为使用者认为方便的名称，为此可使用关键字 typedef。\n#include &lt;iostream&gt;using namespace std;typedef unsigned int uint;  // 将unsigned int定义为uintint main()&#123;    uint a = 10;    cout &lt;&lt; a &lt;&lt; endl;    a = -10;    cout &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n运行结果为：\n104294967286\n可以看到，uint声明出来的变量a，它的类型是unsigned int。这就是typedef的作用。\n常量\n常量是在程序中不会被改变的量，常量一旦声明，它的值就不能改变。常量在声明时一定要初始化，然后就不可被改变。\n字面常量\n在前面的程序中，字面常量几乎一直被使用，比如\ncout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;\n其中的&quot;Hello World!&quot;就是一个字面常量。或者在赋值时int a = 10;，这里面的10也是字面常量。\nconst\n可以通过const关键字将变量声明为常量，比如\n#include &lt;iostream&gt;using namespace std;int main()&#123;    const int a = 10;    cout &lt;&lt; a &lt;&lt; endl;    // a = 20; // error    return 0;&#125;\n如果将注释符号去掉，将出现编译的错误，支出不能给常量赋值。因此，常量是一种确保某些数据不能修改的强大方式。\nconstexpr\nC++中有一个关键字constexpr，这个关键字既可以修饰函数，又可以修饰变量。constexpr可以在编译期生效，这是它最大的特点。\n在按下编译运行时，代码经历了两个流程，一个是编译期，一个是运行期(有的软件会把编译和运行分开，可以仅执行编译而不运行，如DEV-C++)。编译期就是从按下编译到产生可执行文件(Windows是.exe文件)的阶段，运行期就是这个可执行文件开始运行到最后运行完成的阶段(相当于双击了.exe文件)。\n修饰函数\n返回常量表达式\n#include &lt;iostream&gt;using namespace std;// 用constexpr修饰下面这个函数// 可以看到，这个函数无论何时被调用返回固定值constexpr double GetPi() &#123;return 22.0/7;&#125;// 下面这个代码调用了GetPi()// 由于GetPi()是常量表达式// 下面这个函数也是无论何时调用都返回固定值constexpr double TwicePi() &#123;return GetPi()*2;&#125;int main() &#123;    cout &lt;&lt; GetPi() &lt;&lt; endl;    cout &lt;&lt; TwicePi() &lt;&lt; endl;    return 0;&#125;\n上面这个示例代码中，GetPi()无论何时被调用都会返回固定的值，且被constexpr修饰，因此，它变成了常量表达式。相当于把计算出来的结果直接放进了二进制文件中，它的作用相当于一个名字为GetPi()的常量。而TwicePi()使用了这个常量，因此它的值也是固定的，也成为了常量表达式。\n\n如果TwicePi()里面用了const定义的常量，那它就不是常量表达式，因为const是运行期生效，在编译期，TwicePi里面存在变量，编译期会认为这个函数的返回值会发生变化，因此将它当做普通函数。\n\n返回普通函数\n正如上面所说，若是编译器在编译期无法确定函数的返回值是确定的，编译器就会将函数作为普通函数进行编译。\n修饰变量\nconstexpr修饰变量的语法与const类似。\nconstexpr int a = 5;\n上面这行代码定义了一个编译期全局变量，在编译期，所有用到这个常量a的地方都被替换为了5写进了二进制文件中。\n\n综上所述，constexpr与const最大的区别在于值的确定时机，目前这个区别只能用来提高编译函数的效率，但是在后面的场景中，会出现二者不能混用的情况。\n\n\n强烈建议：在可使用也可以不使用constexpr时，一定要使用它\n\n枚举\n有些时候，变量只会有一些特定的值，比如星期，只会有7天，这时就可以使用枚举变量。\n#include &lt;iostream&gt;using namespace std;//彩虹的颜色enum RainbowColors&#123;    Red,    Orange,    Yellow,    Green,    Blue,    Indigo,    Violet&#125;;int main()&#123;    //声明变量    RainbowColors color = Green;    cout &lt;&lt; &quot;The color is &quot; &lt;&lt; color &lt;&lt; endl;    return 0;&#125;\n上面的代码中，RainbowColors类型的变量只有七个可取的颜色，不能取其他值，运行结果为\nThe color is 3\n在枚举变量中，变量的值是枚举类型的索引，从0开始，上面的代码中，Red是第一个变量，因此索引为0，Orange是第二个变量，索引为1，以此类推。\n若是希望索引不是从0开始，可以这样做\nenum RainbowColors&#123;    Red = 7,    Orange,    Yellow,    Green,    Blue,    Indigo,    Violet&#125;;\n这样，索引就会从7开始，Orange为8，以此类推。\nenum ResultCode &#123;    OK = 0,            // 成功    ERROR_PARAM = -1,  // 参数错误    ERROR_NET = -2,    // 网络错误    ERROR_AUTH = -3    // 权限错误&#125;;\n也可以这样给枚举里的枚举值赋值，这样枚举的索引将是被赋予的值，这种一般用在表示状态的类型里。\n// 允许值重复（特殊场景用，如「别名」）enum Flag &#123;    Enable = 1,    Open = 1,   // 与 Enable 等价，别名    Disable = 0,    Close = 0   // 与 Disable 等价&#125;;\n可以看到，枚举值的索引是可以重复的。\n\n枚举是一个很简单的用法，但是它在项目中又无处不在，因为它不仅可以规定变量的取值范围，还可以用语义化名称替代不知含义的数字，让人一眼可以看懂\n\ndefine\nC++允许使用预处理器指令define来定义常量，但是这种方式不建议使用，这里提出这种方式只是为了方便阅读一些使用了这种方式定义常量的代码。\n#define PI 3.14159\n上面这行代码的结果就是让PI等于3.14159。但是这与前面介绍的方法有很大的区别。预处理器会将代码中的所有的PI替换为3.14159，然后再让编译器进行编译，这种替换是文本替换，而不是智能替换，编译器不知道常量的类型，这可能会导致一些意料之外的错误。\n关键字\n有些单词被C++保留，不能用作变量名。对编译器来说，这些关键字有特殊含义，包括：if、while等。\n","categories":["C++"],"tags":["C++"]}]