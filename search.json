[{"title":"CPP函数","url":"/2026/01/03/CPP%E5%87%BD%E6%95%B0/","content":"函数是一段可重用的代码块，用于执行特定任务。它接收输入（参数），执行操作，并可能返回结果。函数的核心价值在于封装和复用，让我们的代码更加模块化、可维护。\n函数声明与定义\n函数需要先声明后使用。函数声明告诉编译器函数的存在，而函数定义则包含函数的具体实现。\n// 函数声明（通常放在头文件中）int add(int a, int b);// 函数定义（通常放在源文件中）int add(int a, int b) &#123;    return a + b;&#125;\n声明：只包含函数签名，以分号结束，告诉编译器&quot;这个函数存在&quot;。定义：包含函数体（花括号内的代码），告诉编译器&quot;这个函数具体做什么&quot;\n使用函数\n函数的调用\n函数调用是使用函数的过程。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 形参：name 和 agevoid greet(string name, int age) &#123;    cout &lt;&lt; &quot;你好，&quot; &lt;&lt; name &lt;&lt; &quot;! 你今年&quot; &lt;&lt; age &lt;&lt; &quot;岁。&quot; &lt;&lt; endl;&#125;int main() &#123;    // 实参：&quot;小明&quot; 和 25    greet(&quot;小明&quot;, 25);  // 输出：你好，小明! 你今年25岁。        string myName = &quot;小红&quot;;    int myAge = 30;    greet(myName, myAge);  // 输出：你好，小红! 你今年30岁。        return 0;&#125;\n在上面的代码中，greet(&quot;小明&quot;, 25); 和greet(myName, myAge);就是在调用greet函数。\n调用函数时，要有函数名greet，后面紧跟一个()，括号里要传入函数需要的参数，参数在函数声明时就已经决定string name, int age，因此调用greet函数时，括号里必须有两个参数，第一个是string类型的，第二个是int类型的，且顺序不能颠倒(传递的参数可以是变量，也可以是常量，但是类型一定要正确)。\n形参\n形参（形式参数）是函数定义中的变量。在上面的示例中，形参就是name和age，他们在函数声明时被声明，它们的作用域仅在函数greet中。\n\n在函数中修改形参，对调用函数时传入的参数不会有影响，也就是在函数中修改age时，main中的myAge并不会被改变\n\n实参\n实参（实际参数）是调用时传递的具体值。在上面的示例中，实参就是&quot;小明&quot;，25，myName，myAge\n\n上面这种修改形参不会改变实参的方式，在C++中叫做值传递\n\n没有返回值的函数\n在上面的示例中，greet函数的返回值类型是void，这个类型并不在之前讲到的变量类型中。在C++中，void表示’空’，也就是什么也没有。\n在函数中，将返回值类型设置为void表示这个函数没有返回值，也就是说，这个函数不能被放在=的右侧。\n没有参数的函数\n在C++中，完全可以声明并定义一个没有参数的函数，它可以与没有返回值的函数联合使用，用来完成初始化的工作。\n#include &lt;iostream&gt;using namespace std;void initializeSystem() &#123;    cout &lt;&lt; &quot;系统正在初始化...&quot; &lt;&lt; endl;    // 这里可以添加初始化代码    cout &lt;&lt; &quot;系统初始化成功！&quot; &lt;&lt; endl;&#125;int main() &#123;    initializeSystem();  // 调用另一个无参数无返回值函数        return 0;&#125;\n上面这个代码中，就使用了没有返回值没有参数的函数，用来初始化系统。这里只是一个示例，在嵌入式系统中，这种写法更为常见。\n使用场景：\n\n\n显示菜单\n\n\n初始化全局状态\n\n\n执行一次性操作\n\n\n清理资源\n\n\n带默认值的函数参数\n如果要写一个计算圆的面积的函数，一般来说，圆周率取3.14就可以满足要求了，但是有些时候又要更高的精度。这个时候，将它作为函数的一个参数，让用户自行决定使用多高精度的圆周率即可。但是如果不追求高精度，每次调用函数都要输入一次3.14，这对普通用户而言就太麻烦了。这个时候，可以使用带默认值的函数参数。\n#include &lt;iostream&gt;using namespace std;//计算圆的面积，其中参数Pi是带默认参数的double Area(double r, double Pi = 3.14)&#123;    return Pi * r * r;&#125;int main()&#123;    double r = 3;    cout &lt;&lt; &quot;面积为(用默认参数):&quot;&lt;&lt; Area(r) &lt;&lt; endl;    cout &lt;&lt; &quot;面积为(用自定参数):&quot;&lt;&lt; Area(r, 3.1416) &lt;&lt; endl;    return 0;&#125;\n可以看到，在使用了带默认值的参数后，调用函数时可以不传递这个参数，它会使用默认值进行计算；也可以传递自己想使用的值，程序就会用传递的参数进行计算。\n\n\n\n默认参数必须放在非默认参数之后\n\n\n不能跳过中间参数（不能只提供第一个和第三个参数）\n\n\n默认参数在函数声明中指定（如果声明和定义分离）\n\n\n\n递归函数\n前面的代码中，函数自己不会调用自己，如果专门设计一个可以调用自己的函数，那它就被称为递归函数。递归需要两个关键部分：基准条件（base case）和递归条件（recursive case）。\n递归函数适合用于问题本身具有明显递归结构或可自然分解为相同子问题的场景，即：大问题可以拆分为若干个与原问题形式完全相同、规模更小的子问题。也可以用于处理层级结构或嵌套结构或需要在多个选择中不断“尝试—撤销—再尝试”的场景。\n#include &lt;iostream&gt;using namespace std;// 计算阶乘的递归函数unsigned long long factorial(int n) &#123;    // 基准条件    if (n &lt;= 1) &#123;        return 1;    &#125;    // 递归条件    return n * factorial(n - 1);&#125;// 计算斐波那契数列int fibonacci(int n) &#123;    if (n &lt;= 1) &#123;        return n;    &#125;    return fibonacci(n - 1) + fibonacci(n - 2);&#125;int main() &#123;    cout &lt;&lt; &quot;5! = &quot; &lt;&lt; factorial(5) &lt;&lt; endl;      // 输出：120    cout &lt;&lt; &quot;斐波那契数列第8项 = &quot; &lt;&lt; fibonacci(8) &lt;&lt; endl;  // 输出：21        return 0;&#125;\n以阶乘为例，当调用factorial(5)时，调用栈会依次展开：\n\n\nfactorial(5) 调用 factorial(4)\n\n\nfactorial(4) 调用 factorial(3)\n\n\nfactorial(3) 调用 factorial(2)\n\n\nfactorial(2) 调用 factorial(1)\n\n\nfactorial(1) 返回 1\n\n\n然后逐层返回：2×1=2, 3×2=6, 4×6=24, 5×24=120\n\n\n递归也有着诸多缺陷：\n\n\n栈溢出（stack overflow）如果递归太深\n\n\n性能问题\n\n\n因此在实际应用中，考虑使用迭代或尾递归优化。\nreturn\n在函数定义中，并非只能有一条return语句，可以在函数的任何地方返回，如果愿意，还可包含多条return语句\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;bool isPrime(int n) &#123;    if (n &lt;= 1) return false;           // 提前返回    if (n == 2 || n == 3) return true;  // 提前返回        for (int i = 2; i * i &lt;= n; i++) &#123;        if (n % i == 0) &#123;            return false;  // 发现因子，提前返回        &#125;    &#125;        return true;  // 所有检查通过，是质数&#125;int main() &#123;    cout &lt;&lt; &quot;7是质数: &quot; &lt;&lt; isPrime(7) &lt;&lt; endl;     // 输出：1 (true)    cout &lt;&lt; &quot;15是质数: &quot; &lt;&lt; isPrime(15) &lt;&lt; endl;   // 输出：0 (false)        return 0;&#125;\n使用return可以中断函数的运行，如果是无返回值的函数，可以使用return;返回。\n函数重载\n函数重载允许在同一个作用域内定义多个同名函数，但参数列表不同（参数类型、数量或顺序不同）。\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;// 重载函数：不同参数类型void print(int value) &#123;    cout &lt;&lt; &quot;整数: &quot; &lt;&lt; value &lt;&lt; endl;&#125;void print(double value) &#123;    cout &lt;&lt; &quot;浮点数: &quot; &lt;&lt; value &lt;&lt; endl;&#125;void print(string value) &#123;    cout &lt;&lt; &quot;字符串: &quot; &lt;&lt; value &lt;&lt; endl;&#125;// 重载函数：不同参数数量void log(string message) &#123;    cout &lt;&lt; &quot;[信息] &quot; &lt;&lt; message &lt;&lt; endl;&#125;void log(string message, string level) &#123;    cout &lt;&lt; &quot;[&quot; &lt;&lt; level &lt;&lt; &quot;] &quot; &lt;&lt; message &lt;&lt; endl;&#125;int main() &#123;    print(42);           // 调用 print(int)    print(3.14159);      // 调用 print(double)    print(&quot;你好&quot;);       // 调用 print(string)        log(&quot;系统已启动&quot;);                // 调用 log(string)    log(&quot;数据库连接成功&quot;, &quot;成功&quot;);    // 调用 log(string, string)        return 0;&#125;\n函数重载必须保证函数名和返回类型相同，只有参数可以不同。\n多态\n这里可以引出面向对象语言的三大特性之一：多态。多态的字面意思是多种形态，后面会专门介绍，这里只需要知道函数重载就是其中的一种情况。\n多态分为两种：\n\n\n编译时多态：通过函数重载和运算符重载实现，编译器在编译时就确定调用哪个函数。\n\n\n运行时多态：通过虚函数和继承实现，程序在运行时根据对象的实际类型决定调用哪个函数。\n\n\n传递数组\n数组的传递是以指针的方式传递的。指针简单来说就是地址，前面提到，数组在内存中是连续存储的，因此，只要知道数组的第一个元素的地址，后面的任意元素的地址都可以计算出来。将指针传递给函数，就是将数组的首地址传递给了函数，函数就可以对数组进行操作\n\n这里要注意，操作数组就是在操作地址，所以在函数里修改数组会把原来的数组也修改了。还需要注意，由于传递数组的本质是传递指针，所以数组失去了大小的信息，所以要显式传递数组的大小。\n\n#include &lt;iostream&gt;using namespace std;// 方法1：传递数组指针（最常见）void printArray(int arr[], int size) &#123;    cout &lt;&lt; &quot;数组内容: &quot;;    for (int i = 0; i &lt; size; i++) &#123;        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;&#125;// 方法2：传递指针和大小（更明确）int* arr表示声明了一个int类型的指针，名字叫做arrvoid processArray(int* arr, int size) &#123;    cout &lt;&lt; &quot;处理大小为&quot; &lt;&lt; size &lt;&lt; &quot;的数组: &quot;;    for (int i = 0; i &lt; size; i++) &#123;        arr[i] *= 2;  // 修改原始数组    &#125;&#125;int main() &#123;    int numbers[] = &#123;1, 2, 3, 4, 5&#125;;    int size = sizeof(numbers) / sizeof(numbers[0]);        cout &lt;&lt; &quot;原始数组: &quot;;    printArray(numbers, size);  //运行结果：1 2 3 4 5        processArray(numbers, size);        cout &lt;&lt; &quot;修改后的数组: &quot;;    printArray(numbers, size);  //运行结果：2 4 6 8 10        return 0;&#125;\n按引用传递\nC++的值传递相当于运行了一次赋值，这就导致参数实际上是被复制了一份，对于一些数据结构，对它进行赋值拷贝需要很大的开销，为了避免这些开销，可以使用引用传递。\n引用传递就好像给实参起了一个别名，这样使用这个别名也相当于操作了这个实参，因此引用传递的参数如果在函数中被修改，那么实参也会对应的被修改。\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;// 按值传递：不会修改原始变量void modifyByValue(int x) &#123;    x = 100;    cout &lt;&lt; &quot;在modifyByValue函数内: x = &quot; &lt;&lt; x &lt;&lt; endl;&#125;// 按引用传递：会修改原始变量void modifyByReference(int&amp; x) &#123;    x = 200;    cout &lt;&lt; &quot;在modifyByReference函数内: x = &quot; &lt;&lt; x &lt;&lt; endl;&#125;// 常量引用：既避免拷贝，又保护数据不被修改void printString(const string&amp; str) &#123;    cout &lt;&lt; &quot;字符串长度: &quot; &lt;&lt; str.length() &lt;&lt; endl;    cout &lt;&lt; &quot;内容: &quot; &lt;&lt; str &lt;&lt; endl;&#125;// 引用传递大对象：显著提高效率void processVector(vector&lt;int&gt;&amp; vec) &#123;    cout &lt;&lt; &quot;处理包含&quot; &lt;&lt; vec.size() &lt;&lt; &quot;个元素的向量&quot; &lt;&lt; endl;    for (int&amp; num : vec) &#123;        num *= 2;    &#125;&#125;int main() &#123;    int value = 10;        cout &lt;&lt; &quot;调用modifyByValue前: value = &quot; &lt;&lt; value &lt;&lt; endl;    modifyByValue(value);    cout &lt;&lt; &quot;调用modifyByValue后: value = &quot; &lt;&lt; value &lt;&lt; endl;        cout &lt;&lt; &quot;\\n调用modifyByReference前: value = &quot; &lt;&lt; value &lt;&lt; endl;    modifyByReference(value);    cout &lt;&lt; &quot;调用modifyByReference后: value = &quot; &lt;&lt; value &lt;&lt; endl;        string text = &quot;你好，C++！&quot;;    printString(text);  // 不会修改text，且避免了拷贝        vector&lt;int&gt; numbers = &#123;1, 2, 3, 4, 5&#125;;    processVector(numbers);    cout &lt;&lt; &quot;修改后的向量: &quot;;    for (int num : numbers) &#123;        cout &lt;&lt; num &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;        return 0;&#125;\n按引用传递与指针传递不同，指针可以重新指向另一个地址，但是引用一旦被赋值，就不能再引用其他变量。\n按引用传参的优势：\n\n\n避免大对象的拷贝开销\n\n\n允许函数修改调用者的变量\n\n\n可以返回多个值（通过多个引用参数）\n\n\n常量引用（const &amp;）的最佳实践：\n\n\n当函数不需要修改参数时，使用const引用\n\n\n既获得引用的效率，又保证数据的安全性\n\n\n适用于字符串、容器、自定义对象等大对象\n\n\n三种传递方式的区别\n\n\n\n\n按值传递\n按引用传递\n按指针传递\n\n\n\n\n参数复制\n需要复制实参\n不需要复制实参\n复制指针\n\n\n内存消耗\n可能较大\n较小\n较小\n\n\n安全性\n安全\n较安全\n不安全\n\n\n\n处理器操作\n函数的调用在计算机内部，就是一个入栈出栈的操作。\n栈\n栈是C++在操作程序的时候规定的一片空间，栈的特点是先入后出。这就像放盘子和拿盘子一样，你会将最先洗完的盘子放在最下面，最后洗完的盘子放在上面；在使用盘子时则相反，你会先拿上面的盘子使用。\n函数与栈\n看下面的示例代码\n#include &lt;iostream&gt;using namespace std;void functionB(int y) &#123;    cout &lt;&lt; &quot;在functionB函数内, y = &quot; &lt;&lt; y &lt;&lt; endl;&#125;void functionA(int x) &#123;    cout &lt;&lt; &quot;在functionA函数内, x = &quot; &lt;&lt; x &lt;&lt; endl;    functionB(x + 10);&#125;int main() &#123;    cout &lt;&lt; &quot;开始执行main函数&quot; &lt;&lt; endl;    functionA(5);    cout &lt;&lt; &quot;回到main函数&quot; &lt;&lt; endl;    return 0;&#125;\n运行结果：\n开始执行main函数在functionA函数内, x = 5在functionB函数内, y = 15回到main函数\n上面这个代码在计算机的流程如图所示可以看到栈指针一直指向栈顶，在栈指针指向的位置可以插入下一个元素。\n当程序开始运行，会依次进行下面的步骤：\n\n\n首先运行main函数，将main压入栈\n\n\nmain中调用了functionA，此时将functionA压入栈\n\n\nfunctionA中调用了functionB，此时将functionB压入栈\n\n\nfunctionB运行结束，将functionB弹出\n\n\nfunctionA运行结束，将functionA弹出\n\n\nmain运行结束，将main弹出\n\n\n程序运行结束\n\n\n\n从上面的步骤可以看出，调用函数与直接将逻辑写在main函数里相比，调用函数会有额外的开销，因此要避免频繁地调用函数的行为。\n\n\n但是如果一段逻辑会被多次使用，仍然建议把它封装为函数。这是因为在每个需要使用这段逻辑的地方重写代码不仅费时费力，还会让程序占用更多的空间。\n\n内联函数\n内联函数（inline）是一种编译器优化，将函数调用替换为函数体本身，避免函数调用开销。语法就是在普通函数定义方式的前面加上inline\n#include &lt;iostream&gt;#include &lt;chrono&gt;using namespace std;using namespace chrono;// 普通函数int addRegular(int a, int b) &#123;    return a + b;&#125;// 内联函数inline int addInline(int a, int b) &#123;    return a + b;&#125;int main() &#123;    //计时器    const int iterations = 10000000;    auto start1 = high_resolution_clock::now();        // 测试普通函数    int sum1 = 0;    for (int i = 0; i &lt; iterations; i++) &#123;        sum1 += addRegular(i, i + 1);    &#125;    //结束计时    auto end1 = high_resolution_clock::now();    auto duration1 = duration_cast&lt;milliseconds&gt;(end1 - start1);        //计时器    auto start2 = high_resolution_clock::now();    // 测试内联函数    int sum2 = 0;    for (int i = 0; i &lt; iterations; i++) &#123;        sum2 += addInline(i, i + 1);    &#125;    //结束计时    auto end2 = high_resolution_clock::now();    auto duration2 = duration_cast&lt;milliseconds&gt;(end2 - start2);        cout &lt;&lt; &quot;普通函数耗时: &quot; &lt;&lt; duration1.count() &lt;&lt; &quot; 毫秒&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;内联函数耗时: &quot; &lt;&lt; duration2.count() &lt;&lt; &quot; 毫秒&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;结果: &quot; &lt;&lt; sum1 &lt;&lt; &quot;, &quot; &lt;&lt; sum2 &lt;&lt; endl;        return 0;&#125;\n结果为：\n普通函数耗时: 15 毫秒内联函数耗时: 14 毫秒结果: 276447232, 276447232\n这段程序在运行时并不一定总是内联函数耗时更短，导致这种现象的原因有很多种可能。首先inline只是给编译器的建议，编译器并不一定会采取内联的方式，而不加内联的普通函数也有可能被编译器自动优化为内联函数，这是编译器自带的优化。再往底层考虑也会有多种可能，甚至硬件的状态也会影响结果。尽管如此，仍然建议将非常简单的函数声明为内联函数。\n\n这是一种用内存换时间的方案\n\n自动推断返回类型\n前面我们说过可以用auto关键字自动推断变量类型，在C++14之后，函数的返回类型也可以使用auto自动推断。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;// 基本用法：auto推断返回类型auto add(int a, int b) &#123;    return a + b;  // 编译器推断返回类型为int&#125;// 复杂类型推断auto getMinMax(const vector&lt;int&gt;&amp; vec) &#123;    if (vec.empty()) &#123;        return make_pair(0, 0);  // 返回pair&lt;int, int&gt;    &#125;    auto minmax = minmax_element(vec.begin(), vec.end());    return make_pair(*minmax.first, *minmax.second);&#125;int main() &#123;    cout &lt;&lt; &quot;add(5, 3) = &quot; &lt;&lt; add(5, 3) &lt;&lt; endl;        vector&lt;int&gt; numbers = &#123;3, 1, 4, 1, 5, 9, 2, 6&#125;;    auto result = getMinMax(numbers);    cout &lt;&lt; &quot;最小值: &quot; &lt;&lt; result.first &lt;&lt; &quot;, 最大值: &quot; &lt;&lt; result.second &lt;&lt; endl;        return 0;&#125;\n可以看到，当函数返回复杂的类型时，可以使用auto自动推断，这在模板编程中特别有用。\n\n注意：递归函数必须显式指定返回类型\n\nLambda函数\n本节只会简单介绍Lambda函数，因为完全学习它需要一些还未学到的知识做支撑。但是为了能够更加系统的建立起知识网络，这里还是要简单学习。\nlambda函数的基本语法为\n[capture](parameters) -&gt; return_type &#123;    // 函数体&#125;\n下面是一个使用示例\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;using namespace std;int main() &#123;    vector&lt;int&gt; numbers = &#123;5, 2, 8, 1, 9, 3, 7, 4&#125;;        cout &lt;&lt; &quot;原始向量: &quot;;    for (int num : numbers)         cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;        // 简单的lambda：捕获空，参数为两个int，返回bool    sort(numbers.begin(), numbers.end(), [](int a, int b) &#123;        return a &lt; b;    &#125;);        cout &lt;&lt; &quot;升序排序后: &quot;;    for (int num : numbers) cout &lt;&lt; num &lt;&lt; &quot; &quot;;    cout &lt;&lt; endl;    return 0;&#125;\n其中，lambda函数是[](int a, int b){ return a &lt; b; }这部分，它成为了sort函数的一个参数。很明显可以看出，这个lambda函数的作用是当a&lt;b时，返回true，也就是让动态数组升序排列。运行结果为\n原始向量: 5 2 8 1 9 3 7 4 升序排序后: 1 2 3 4 5 7 8 9","categories":["C++"],"tags":["C++"]},{"title":"CPP变量与常量","url":"/2025/12/26/CPP%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/","content":"变量\n变量是在代码中可以被改变的数据，在使用变量前，要先规定变量的类型和名称，如果规定是整数型，那它就不能用来存储小数。变量类型向编译器指出了变量可存储的数据的性质，编译器将为变量预留必要的空间。\n内存\n在计算机中，处理器负责执行应用程序，在此过程中，它会从 RAM（随机存取存储器）中读取程序的二进制指令及相关数据。RAM 可以看作是一系列连续的存储单元（“格子”），每个单元可以存放一个固定大小的数据项。需要注意的是，一个存储单元只能容纳一份数据，但同一份数据可以被复制到多个单元中。\n举个例子：假设你有一整套螺丝刀（我们将其视为一个完整的数据结构），但每个格子的容量只能容纳一把螺丝刀。这时，你需要将这套螺丝刀拆开，将每把螺丝刀依次放入相邻的格子中。这样一来，当你需要使用整套工具时，就可以快速按顺序取出这些螺丝刀，并重新组合成完整的工具集。\n这样的类比有助于理解：在内存中，复杂的数据（如数组、结构体等）通常是以连续或关联的方式分布在多个内存单元中的，以便处理器高效访问和处理。\n声明变量\n在C++中，声明变量的基本格式是 VariableType VariableName，例如 int a，其中 int 是变量的类型，a 是变量的名称。\n声明变量的作用是向系统申请一块与其类型相匹配大小的内存空间。一旦变量被声明，这块内存就会被“预留”给该变量，直到其生命周期结束（例如离开作用域或被显式释放）。在这期间，该内存不会被分配给其他变量。\n需要注意的是，如果在声明变量时没有显式初始化（即没有在声明时赋予初始值），那么该变量的值将是未定义的——它会包含该内存位置当前残留的任意内容。这并非“上一个程序”留下的数据（现代操作系统通常会为每个进程提供独立的虚拟地址空间，并在分配内存时清零或做安全处理），而更可能是之前在同一程序中该内存位置所存储的旧值，或者是未初始化的“垃圾值”。\n可以用一个类比来理解：想象一个格子原本放着一把螺丝刀，后来格子的主人不再使用它，但没有清空格子。如果新主人直接使用这个格子而不放新东西进去，那么他拿到的还是那把旧螺丝刀。因此，在使用变量前进行初始化，是避免意外行为和保证程序可靠性的良好实践。\n初始化变量\n下面是初始化变量的示例代码\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化变量    int a = 10;    //声明多个变量    int b1, b2;    //初始化多个变量    int c1 = 10, c2 = 20, c3 = 30;    return 0;&#125;\n在C++中，变量的初始化是在声明时进行的，可以同时声明多个相同类型的变量，也可以同时初始化多个变量，中间用逗号隔开。\n作用域\n变量的作用域是变量能够被使用的范围。一旦超出了这个作用域，变量就无法被使用。如果变量的作用域是函数，那么这个变量会在函数结束后被销毁。\n在上面的代码中，变量声明和初始化是在 main 函数中，一旦 main 函数执行完毕，变量就会自动销毁。而如果在main函数中调用另一个函数，在运行另一个函数时，main里面的变量无法被访问。可以尝试运行下面的代码，看看是否能编译成功。\n#include &lt;iostream&gt;using namespace std;int sum(int a, int b) &#123;    //使用main函数里的变量    x = x + y;    return a + b;&#125;int main() &#123;    int x = 1, y = 2;    cout &lt;&lt; sum(x, y) &lt;&lt; endl;    return 0;&#125;\n上面的代码会编译失败，因为x和y的作用域是main函数，在sum函数中无法使用。同理，main函数也无法使用sum函数中的变量。\n\n只有在函数运行结束后，变量才会被销毁，在上面的例子中，sum函数只是无法使用x和y，但它们并没有被释放。\n\n全局变量\n如果有一个变量在多个函数中都使用，那么就可以将其定义为全局变量。全局变量和普通变量一样，区别在于它是在函数外被声明的，并且可以在任意函数中访问。\n#include &lt;iostream&gt;using namespace std;int a = 10, b = 20;int sum()&#123;    return a + b;&#125;int main()&#123;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum() &lt;&lt; endl;    return 0;&#125;\n运行后可以看到运行结果：\na = 10b = 20sum = 30\n虽然main函数和sum函数没有定义变量a和b，但程序依然可以正确的编译运行，因为全局变量的作用域是整个程序，因此可以在任意函数中访问。\n如果在函数里重新声明变量，那么局部变量会屏蔽全局变量。\n#include &lt;iostream&gt;using namespace std;int a = 10, b = 20;int sum()&#123;    //重新声明变量a    int a = 30;    return a + b;&#125;int main()&#123;    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;    cout &lt;&lt; &quot;sum = &quot; &lt;&lt; sum() &lt;&lt; endl;    //使用全局变量a    cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n运行后可以看到运行结果：\na = 10b = 20sum = 50a = 10\n可以看到，在sum函数中重新声明了变量a，在 sum 函数中声明的局部变量 a 屏蔽了全局变量 a，因此在该函数内部引用 a 时，指的是局部变量，而非全局变量。在sum函数结束后，sum声明的变量a被销毁，因此a的值被恢复为10。\n命名规范\n在上面的代码中，变量的名字都是简单的字母，但是在实际项目中，每个变量都有自己的含义，这个时候，变量名应该具有意义，这样可以让自己和其他人更容易理解一个变量的作用。比如，如果要定义年龄变量，应该这么写int age = 18;，这样在调用的时候很方便理解变量含义。\n在C++中，变量名只能使用字母、数字、下划线，不能使用特殊字符，并且变量名不能以数字开头。C++变量区分大小写，因此变量名Age和age是不同的(函数名同理)。\n推荐一个大家约定俗成的变量命名规范：驼峰命名法。驼峰命名法就是将变量首字母小写，然后每个单词首字母大写，比如phoneNumber，首字母p小写，第二个单词首字母N大写。\n与变量的驼峰命名法类似，函数命名规范采用Pascal命名法，即每个单词首字母大写，比如GetPhoneNumber。\n变量类型\n整数类型\nC++中，整数类型有char、short、int、long、long long，它们的大小由具体实现决定，但 C++ 标准确保：sizeof(char) ≤ sizeof(short) ≤ sizeof(int) ≤ sizeof(long) ≤ sizeof(long long)。在大多数现代系统上，char 为 8 位，short 为 16 位，int 为 32 位，long 为 32 或 64 位，long long 为 64 位(位数指的是二进制位数)。\n有符号整数\n在计算机中，整数的存储通过补码形式存储，如果补码二进制第一位是’0’，则表示这个整数是整数，如果补码二进制第一位是’1’，则表示这个整数是负数。因此，对于16位整数，只有15位表示数字的大小，最高位表示数字的正负。\n无符号整数\n无符号整数就是没有符号位的整数，最高位无论是0还是1，都是正数。因此，对于16位的无符号整数，16位都表示数字的大小。\n\n关于原码、反码、补码可以参考这篇博客二进制数的原码、反码、补码（详解），这部分内容推荐阅读。\n\n浮点类型\nC++中，浮点类型有float、double、long double，分别表示单精度、双精度、长双精度。\n字符类型\nC++中，字符类型一般用char，字符类型要用单引号括住，比如'a'。可以发现，在整数类型中也有char类型，这是因为在计算机中，字符是通过编码为整数存储在内存中的，所以char类型既是整数类型，也是字符类型。比较常见的编码形式有ASCII、UTF-8(支持绝大多数语言)、GBK(只支持中文和英文)等。\n\n要注意的是，由于字符的编码都是正整数，所以char类型的变量是无符号类型的整数\n\n布尔类型\n布尔类型用bool表示，只有两个值，true和false。\n下面是声明不同类型变量的示例：\n#include &lt;iostream&gt;using namespace std;int main() &#123;  int myNum1 = 5;               // 声明整数类型变量  short int myNum2 = 5;        // 短整型  unsigned int myNum3 = 5;     // 无符号整型  float myFloatNum = 5.99;     // 声明单精度浮点数类型变量  double myDoubleNum = 9.98;   // 声明双精度浮点数类型变量  char myLetter = &#x27;D&#x27;;         // 声明字符类型变量  bool myBoolean = true;       // 声明布尔类型变量  cout &lt;&lt; &quot;整数类型变量：&quot; &lt;&lt; myNum1 &lt;&lt; &quot;\\n&quot;;   //&#x27;\\n&#x27;表示换行  cout &lt;&lt; &quot;短整型变量：&quot; &lt;&lt; myNum2 &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;无符号整型变量：&quot; &lt;&lt; myNum3 &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;单精度浮点数类型变量：&quot; &lt;&lt; myFloatNum &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;双精度浮点数类型变量：&quot; &lt;&lt; myDoubleNum &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;字符类型变量：&quot; &lt;&lt; myLetter &lt;&lt; &quot;\\n&quot;;  cout &lt;&lt; &quot;布尔类型变量：&quot; &lt;&lt; myBoolean &lt;&lt; &quot;\\n\\n&quot;;  //给无符号整型赋值负数  myNum3 = -5;  cout &lt;&lt; &quot;无符号整型变量：&quot; &lt;&lt; myNum3 &lt;&lt; &quot;\\n\\n&quot;;  //给短整型赋值32800  myNum2 = 32800;  cout &lt;&lt; &quot;短整型变量：&quot; &lt;&lt; myNum2 &lt;&lt; &quot;\\n\\n&quot;;  return 0;&#125;\n运行结果为：\n整数类型变量：5短整型变量：5无符号整型变量：5单精度浮点数类型变量：5.99双精度浮点数类型变量：9.98字符类型变量：D布尔类型变量：1无符号整型变量：4294967291短整型变量：-32736\n前几行都是正确的结果，但是后两个的输出结果明显与赋值不同，无符号整型变量从-5变成了一个很大的正数，短整型从正数变为了负数。第一个结果的原因是，无符号整数没有符号位，但是-5有符号位，且为1，因此补码为11111111111111111111111111111101，也就是4294967291。第二个结果的原因是，短整型的范围是-32768到32767，因此当赋值超过这个范围时，会进行截断，截断后的值读取为-32736。\n\n这些结果是可以算出来的，并非随机的，可以参考上面的原码、反码、补码的介绍尝试计算。\n\n常用运算符和关键字\n下面介绍一下关于变量的常用的运算符和关键字\nsizeof\nsizeof()是C++提供的一个运算符，可用于确定变量的长度\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; endl;              // 查看char所占字节数    cout &lt;&lt; &quot;sizeof(short) = &quot; &lt;&lt; sizeof(short) &lt;&lt; endl;            // 查看short所占字节数    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; endl;                // 查看int所占字节数    cout &lt;&lt; &quot;sizeof(long) = &quot; &lt;&lt; sizeof(long) &lt;&lt; endl;              // 查看long所占字节数    cout &lt;&lt; &quot;sizeof(long long) = &quot; &lt;&lt; sizeof(long long) &lt;&lt; endl;    // 查看long long所占字节数    cout &lt;&lt; &quot;sizeof(float) = &quot; &lt;&lt; sizeof(float) &lt;&lt; endl;            // 查看float所占字节数    int a;    cout &lt;&lt; &quot;sizeof(a) = &quot; &lt;&lt; sizeof(a) &lt;&lt; endl;                    // 查看变量a所占字节数    return 0;&#125;\n运行结果为：\nsizeof(char) = 1sizeof(short) = 2sizeof(int) = 4sizeof(long) = 4sizeof(long long) = 8sizeof(float) = 4sizeof(a) = 4\nsizeof()的返回值是字节数，而不是位数(1Byte = 8bit，Byte表示字节，bit表示位)。\nauto\nauto是C++提供的自动推断类型的关键字，比如\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //使用auto自动推测变量类型    auto a = 10;    auto b = 10.5;    auto c = &#x27;a&#x27;;    auto d = true;    cout &lt;&lt; &quot;sizeof(a)=&quot; &lt;&lt; sizeof(a) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(b)=&quot; &lt;&lt; sizeof(b) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(c)=&quot; &lt;&lt; sizeof(c) &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(d)=&quot; &lt;&lt; sizeof(d) &lt;&lt; endl;    return 0;&#125;\n运行结果为\nsizeof(a)=4sizeof(b)=8sizeof(c)=1sizeof(d)=1\n根据之前的sizeof()的结果，可以发现，a 是int类型，b是double类型，c是char类型，d是bool类型。\ntypedef\nC++允许将变量类型替换为使用者认为方便的名称，为此可使用关键字 typedef。\n#include &lt;iostream&gt;using namespace std;typedef unsigned int uint;  // 将unsigned int定义为uintint main()&#123;    uint a = 10;    cout &lt;&lt; a &lt;&lt; endl;    a = -10;    cout &lt;&lt; a &lt;&lt; endl;    return 0;&#125;\n运行结果为：\n104294967286\n可以看到，uint声明出来的变量a，它的类型是unsigned int。这就是typedef的作用。\n常量\n常量是在程序中不会被改变的量，常量一旦声明，它的值就不能改变。常量在声明时一定要初始化，然后就不可被改变。\n字面常量\n在前面的程序中，字面常量几乎一直被使用，比如\ncout &lt;&lt; &quot;Hello World!&quot; &lt;&lt; endl;\n其中的&quot;Hello World!&quot;就是一个字面常量。或者在赋值时int a = 10;，这里面的10也是字面常量。\nconst\n可以通过const关键字将变量声明为常量，比如\n#include &lt;iostream&gt;using namespace std;int main()&#123;    const int a = 10;    cout &lt;&lt; a &lt;&lt; endl;    // a = 20; // error    return 0;&#125;\n如果将注释符号去掉，将出现编译的错误，支出不能给常量赋值。因此，常量是一种确保某些数据不能修改的强大方式。\nconstexpr\nC++中有一个关键字constexpr，这个关键字既可以修饰函数，又可以修饰变量。constexpr可以在编译期生效，这是它最大的特点。\n在按下编译运行时，代码经历了两个流程，一个是编译期，一个是运行期(有的软件会把编译和运行分开，可以仅执行编译而不运行，如DEV-C++)。编译期就是从按下编译到产生可执行文件(Windows是.exe文件)的阶段，运行期就是这个可执行文件开始运行到最后运行完成的阶段(相当于双击了.exe文件)。\n修饰函数\n返回常量表达式\n#include &lt;iostream&gt;using namespace std;// 用constexpr修饰下面这个函数// 可以看到，这个函数无论何时被调用返回固定值constexpr double GetPi() &#123;return 22.0/7;&#125;// 下面这个代码调用了GetPi()// 由于GetPi()是常量表达式// 下面这个函数也是无论何时调用都返回固定值constexpr double TwicePi() &#123;return GetPi()*2;&#125;int main() &#123;    cout &lt;&lt; GetPi() &lt;&lt; endl;    cout &lt;&lt; TwicePi() &lt;&lt; endl;    return 0;&#125;\n上面这个示例代码中，GetPi()无论何时被调用都会返回固定的值，且被constexpr修饰，因此，它变成了常量表达式。相当于把计算出来的结果直接放进了二进制文件中，它的作用相当于一个名字为GetPi()的常量。而TwicePi()使用了这个常量，因此它的值也是固定的，也成为了常量表达式。\n\n如果TwicePi()里面用了const定义的常量，那它就不是常量表达式，因为const是运行期生效，在编译期，TwicePi里面存在变量，编译期会认为这个函数的返回值会发生变化，因此将它当做普通函数。\n\n返回普通函数\n正如上面所说，若是编译器在编译期无法确定函数的返回值是确定的，编译器就会将函数作为普通函数进行编译。\n修饰变量\nconstexpr修饰变量的语法与const类似。\nconstexpr int a = 5;\n上面这行代码定义了一个编译期全局变量，在编译期，所有用到这个常量a的地方都被替换为了5写进了二进制文件中。\n\n综上所述，constexpr与const最大的区别在于值的确定时机，目前这个区别只能用来提高编译函数的效率，但是在后面的场景中，会出现二者不能混用的情况。\n\n\n强烈建议：在可使用也可以不使用constexpr时，一定要使用它\n\n枚举\n有些时候，变量只会有一些特定的值，比如星期，只会有7天，这时就可以使用枚举变量。\n#include &lt;iostream&gt;using namespace std;//彩虹的颜色enum RainbowColors&#123;    Red,    Orange,    Yellow,    Green,    Blue,    Indigo,    Violet&#125;;int main()&#123;    //声明变量    RainbowColors color = Green;    cout &lt;&lt; &quot;The color is &quot; &lt;&lt; color &lt;&lt; endl;    return 0;&#125;\n上面的代码中，RainbowColors类型的变量只有七个可取的颜色，不能取其他值，运行结果为\nThe color is 3\n在枚举变量中，变量的值是枚举类型的索引，从0开始，上面的代码中，Red是第一个变量，因此索引为0，Orange是第二个变量，索引为1，以此类推。\n若是希望索引不是从0开始，可以这样做\nenum RainbowColors&#123;    Red = 7,    Orange,    Yellow,    Green,    Blue,    Indigo,    Violet&#125;;\n这样，索引就会从7开始，Orange为8，以此类推。\nenum ResultCode &#123;    OK = 0,            // 成功    ERROR_PARAM = -1,  // 参数错误    ERROR_NET = -2,    // 网络错误    ERROR_AUTH = -3    // 权限错误&#125;;\n也可以这样给枚举里的枚举值赋值，这样枚举的索引将是被赋予的值，这种一般用在表示状态的类型里。\n// 允许值重复（特殊场景用，如「别名」）enum Flag &#123;    Enable = 1,    Open = 1,   // 与 Enable 等价，别名    Disable = 0,    Close = 0   // 与 Disable 等价&#125;;\n可以看到，枚举值的索引是可以重复的。\n\n枚举是一个很简单的用法，但是它在项目中又无处不在，因为它不仅可以规定变量的取值范围，还可以用语义化名称替代不知含义的数字，让人一眼可以看懂\n\ndefine\nC++允许使用预处理器指令define来定义常量，但是这种方式不建议使用，这里提出这种方式只是为了方便阅读一些使用了这种方式定义常量的代码。\n#define PI 3.14159\n上面这行代码的结果就是让PI等于3.14159。但是这与前面介绍的方法有很大的区别。预处理器会将代码中的所有的PI替换为3.14159，然后再让编译器进行编译，这种替换是文本替换，而不是智能替换，编译器不知道常量的类型，这可能会导致一些意料之外的错误。\n关键字\n有些单词被C++保留，不能用作变量名。对编译器来说，这些关键字有特殊含义，包括：if、while等。\n","categories":["C++"],"tags":["C++"]},{"title":"CPP控制程序流程(上)","url":"/2026/01/02/CPP%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B-%E4%B8%8A/","content":"在前面的程序中，我们总是一套逻辑从头执行到尾。但是这样的程序非常的死板，如果想和用户交互，根据用户的行为来决定执行哪些语句又该怎么办？\n三元运算符\n上一节说到的三元运算符? :是一种选择。这个运算符可以根据用户输入的内容和判断语句来选择执行哪个表达式。\n但是这样的方式只能执行一个表达式。大部分情况下，我们要根据不同的输入来执行一系列操作，很明显这个时候三元运算符就不适合使用了。\nif…else\nC++使用if...else帮助程序员解决这个问题。\nif…else基本结构\n下面是一个最简单的if...else结构。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用if else进行判断    if (op == &#x27;+&#x27;)  //如果符号是+，执行下面的语句        res = x+y;    else //如果符号不是+，执行下面的语句        res = x-y;            cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n运行结果：\n请输入计算式(用空格隔开，只能算加减):3 + 5结果为：8请输入计算式(用空格隔开，只能算加减):10 - 2.3结果为：7.7\n可以看到输入的两个计算式都被正确的计算了。\n再来看代码中的\n//使用if else进行判断if (op == &#x27;+&#x27;)  //如果符号是+，执行下面的语句    res = x+y;else //如果符号不是+，执行下面的语句    res = x-y;\n首先，if后面必须要有一个表达式，如果这个表达式结果为true，则执行if下面的语句，即res=x+y;\n如果if后面的表达式结果为false，则if下面的语句不会被执行，会转而执行else下面的语句。else表示：如果上面的判断都为false，就来执行else后面的语句。\n\n在没有使用花括号{}的情况下，if和else都只会执行后面紧跟着的一条语句。使用花括号可以将多条语句组合成一个代码块，使其全部被执行。\n\n执行多条语句\n如果仅仅是上面的效果，仍然满足不了执行多条语句的要求，这个时候，我们可以将要执行的多条语句用{}包裹，形成一个代码块，那么它们就都会被执行了。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用if else进行判断    if (op == &#x27;+&#x27;)  &#123;        cout &lt;&lt; &quot;执行加法&quot; &lt;&lt; endl;        res = x+y;    &#125;    else &#123;        cout &lt;&lt; &quot;执行减法&quot; &lt;&lt; endl;        res = x-y;    &#125;    cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n运行结果：\n请输入计算式(用空格隔开，只能算加减):5 + 3执行加法结果为：8请输入计算式(用空格隔开，只能算加减):4 - 2.2执行减法结果为：1.8\n可以看到运行结果中，if和else都执行了两条语句，语句数量可以扩展到更多。\nelse if\n在上面的示例中，如果用户没有按要求输入，那就会导致代码错误。例如\n请输入计算式(用空格隔开，只能算加减):3 / 2执行减法结果为：1\n可以看到用户输入了除法计算式，但是程序仍然按减法计算了，这就导致了错误。\n因此更推荐对每种情况都加一个判断语句，最后的else用来处理特殊情况。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用if else进行判断    if (op == &#x27;+&#x27;)      &#123;        res = x+y;    &#125;    else if(op == &#x27;-&#x27;)     &#123;        res = x-y;    &#125;    else    &#123;        cout &lt;&lt; &quot;非法输入&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n结果为：\n请输入计算式(用空格隔开，只能算加减):3 / 2非法输入结果为：0\n可以看到程序已经能判断输入是否有问题了，但是还有点小问题。在输入非法的时候，程序不应该输出结果。这时有三种解决方法\n\n\n将输出结果的代码放到每个代码块中\n\n\n在最后的else中加入一个return 0;直接停止代码的运行\n\n\n用一个标志位来判断是否调用输出语句\n\n\n单独使用if\nif可以被单独使用，作用就是表达式的值为true时，运行if后面的语句，表达式为false时，就什么也不做。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //实现一个加减法计算器    double x=0, y=0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开，只能算加减):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用标志位flag对是否输出结果进行判断。    bool flag = true;    //使用if else进行判断    if (op == &#x27;+&#x27;)      &#123;        res = x+y;    &#125;    else if(op == &#x27;-&#x27;)     &#123;        res = x-y;    &#125;    else    &#123;        cout &lt;&lt; &quot;非法输入&quot; &lt;&lt; endl;        flag = false;    &#125;    if (flag)        cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n运行结果：\n请输入计算式(用空格隔开，只能算加减):5 + 3结果为：8请输入计算式(用空格隔开，只能算加减):5 / 3非法输入\n可以看到通过使用标志位和单独使用if，就解决了之前的输入非法还会输出结果的问题。\nif的嵌套\nif的代码块里仍然可以使用if，这种方式就叫做嵌套。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    double x = 0, y = 0;    char op;    double res = 0;    cout &lt;&lt; &quot;请输入计算式(用空格隔开):&quot;;    cin &gt;&gt; x &gt;&gt; op &gt;&gt; y;    //使用标志位flag对是否输出结果进行判断。    bool flag = true;    if (op==&#x27;+&#x27;)    &#123;        res = x+y;    &#125;else if(op == &#x27;-&#x27;)    &#123;        res = x-y;    &#125;else if(op == &#x27;*&#x27;)    &#123;        res = x*y;    &#125;else if(op == &#x27;/&#x27;)    &#123;        if (y != 0)        &#123;            res = x/y;        &#125;else        &#123;            cout &lt;&lt; &quot;除数不能为0&quot; &lt;&lt; endl;            flag = false;        &#125;    &#125;else    &#123;        cout &lt;&lt; &quot;输入有误&quot; &lt;&lt; endl;        flag = false;    &#125;    if (flag)    &#123;        cout &lt;&lt; &quot;结果为：&quot; &lt;&lt; res;    &#125;    return 0;&#125;\n结果为：\n请输入计算式(用空格隔开):3 + 5结果为：8请输入计算式(用空格隔开):6 / 3结果为：2请输入计算式(用空格隔开):6 / 0除数不能为0\n在这个示例中，在计算除法时，我们还要保证除数不为0，因此在除法的else if语句里，我们又加上了一个if...else，来保证除数不为0。\nswitch…case\nswitch…case可以让表达式与一系列常量进行比较，并根据表达式的值执行不同的操作。\n首先介绍switch…case的整体框架\nswitch(表达式)&#123;    case 常量A:        //执行语句        break;    case 常量B:        //执行语句        break;    ...    default:        //执行语句        break;&#125;\nswitch后面的括号中需要有一个表达式，表达式的值会被用来与下面的常量A、常量B…进行比较，如果相等，就会从当前常量下面的代码开始执行，执行到break;语句为止。如果没有常量与表达式的值相等，就会执行default下面的语句。\n\nswitch表达式的结果必须是整数类型（int、char、enum等）或可以隐式转换为整数类型的类型。不能直接使用浮点数（float、double）或字符串（string）作为switch表达式。\n\n要说明的是：break并不是switch结构的一部分，也就是说break;是可以被删掉的。break语句的作用是打断当前的switch结构的执行，让程序跳出switch。\nswitch语句并不像if…else一样，只执行符合条件的判断的下面的语句。switch更像是让代码跳到对应的标签处，依次向下执行(也就是说如果常量A下面的代码没有break，程序会继续执行常量B下面的代码，直到运行完switch或见到一个break)。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 2;    switch (a)    &#123;    case 1:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;1&quot; &lt;&lt; endl;        break;    case 2:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;2&quot; &lt;&lt; endl;        break;    case 3:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;3&quot; &lt;&lt; endl;        break;    case 4:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;4&quot; &lt;&lt; endl;        break;    default:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;default&quot; &lt;&lt; endl;        break;    &#125;    return 0;&#125;\n上面的代码运行结果为：\n标签为：2\n如果将break都去掉\n#include &lt;iostream&gt;using namespace std;int main()&#123;    int a = 2;    switch (a)    &#123;    case 1:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;1&quot; &lt;&lt; endl;        //break;    case 2:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;2&quot; &lt;&lt; endl;        //break;    case 3:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;3&quot; &lt;&lt; endl;        //break;    case 4:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;4&quot; &lt;&lt; endl;        //break;    default:        cout &lt;&lt; &quot;标签为：&quot; &lt;&lt; &quot;default&quot; &lt;&lt; endl;        //break;    &#125;    return 0;&#125;\n运行结果为：\n标签为：2标签为：3标签为：4标签为：default\n这个结果也印证了上面所说的，break是用来打断程序继续执行switch。\n","categories":["C++"],"tags":["C++"]},{"title":"CPP控制程序流程(下)","url":"/2026/01/02/CPP%E6%8E%A7%E5%88%B6%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B-%E4%B8%8B/","content":"这一节来介绍C++中的循环语句。假设你要打印100次&quot;Hello World&quot;，按照前面的方法，就是写100次cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;，这种操作费时费力，这时候就可以使用循环，它可以用几行代码完成重复性工作，让代码更简洁。\ngoto\ngoto语句是C++中最原始的控制流语句，现在的编程中几乎很难看到它的身影，也不推荐在程序中使用它，但是还是作为了解。\n#include &lt;iostream&gt;using namespace std;int main() &#123;    int count = 1;    start_loop:  // 这是一个标签    cout &lt;&lt; &quot;当前计数: &quot; &lt;&lt; count &lt;&lt; endl;    count++;        if (count &lt;= 5) &#123;        goto start_loop;  // 跳转回标签处    &#125;        cout &lt;&lt; &quot;循环结束！&quot; &lt;&lt; endl;    return 0;&#125;\n可以看到goto的用法就是跳转到标签处，循环只是它的一个用法，也可以用来跳过某些语句。\n现在的程序中，只有在一些特殊情况下需要跳出多层嵌套循环时才有可能使用。\nwhile循环\nwhile循环适合用在不确定循环次数，但是知道循环继续的条件的情况下，它的特点是先判断，后执行。基本语法是\nwhile (条件表达式) &#123;    // 循环体&#125;\n下面是一个求和的示例代码：\n#include &lt;iostream&gt;using namespace std;int main() &#123;    int i = 1;        // 计算1到10的和    int sum = 0;    while (i &lt;= 10) &#123;        sum += i;        cout &lt;&lt; &quot;加上 &quot; &lt;&lt; i &lt;&lt; &quot;，当前和为: &quot; &lt;&lt; sum &lt;&lt; endl;        i++;  // 别忘了递增，否则会死循环！    &#125;        cout &lt;&lt; &quot;1到10的总和是: &quot; &lt;&lt; sum &lt;&lt; endl;    return 0;&#125;\n在代码中，while会先判断后面的表达式是否为真(true)，为真就会进入循环体，且每运行完一次循环体，while又会在判断一下表达式的值，直到表达式的值为假(false)，就不再执行循环体。\n\n在编写循环体时，要确保条件可以变为false。\n\ndo…while\ndo...while与while循环类似，但是它的特点是先执行，后循环。这也就代表着循环体至少会被执行一次。基本语法是\ndo &#123;    // 循环体&#125; while (条件表达式);\n下面是一个模拟ATM的示例代码\n#include &lt;iostream&gt;using namespace std;int main() &#123;    char choice;        do &#123;        cout &lt;&lt; &quot;===== 菜单 =====&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;1. 查看余额&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;2. 转账&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;3. 退出&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;请选择 (1-3): &quot;;        cin &gt;&gt; choice;                switch(choice) &#123;            case &#x27;1&#x27;:                cout &lt;&lt; &quot;您的余额是: $1000.00&quot; &lt;&lt; endl;                break;            case &#x27;2&#x27;:                cout &lt;&lt; &quot;转账功能暂未开放&quot; &lt;&lt; endl;                break;            case &#x27;3&#x27;:                cout &lt;&lt; &quot;感谢使用，再见！&quot; &lt;&lt; endl;                break;            default:                cout &lt;&lt; &quot;无效选择，请重新输入！&quot; &lt;&lt; endl;        &#125;        cout &lt;&lt; endl;    &#125; while (choice != &#x27;3&#x27;);  // 当用户选择3时退出循环        return 0;&#125;\n可以看到，无论如何，ATM都要先执行一次循环体，然后直到用户选择3时，程序才能退出。由于无论如何都要先执行一次循环体，因此适合使用do...while\n\n适合在用户交互系统使用\n\nfor\nfor循环是C++中最常用的，功能最强大的循环。它将初始化、条件判断和迭代更新三个部分集中在一个语句中，让代码更加清晰。基本语法是\nfor (初始化; 条件表达式; 迭代更新) &#123;    // 循环体&#125;\n下面是for循环的几种常见的用法的示例代码\n#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123;    // 示例1：简单的计数循环    cout &lt;&lt; &quot;=== 乘法表 ===&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= 9; i++) &#123;        for (int j = 1; j &lt;= 9; j++) &#123;            cout &lt;&lt; i &lt;&lt; &quot;*&quot; &lt;&lt; j &lt;&lt; &quot;=&quot; &lt;&lt; i*j &lt;&lt; &quot;\\t&quot;;        &#125;        cout &lt;&lt; endl;    &#125;        // 示例2：遍历容器    cout &lt;&lt; &quot;\\n=== 遍历vector ===&quot; &lt;&lt; endl;    vector&lt;string&gt; fruits = &#123;&quot;苹果&quot;, &quot;香蕉&quot;, &quot;橙子&quot;, &quot;葡萄&quot;&#125;;        // 传统for循环    for (int i = 0; i &lt; fruits.size(); i++) &#123;        cout &lt;&lt; &quot;索引 &quot; &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; fruits[i] &lt;&lt; endl;    &#125;        // C++11及以后的范围for循环（更简洁！）    cout &lt;&lt; &quot;\\n使用范围for循环:&quot; &lt;&lt; endl;    for (const auto&amp; fruit : fruits) &#123;        cout &lt;&lt; &quot;水果: &quot; &lt;&lt; fruit &lt;&lt; endl;    &#125;        return 0;&#125;\n从上面的示例可以看出，在需要固定的循环次数时，优先选择for循环\n\n\n\n在for循环中定义的变量(int i)只在循环内部生效\n\n\nfor循环中，括号里的三个部分都可以为空，但是分号不能省略，也就是for(;;)，它的作用相当于while(true)，是个死循环\n\n\n示例中的最后一种方法是遍历容器的最佳实践\n\n\n在遍历容器时，不要在循环体内修改容器的大小，这可能导致未定义行为(容器后面会讲)\n\n\n\n循环控制语句\nbreak\n立即终止当前循环，跳出循环体。\n#include &lt;iostream&gt;using namespace std;int main() &#123;    cout &lt;&lt; &quot;寻找第一个能被7整除的数:&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= 100; i++) &#123;        if (i % 7 == 0) &#123;            cout &lt;&lt; &quot;找到: &quot; &lt;&lt; i &lt;&lt; endl;            break;  // 找到后立即退出循环        &#125;    &#125;    return 0;&#125;\ncontinue\n跳过当前迭代，直接进入下一次循环。\n#include &lt;iostream&gt;using namespace std;int main() &#123;    cout &lt;&lt; &quot;打印1-20之间的奇数:&quot; &lt;&lt; endl;    for (int i = 1; i &lt;= 20; i++) &#123;        if (i % 2 == 0) &#123;            continue;  // 跳过偶数        &#125;        cout &lt;&lt; i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n最佳实践\n\n\n优先使用for循环\n\n\n循环的嵌套最好不要超过3层\n\n\n操作数组时务必确保不会发生数组越界\n\n\n由于浮点数存在精度问题，最好不要在循环的表达式中比较浮点数，如果一定要比较，最好是判断浮点数是否在目标的极小的范围内(比如判断是a否等于0.3时可以这样写a&gt;=0.29 &amp;&amp; a&lt;=0.31)\n\n\n","categories":["C++"],"tags":["C++"]},{"title":"CPP数组与字符串","url":"/2025/12/31/CPP%E6%95%B0%E7%BB%84/","content":"静态数组\n如果有5个类型相同，意义相近的变量，你可以用下列代码进行声明。\nint firstNum, secondNum, thirdNum, fourthNum, fifthNum;\n但是如果是100个变量，这样写的效率就极低了，此时我们可以使用数组对这些变量进行存储。\n声明和初始化\n数组的声明语法与变量类似，区别只是多了个[]用来表示要存储多少个变量。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明一个能存储5个整数类型变量的数组    int array1[5];    //声明并初始化数组    char array2[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    //声明并初始化数组    char array3[] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    return 0;&#125;\n上面的代码中，array1是能存储5个int类型的变量的数组，array2是能存储5个char类型变量的数组，并且array2通过{}和,的方式进行了初始化。array3在初始化时给出了数组里的所有元素，所以编译器自动推导了数组的长度，此时[]可以不写元素的数量。\n数组的初始化就是在{}里面，用,把每个变量的值隔开。\n\n虽然都是存储5个变量，但是array1占用的空间是$5 \\times sizeof(int)$，array2占用的空间是$5 \\times sizeof(char)$\n\n\n[]里面的数必须是整数\n\n访问数组元素\n访问数组中的某个元素，就是在[]中填入元素的索引。注意：数组的索引从0开始。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化数组    char array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    cout &lt;&lt; array1[0] &lt;&lt; array1[1] &lt;&lt; endl;    char ch1 = array1[4];    cout &lt;&lt; ch1 &lt;&lt; endl;    char ch2 = array1[5];    cout &lt;&lt; ch2 &lt;&lt; endl;    return 0;&#125;\n上面的代码的运行结果是\nabz\n可以看到array1[0]输出的结果是第一个元素a，array1[1]输出的结果是第二个元素b。这也证明了刚才所说的：数组的索引从0开始。\n在示例代码中，数组索引的取值范围是0-4，而ch2尝试读取索引为5的数组元素，运行结果是什么也没有显示。这种访问或修改数组索引范围之外的操作叫做数组越界。\n数组越界在C++中是未定义的行为，未定义的意思就是：C++没有规定如果出现了这种情况该怎么做。因此当程序中不小心出现了数组越界的问题，他导致的后果可能并不相同，这是由编译器决定的。导致的后果包括但不限于：\n\n\n程序报错\n\n\n输出一个垃圾值\n\n\n程序崩溃\n\n\n修改数组元素\n修改数组元素的方法与修改变量的值也类似。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化数组    char array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;    cout &lt;&lt; array1[0] &lt;&lt; endl;    array1[0] = &#x27;d&#x27;;    cout &lt;&lt; array1[0] &lt;&lt; endl;    return 0;&#125;\n运行结果为\nad\n可以看到array1[0]存储的值已经被更改了。\n通过上面的代码不难看出，对数组的操作与对变量的操作是类似的，只不过需要加上一个包含索引值的[]来表示你要对数组中的哪个元素进行操作。\n数组的存储\n在程序中创建一个数组时，需要指定数组的长度(长度是数组中元素的个数)，编译时，计算机会将一个连续的空间分配给这个数组，比如下面这行代码。\nchar array1[5] = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;, &#x27;c&#x27;, &#x27;z&#x27;&#125;;\n运行后，数组在内存中的结构如下图所示 \n假设这个数组的首地址(地址可以理解为内存的门牌号)为0x01(0x表示后面的数字是十六进制)，可以看到’a’的起始地址为0x01，'b’的起始地址为0x02，这是因为char类型只占1字节。\n在这张图片中，不难发现五个元素的地址是紧挨着的。这是因为数组是由计算机分配的连续的空间，而计算机读取变量值靠的是地址，数组的数据挨在一起，那么计算机只要知道第一个元素的地址，后面的元素的地址可以靠公式$address = firstAddress + index\\times sizeof(variableType)$计算得到。其中address表示我们要找的元素的地址，firstAddress表示数组第一个元素的地址，index表示要找的元素的索引(从0开始)，variableType表示变量类型。\n正是因为无论多大的数组都可以靠这个公式轻松计算得到元素的地址，计算机访问数组的速度极快，且与数组大小无关。\n多维数组\n上面说到的数组都是一维数组，数组也可以定义为多维的。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //声明并初始化多维数组    //声明一个2行3列的数组    //第一行为1，2，3；第二行为4，5，6    int array1[2][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;&#125;;     //声明一个3行2列的数组    //第一行为1，2；第二行为3，4；第三行为5，6    int array2[3][2] = &#123;&#123;1, 2&#125;, &#123;3, 4&#125;, &#123;5, 6&#125;&#125;;    //声明一个三维数组    int array3[2][3][4] = &#123;&#123;&#123;1, 2, 3, 4&#125;, &#123;4, 3, 2, 1&#125;, &#123;2, 3, 4, 1&#125;&#125;,                             &#123;&#123;1, 1, 1, 1&#125;, &#123;2, 2, 2, 2&#125;, &#123;3, 3, 3, 3&#125;&#125;&#125;;    //访问多维数组    cout &lt;&lt; array1[0][0] &lt;&lt; endl;    cout &lt;&lt; array2[2][1] &lt;&lt; endl;    cout &lt;&lt; array3[1][1][3] &lt;&lt; endl;    //修改多维数组    array1[0][0] = 2025;    array2[2][1] = 12;    array3[1][1][3] = 31;    cout &lt;&lt; array1[0][0] &lt;&lt; endl;    cout &lt;&lt; array2[2][1] &lt;&lt; endl;    cout &lt;&lt; array3[1][1][3] &lt;&lt; endl;    return 0;&#125;\n结果为\n16220251231\n判断数组是几维的最直接的方法就是看声明和使用数组时要用到几个[]，除了维度变得更高，使用方法几乎与一维数组一样。需要注意的是：多维数组在形式上是多维的，但是存储的方式仍然是一维的。\n以二维数组为例，如果数组的声明为int a[2][2];，则它的表现形式和存储形式如图所示\n因此初始化可以有两种形式\nint a[2][2] = &#123;1, 2, 3, 4&#125;;\nint a[2][2] = &#123;&#123;1, 2&#125;,                &#123;3, 4&#125;&#125;;\n第一种初始化是从内存角度出发的方式，这样可以一眼看出元素在内存中的存储形式。第二种初始化则更符合人的习惯，这样可以看出数组的表现形式。推荐使用第二种赋值方式，对于更高维的数组来说，这样的赋值方式不容易出错。\n注意事项\n对于标准的C++来说，数组的大小必须在编译期就确定，因此[]里只能是字面常量或者编译期常量表达式。\nint array1[3];  //这是用字面常量规定数组长度constexpr int MAX_SIZE = 3;int array2[MAX_SIZE];   //这是用常量表达式规定数组的长度\n也就是说，对于标准C++来说，不能用变量来规定数组的长度。\n// 错误的使用方式，因为变量是运行期确定值int a = 3;int array1[a];\n但是如果真的这样使用，编译器未必会报错，并且可以正确的完成声明的步骤。\n这是因为一些编译器（如GCC）提供了扩展支持，支持变长数组（VLA），但这并非C++的标准语法。\n动态数组\nC++提供的方案\n静态数组虽然读取速度快，但是也有自身的局限性。静态数组需要在程序开始运行前就确定数组的大小，且确定后就无法修改大小。如果一个图书馆要存储图书的数据，那肯定不能使用大小要开始就确定的静态数组，毕竟没有人知道这个图书馆最后会存储多少本书。\n这个时候就可以使用动态数组，动态数组长度不固定，可以随意添加或删除数据。并且C++提供了这种数据类型，不需要自己去实现。\n#include &lt;iostream&gt;//使用C++提供的动态数组，必须包含头文件vector#include &lt;vector&gt;using namespace std;int main()&#123;    //声明动态数组，初始长度为3，并把元素全部初始化为10    vector&lt;int&gt; dynArray(3, 10);    cout &lt;&lt; &quot;dynArray的元素个数：&quot; &lt;&lt; dynArray.size() &lt;&lt; endl;    cout &lt;&lt; dynArray[0] &lt;&lt; endl;    cout &lt;&lt; dynArray[1] &lt;&lt; endl;    cout &lt;&lt; dynArray[2] &lt;&lt; endl;    //在数组后面添加一个元素    dynArray.push_back(333);    cout &lt;&lt; &quot;dynArray的元素个数：&quot; &lt;&lt; dynArray.size() &lt;&lt; endl;    cout &lt;&lt; dynArray[0] &lt;&lt; endl;    cout &lt;&lt; dynArray[1] &lt;&lt; endl;    cout &lt;&lt; dynArray[2] &lt;&lt; endl;    cout &lt;&lt; dynArray[3] &lt;&lt; endl;    return 0;&#125;\n结果为\ndynArray的元素个数：3101010dynArray的元素个数：4101010333\n以上是C++提供的动态数组的基本操作方式，更详细的操作会在后面的STL中介绍。\n动态数组原理\n动态数组首先通过malloc函数分配初始所占空间，malloc函数只有一个参数，就是要分配的空间的大小(字节)，也就是上面代码vector&lt;int&gt; dynArray(3, 10);中的参数3，这时dynArray的空间大小为$3\\times sizeof(int)$。\n后面使用方法push_back插入了一个数据，这时，C++会调用realloc函数重新为数组分配空间，realloc函数有两个参数，一个是原本数组的地址，另一个是改变容量后的空间大小。调用了这个函数后，动态数组的空间增大，并加入了一个新元素。\n字符串\n字符串顾名思义就是许多个字符连接起来，也就是我们平时使用的文本。\n在代码中，经常会遇到需要用文本和用户交互的情况，这种情况下，如果用char就需要定义很多字符型变量。为了解决这个问题，类C语言专门制定了字符串的规范。\nC风格字符串\nC风格字符串是C语言中使用的字符串的格式，C语言的做法是用字符型数组存储字符串，并在最后加上一个'\\0'表示字符串的结尾。下面是一个C语言的示例，它与C++有些许不同，但是整体结构非常相似。\n#include &lt;stdio.h&gt;int main()&#123;    char stringArr[] = &quot;Hello World&quot;;    printf(stringArr);    return 0;&#125;\n上述代码中，stringArr看似只有11个元素，但实际上有12个元素，可以等价为\nchar stringArr[] = &#123;&#x27;H&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;, &#x27; &#x27;, &#x27;W&#x27;, &#x27;o&#x27;, &#x27;r&#x27;, &#x27;l&#x27;, &#x27;d&#x27;, &#x27;\\0&#x27;&#125;;\n这个字符串最后的'\\0'是字符串的结束字符。计算机并不认识字符串，在计算机眼中，这些只是一串二进制数，那在输出文本的时候，如何判断字符串已经结束了呢？\n答案就是当计算机看到结束字符’\\0’时，就知道字符串已经结束了。如果丢掉这个结束字符，计算机就不知道字符串已经结束了，会继续向后输出，导致数组越界。\n因此，C语言的字符串实际上是一个非常危险的设计。\nC++风格字符串\n无论是处理文本输入，还是执行拼接字符串操作，使用C++风格的字符串都是更高效、更安全的选择。\n不同于C语言的字符串数组，C++的std::string是动态的，在文本更长时它的容量将增大。\n下面是C++字符串的一些常用操作。\n#include &lt;iostream&gt;//使用字符串时，加上string头文件#include &lt;string&gt;using std::cout, std::endl, std::cin;int main()&#123;    //声明并初始化字符串    std::string helloString(&quot;Hello World&quot;);    cout &lt;&lt; helloString &lt;&lt; endl;    //读取输入的字符串    std::string firstLine;    cout &lt;&lt; &quot;请输入第一行数据：&quot;;    getline(cin, firstLine);    std::string secondLine;    cout &lt;&lt; &quot;请输入第二行数据：&quot;;    getline(cin, secondLine);    //输出读取到的内容    cout &lt;&lt; &quot;\\n输入的内容为：\\n&quot;;    cout &lt;&lt; firstLine &lt;&lt; endl;    cout &lt;&lt; secondLine &lt;&lt; endl;    //拼接两个字符串    std::string contactString = firstLine + &quot; &quot; + secondLine;    cout &lt;&lt; &quot;拼接后的字符串： &quot; &lt;&lt; contactString &lt;&lt; endl;    //复制字符串    std::string copyString;    copyString = helloString;    cout &lt;&lt; &quot;复制出来的字符串： &quot; &lt;&lt; copyString &lt;&lt; endl;    //计算字符串的长度    cout &lt;&lt; &quot;helloString的字符数量为： &quot; &lt;&lt; helloString.length() &lt;&lt; endl;    return 0;&#125;\n运行结果为\nHello World请输入第一行数据：你好请输入第二行数据：世界输入的内容为：你好世界拼接后的字符串： 你好 世界复制出来的字符串： Hello WorldhelloString的字符数量为： 11\n上面这些是常用的对字符串的操作，更详细的内容将在后面的STL部分介绍。\n","categories":["C++"],"tags":["C++"]},{"title":"环境设置","url":"/2025/12/25/%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/","content":"C++学习环境配置\nVisual Studio安装\n想要系统学习C++，Visual Studio是一个一定会被用到的软件，它是由微软（Microsoft）开发的一款功能强大、高度集成的集成开发环境（Integrated Development Environment, IDE），广泛用于 Windows 平台上的应用程序开发。它不仅支持多种编程语言（如 C#、Python、JavaScript 等），还为 C 和 C++ 开发者提供了全面的工具链支持，包括智能代码编辑、调试器、性能分析器、版本控制集成以及项目管理功能。\n下载\n点击下载链接即可进入Visual Studio的官方下载界面 \n点击社区版的免费下载(红框部分)，即可下载Visual Studio下载器，这个下载器不大，很快就可以下载下来。下载成功后，双击下载下来的.exe文件，就会进入下面的界面   \n可以根据需要选择模块来进行下载，学习C++的不知道选什么的话，可以将图中的三个选上。然后选择安装位置，将安装路径改为C盘以外的盘，因为这个软件本身占用空间较大，放在C盘可能会使电脑卡顿，另一方面，如果电脑坏了，放在非系统盘可以把数据恢复。等它安装好即可使用(有些电脑可能要先重启在使用)。\nVScode安装\n虽然Visual Studio功能强大，但是本身占用的空间比较大，而且，它一般是面向于项目，对于只想学C++的人来说，它过于笨重，因此我们可以用VScode来替代它，等到要做项目的时候在使用Visual Studio。\nVScode是微软开发的一款轻量级但功能强大的源代码编辑器，支持 Windows、macOS 和 Linux 三大主流操作系统。虽然 VS Code 本身并非传统意义上的集成开发环境（IDE），但通过安装扩展（Extensions），它可以轻松转变为功能完备的 C++ 开发工具。配合官方提供的 C/C++ 扩展，VS Code 能提供智能代码补全（IntelliSense）、语法高亮、代码导航、重构支持、调试集成（通过 GDB 或 LLDB）等专业级功能。同时，它原生支持 CMake、Makefile 以及任务（Tasks）和启动（Launch）配置，使项目构建与调试流程高度自动化。\n对于 C++ 初学者或希望在多平台（如 Linux 或嵌入式开发）下工作的开发者来说，VS Code 是一个灵活且高效的选择。它不捆绑特定编译器，而是依赖系统已安装的工具链（如 GCC、Clang 或 MinGW），因此配置更具自由度，也更贴近真实开发环境。此外，其内置终端、Git 集成、主题自定义和远程开发能力（如 Remote - SSH、WSL）进一步提升了开发体验。\n下载\n可以在vscode官方网站下载软件，如果下载速度比较慢的话，可以用迅雷下载，或者通过国内镜像下载。\n插件\n打开VScode后，在界面的左边打开插件界面 \n打开后可以看到已经安装的插件，红框框住的就是要下载的插件 \n在上面的搜索栏中搜索插件的名字，即可进行下载，这里还推荐一个与C++无关的插件\n这个插件可以让你的文件有不同的图标，让界面看起来更美观，提升工作效率。效果如下图所示。\n\n配置C/C++编译器\n目前最常用的 C/C++ 编译器主要有 GCC、MSVC 和 Clang。其中，GCC 和 Clang 具备良好的跨平台支持，而 MSVC 主要面向 Windows 平台，在其他系统上的使用较为受限。GCC 在 Linux 系统及嵌入式开发中被广泛采用，是这些领域事实上的标准工具链。考虑到 C++ 的主要应用场景（如系统编程、嵌入式开发、服务器后端等）大多集中在 Linux 和嵌入式环境，因此选择 GCC 作为 C++ 编译器是一个自然且实用的选择。\n安装MinGW\n到MinGW的GitHub主页下载MinGW \n如果无法进入GitHub，可以通过镜像下载，选择下载安装包可参考上一张图\n下载好后解压下载的压缩包，可以得到一个文件夹\n双击打开，进入里面的bin文件夹，复制文件夹的地址\n下一步配置环境变量，按下WIN+R，输入sysdm.cpl，然后按下回车，然后点击高级，点击环境变量，找到Path，点击新建，将刚才复制的地址粘贴进去\n按下WIN+R，输入cmd，然后按下回车，输入\ngcc -vg++ -v\n出现下面的消息说明安装成功。\n配置VScode\n在任意地方建立一个空文件夹，这个空文件夹可以用来作为学习C++时存储代码的文件夹，自行起一个名字(路径里最好不要有中文，因为有些软件是不支持中文路径的，中文路径可能导致软件运行出错，VScode虽然没有这个问题，但还是要养成使用英文路径的习惯)。有两种在该文件夹打开VScode的方法：\n通过命令行打开\n鼠标点击地址栏，输入cmd\n按下回车，会打开命令行，此时命令行的地址就在当前文件夹，输入\ncode .\n按下回车，就在VScode中打开了当前文件夹，在Linux系统中，也可以通过这种方式打开当前文件夹\n右键打开\n可以直接在文件夹空白处右键，选择通过Code打开，即可直接在VScode中打开当前文件夹。\n创建一个C++文件\n点击左上角的资源管理器，点击新建文件，输入文件的名字，在后面加上.cpp后缀，.cpp表示这是一个C++代码文件，就像C代码文件后缀是.c，python代码文件后缀是.py一样。\n在创建的C++文件里输入以下代码\n#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n插件设置\n点开插件界面，右键点击Code Runner，点击设置\n找到Run in Terminal，将它选上。\n运行代码\n回到cpp文件界面，点击鼠标右键，点击Run Code，即可运行\n运行后结果如图所示\n如果中文出现乱码，可以修改settings.json，在Code Runner插件中找到在settings.json中编辑\n在settings.json中进行修改\n可以直接将下面这三行代码替换图中指的三行\n&quot;c&quot;: &quot;cd $dir &amp;&amp; gcc -fexec-charset=GBK $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,&quot;zig&quot;: &quot;zig run&quot;,&quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ -fexec-charset=GBK $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,\n说明\n这种配置方法是最简单的方法，不能使用断点调试，如果想要使用断点调试，可以参考vscode配置C/C++环境\n参考资料\nvscode配置C/C++环境\n","categories":["C++"],"tags":["C++","tools"]},{"title":"CPP运算符","url":"/2026/01/01/CPP%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"元\n首先介绍元，元表示操作的个数，也就是一个运算符需要几个操作数才能完成运算。例如赋值符号=,它的用法是a=3，在这个过程中，a是它的一个操作数，3也是它的操作数，所以=是二元运算符。再比如! flag，其中的!也是一个运算符(下面会讲)，但是它只有一个操作数’flag’，因此它是一元运算符。\n左值和右值\n在C++中，左值一般是指向一个内存单元的，它一般可修改，可寻址，可持久。\n右值一般是临时对象，它一般不可寻址，短暂存在，不可修改。\na = 7;\n在上面这个语句中，a指向内存中的一个地址，且可以长期存在，因此它是左值；而7则是一个临时的值，这个语句结束后就会被销毁，因此它是右值。\n示例代码\n在前面的章节中，已经简单的介绍过了几个运算符，这一节是更详细的展开。\n这一部分将围绕C++中的运算符展开，这里会先给出本节的完整的示例代码，方便复制粘贴。\n#include &lt;iostream&gt;using namespace std;int main()&#123;    //加减乘除和取模    cout &lt;&lt; &quot;===== 1. 加减乘除和取模运算符 =====&quot; &lt;&lt; endl;    int a = 10, b = 3;    cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; &quot; (加法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; &quot; (减法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; &quot; (乘法)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; / &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a / b &lt;&lt; &quot; (除法，整数除法会截断小数部分)&quot; &lt;&lt; endl;    cout &lt;&lt; a &lt;&lt; &quot; % &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a % b &lt;&lt; &quot; (取模，取余数)&quot; &lt;&lt; endl;        double c = 10.0, d = 3.0;    cout &lt;&lt; c &lt;&lt; &quot; / &quot; &lt;&lt; d &lt;&lt; &quot; = &quot; &lt;&lt; c / d &lt;&lt; &quot; (浮点数除法，保留小数)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //递增和递减运算符    cout &lt;&lt; &quot;===== 2. 递增和递减运算符 =====&quot; &lt;&lt; endl;    int num = 5;    cout &lt;&lt; &quot;初始值: num = &quot; &lt;&lt; num &lt;&lt; endl;        num++; // 等价于 num = num + 1    cout &lt;&lt; &quot;num++ 后: num = &quot; &lt;&lt; num &lt;&lt; endl;        num--; // 等价于 num = num - 1    cout &lt;&lt; &quot;num-- 后: num = &quot; &lt;&lt; num &lt;&lt; endl;    cout &lt;&lt; endl;        //递增(递减)运算符的前缀和后缀    cout &lt;&lt; &quot;===== 3. 递增(递减)运算符的前缀和后缀 =====&quot; &lt;&lt; endl;    int x = 10;        // 后缀形式：先使用值，再递增    cout &lt;&lt; &quot;后缀 x++: &quot;;    cout &lt;&lt; &quot;x++ = &quot; &lt;&lt; x++ &lt;&lt; &quot; (先输出x的值，再递增)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;递增后 x = &quot; &lt;&lt; x &lt;&lt; endl;        // 前缀形式：先递增，再使用值    cout &lt;&lt; &quot;前缀 ++x: &quot;;    cout &lt;&lt; &quot;++x = &quot; &lt;&lt; ++x &lt;&lt; &quot; (先递增，再输出x的值)&quot; &lt;&lt; endl;        int y = 20;    cout &lt;&lt; &quot;后缀 y--: &quot;;    cout &lt;&lt; &quot;y-- = &quot; &lt;&lt; y-- &lt;&lt; &quot; (先输出y的值，再递减)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;递减后 y = &quot; &lt;&lt; y &lt;&lt; endl;        cout &lt;&lt; &quot;前缀 --y: &quot;;    cout &lt;&lt; &quot;--y = &quot; &lt;&lt; --y &lt;&lt; &quot; (先递减，再输出y的值)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //相等运算符和不等运算符    cout &lt;&lt; &quot;===== 4. 相等运算符和不等运算符 =====&quot; &lt;&lt; endl;    int m = 15, n = 15, p = 20;        cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m == n ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m == p ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m != n ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;    cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m != p ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;        //关系运算符    cout &lt;&lt; &quot;===== 5. 关系运算符 =====&quot; &lt;&lt; endl;    int val1 = 25, val2 = 30;        cout &lt;&lt; val1 &lt;&lt; &quot; &gt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;        //逻辑运算符    cout &lt;&lt; &quot;===== 6. 逻辑运算符 =====&quot; &lt;&lt; endl;    bool flag1 = true, flag2 = false;        cout &lt;&lt; &quot;flag1 = &quot; &lt;&lt; (flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag2 = &quot; &lt;&lt; (flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        cout &lt;&lt; &quot;flag1 &amp;&amp; flag2 (逻辑与): &quot; &lt;&lt; (flag1 &amp;&amp; flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag1 || flag2 (逻辑或): &quot; &lt;&lt; (flag1 || flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag1 (逻辑非): &quot; &lt;&lt; (!flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag2 (逻辑非): &quot; &lt;&lt; (!flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        // 逻辑运算符的短路特性    int test = 0;    cout &lt;&lt; &quot;短路特性示例 (false &amp;&amp; ...): &quot; &lt;&lt; (false &amp;&amp; (test = 5)) &lt;&lt; endl;    cout &lt;&lt; &quot;test 的值: &quot; &lt;&lt; test &lt;&lt; &quot; (因为短路，赋值没有执行)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //按位运算符    cout &lt;&lt; &quot;===== 7. 按位运算符 =====&quot; &lt;&lt; endl;    unsigned int bits1 = 6;  // 二进制: 0110    unsigned int bits2 = 3;  // 二进制: 0011        cout &lt;&lt; bits1 &lt;&lt; &quot; &amp; &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 &amp; bits2) &lt;&lt; &quot; (按位与)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; | &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 | bits2) &lt;&lt; &quot; (按位或)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; ^ &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 ^ bits2) &lt;&lt; &quot; (按位异或)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;~&quot; &lt;&lt; bits1 &lt;&lt; &quot; = &quot; &lt;&lt; (~bits1) &lt;&lt; &quot; (按位取反，注意符号位)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &lt;&lt; 1 = &quot; &lt;&lt; (bits1 &lt;&lt; 1) &lt;&lt; &quot; (左移1位，相当于乘以2)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &gt;&gt; 1 = &quot; &lt;&lt; (bits1 &gt;&gt; 1) &lt;&lt; &quot; (右移1位，相当于除以2)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;        //复合赋值运算符    cout &lt;&lt; &quot;===== 8. 复合赋值运算符 =====&quot; &lt;&lt; endl;    int compound = 10;        cout &lt;&lt; &quot;初始值: compound = &quot; &lt;&lt; compound &lt;&lt; endl;    compound += 5;  // compound = compound + 5    cout &lt;&lt; &quot;compound += 5 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound -= 3;  // compound = compound - 3    cout &lt;&lt; &quot;compound -= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound *= 2;  // compound = compound * 2    cout &lt;&lt; &quot;compound *= 2 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound /= 4;  // compound = compound / 4    cout &lt;&lt; &quot;compound /= 4 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound %= 3;  // compound = compound % 3    cout &lt;&lt; &quot;compound %= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        int bitwise = 12; // 二进制: 1100    bitwise &amp;= 10;    // 10是1010，按位与后：1000 (8)    cout &lt;&lt; &quot;bitwise &amp;= 10 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise |= 3;     // 3是0011，按位或后：1011 (11)    cout &lt;&lt; &quot;bitwise |= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise ^= 1;     // 1是0001，按位异或后：1010 (10)    cout &lt;&lt; &quot;bitwise ^= 1 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &lt;&lt;= 2;    // 左移2位：101000 (40)    cout &lt;&lt; &quot;bitwise &lt;&lt;= 2 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &gt;&gt;= 3;    // 右移3位：101 (5)    cout &lt;&lt; &quot;bitwise &gt;&gt;= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;    cout &lt;&lt; endl;        //sizeof运算符    cout &lt;&lt; &quot;===== 9. sizeof运算符 =====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(double) = &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(bool) = &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;        int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; &quot;数组 arr 的大小: sizeof(arr) = &quot; &lt;&lt; sizeof(arr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = &quot;          &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; &quot; 个&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;sizeof(10) = &quot; &lt;&lt; sizeof(10) &lt;&lt; &quot; 字节 (字面量的大小)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(10 + 3.14) = &quot; &lt;&lt; sizeof(10 + 3.14) &lt;&lt; &quot; 字节 (表达式的结果类型大小)&quot; &lt;&lt; endl;        return 0;&#125;\n加减乘除与取模\n//加减乘除和取模cout &lt;&lt; &quot;===== 1. 加减乘除和取模运算符 =====&quot; &lt;&lt; endl;int a = 10, b = 3;cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; &quot; (加法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; &quot; (减法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; &quot; (乘法)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; / &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a / b &lt;&lt; &quot; (除法，整数除法会截断小数部分)&quot; &lt;&lt; endl;cout &lt;&lt; a &lt;&lt; &quot; % &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a % b &lt;&lt; &quot; (取模，取余数)&quot; &lt;&lt; endl;double c = 10.0, d = 3.0;cout &lt;&lt; c &lt;&lt; &quot; / &quot; &lt;&lt; d &lt;&lt; &quot; = &quot; &lt;&lt; c / d &lt;&lt; &quot; (浮点数除法，保留小数)&quot; &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 1. 加减乘除和取模运算符 =====10 + 3 = 13 (加法)10 - 3 = 7 (减法)10 * 3 = 30 (乘法)10 / 3 = 3 (除法，整数除法会截断小数部分)10 % 3 = 1 (取模，取余数)10 / 3 = 3.33333 (浮点数除法，保留小数)\n这里的运算符与计算器上的一致，只需要注意\n\n\n如果是两个整数类型的变量或两个整数字面常量(也就是没有小数点)进行除法运算，小数部分会被直接舍去。\n\n\n如果其中一个是浮点数，那么计算出来的就是浮点数。\n\n\n递增与递减\n//递增和递减运算符cout &lt;&lt; &quot;===== 2. 递增和递减运算符 =====&quot; &lt;&lt; endl;int num = 5;cout &lt;&lt; &quot;初始值: num = &quot; &lt;&lt; num &lt;&lt; endl;num++; // 等价于 num = num + 1cout &lt;&lt; &quot;num++ 后: num = &quot; &lt;&lt; num &lt;&lt; endl;num--; // 等价于 num = num - 1cout &lt;&lt; &quot;num-- 后: num = &quot; &lt;&lt; num &lt;&lt; endl;cout &lt;&lt; endl;//递增(递减)运算符的前缀和后缀cout &lt;&lt; &quot;===== 3. 递增(递减)运算符的前缀和后缀 =====&quot; &lt;&lt; endl;int x = 10;// 后缀形式：先使用值，再递增cout &lt;&lt; &quot;后缀 x++: &quot;;cout &lt;&lt; &quot;x++ = &quot; &lt;&lt; x++ &lt;&lt; &quot; (先输出x的值，再递增)&quot; &lt;&lt; endl;cout &lt;&lt; &quot;递增后 x = &quot; &lt;&lt; x &lt;&lt; endl;// 前缀形式：先递增，再使用值cout &lt;&lt; &quot;前缀 ++x: &quot;;cout &lt;&lt; &quot;++x = &quot; &lt;&lt; ++x &lt;&lt; &quot; (先递增，再输出x的值)&quot; &lt;&lt; endl;int y = 20;cout &lt;&lt; &quot;后缀 y--: &quot;;cout &lt;&lt; &quot;y-- = &quot; &lt;&lt; y-- &lt;&lt; &quot; (先输出y的值，再递减)&quot; &lt;&lt; endl;cout &lt;&lt; &quot;递减后 y = &quot; &lt;&lt; y &lt;&lt; endl;cout &lt;&lt; &quot;前缀 --y: &quot;;cout &lt;&lt; &quot;--y = &quot; &lt;&lt; --y &lt;&lt; &quot; (先递减，再输出y的值)&quot; &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 2. 递增和递减运算符 =====初始值: num = 5num++ 后: num = 6num-- 后: num = 5===== 3. 递增(递减)运算符的前缀和后缀 =====后缀 x++: x++ = 10 (先输出x的值，再递增)递增后 x = 11前缀 ++x: ++x = 12 (先递增，再输出x的值)后缀 y--: y-- = 20 (先输出y的值，再递减)递减后 y = 19前缀 --y: --y = 18 (先递减，再输出y的值)\n先看第一部分的代码，可以看到++和--可以使变量+1或者-1，这就是自增和自减运算符的作用。\n再看第二段代码，可以看到自增和自减运算符可以放在变量前面和变量后面。放在变量前面会先进行递增(减)，然后被使用；放在变量后面会先被使用，然后再递增(减)。\n相等与不等\n//相等运算符和不等运算符cout &lt;&lt; &quot;===== 4. 相等运算符和不等运算符 =====&quot; &lt;&lt; endl;int m = 15, n = 15, p = 20;cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m == n ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; == &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m == p ? &quot;相等&quot; : &quot;不相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; n &lt;&lt; &quot; : &quot; &lt;&lt; (m != n ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;cout &lt;&lt; m &lt;&lt; &quot; != &quot; &lt;&lt; p &lt;&lt; &quot; : &quot; &lt;&lt; (m != p ? &quot;不相等&quot; : &quot;相等&quot;) &lt;&lt; endl;cout &lt;&lt; endl;\n运行结果为\n===== 4. 相等运算符和不等运算符 =====15 == 15 : 相等15 == 20 : 不相等15 != 15 : 相等15 != 20 : 不相等\n在C++中，=表示赋值，==表示判断左值和右值是否相等，相等返回true，否则返回false。\n!=则相反，如果左值和右值相等，则返回false，否则返回true。\n在代码中还可以看到一种运算符?  : ，这叫做三元运算符，因为它需要三个操作数，格式为\n条件表达式 ? 表达式1 : 表达式2\n它会首先计算条件表达式，如果条件表达式返回true，则计算并返回表达式1的值；如果条件表达式返回false，则计算并返回表达式2的值\n\n在C++中，表达式的值只要不是0，就可以表示true；表达式的值是0则表示false。\n\n关系运算符\n//关系运算符    cout &lt;&lt; &quot;===== 5. 关系运算符 =====&quot; &lt;&lt; endl;    int val1 = 25, val2 = 30;        cout &lt;&lt; val1 &lt;&lt; &quot; &gt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt; &quot;  &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt; val2  ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &gt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &gt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; val1 &lt;&lt; &quot; &lt;= &quot; &lt;&lt; val2 &lt;&lt; &quot; : &quot; &lt;&lt; (val1 &lt;= val2 ? &quot;真&quot; : &quot;假&quot;) &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 5. 关系运算符 =====25 &gt; 30 : 假25 &lt; 30 : 真25 &gt;= 30 : 假25 &lt;= 30 : 真\n关系运算符返回的结果是true和false。只要左值和右值满足关系运算符的关系，就会返回true，否则返回false。代码中的&lt;表示小于号，&gt;表示大于号，&lt;=表示小于等于号，&gt;=表示大于等于号。\n逻辑运算符\n//逻辑运算符    cout &lt;&lt; &quot;===== 6. 逻辑运算符 =====&quot; &lt;&lt; endl;    bool flag1 = true, flag2 = false;        cout &lt;&lt; &quot;flag1 = &quot; &lt;&lt; (flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag2 = &quot; &lt;&lt; (flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        cout &lt;&lt; &quot;flag1 &amp;&amp; flag2 (逻辑与): &quot; &lt;&lt; (flag1 &amp;&amp; flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;flag1 || flag2 (逻辑或): &quot; &lt;&lt; (flag1 || flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag1 (逻辑非): &quot; &lt;&lt; (!flag1 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;    cout &lt;&lt; &quot;!flag2 (逻辑非): &quot; &lt;&lt; (!flag2 ? &quot;true&quot; : &quot;false&quot;) &lt;&lt; endl;        // 逻辑运算符的短路特性    int test = 0;    cout &lt;&lt; &quot;短路特性示例 (false &amp;&amp; ...): &quot; &lt;&lt; (false &amp;&amp; (test = 5)) &lt;&lt; endl;    cout &lt;&lt; &quot;test 的值: &quot; &lt;&lt; test &lt;&lt; &quot; (因为短路，赋值没有执行)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 6. 逻辑运算符 =====flag1 = trueflag2 = falseflag1 &amp;&amp; flag2 (逻辑与): falseflag1 || flag2 (逻辑或): true!flag1 (逻辑非): false!flag2 (逻辑非): true短路特性示例 (false &amp;&amp; ...): 0test 的值: 0 (因为短路，赋值没有执行)\n可以直接用布尔类型bool的变量来表示true和false。\n接下来介绍与、或、非。与&amp;&amp;表示符号两边的表达式都为true，才会返回true；或||(键盘上是shift+\\ )表示符号两边的表达式任一为true，就会返回true；非!表示符号后面的表达式的结果的相反结果，当后面的表达式结果为true时，就会返回false。\n接下来介绍一下逻辑运算符的短路特性，也就是说：逻辑运算符两边的表达式不是同时计算的，当第一个计算的表达式的结果可以决定最后结果时，另一个表达式就不会被计算。\n逻辑运算符&amp;&amp;和||都是先计算左边表达式的值，如果是下列情况：false &amp;&amp; ...、true || ...，则右侧的表达式不会被计算。\n按位运算符\n//按位运算符    cout &lt;&lt; &quot;===== 7. 按位运算符 =====&quot; &lt;&lt; endl;    unsigned int bits1 = 6;  // 二进制: 0110    unsigned int bits2 = 3;  // 二进制: 0011        cout &lt;&lt; bits1 &lt;&lt; &quot; &amp; &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 &amp; bits2) &lt;&lt; &quot; (按位与)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; | &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 | bits2) &lt;&lt; &quot; (按位或)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; ^ &quot; &lt;&lt; bits2 &lt;&lt; &quot; = &quot; &lt;&lt; (bits1 ^ bits2) &lt;&lt; &quot; (按位异或)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;~&quot; &lt;&lt; bits1 &lt;&lt; &quot; = &quot; &lt;&lt; (~bits1) &lt;&lt; &quot; (按位取反，注意符号位)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &lt;&lt; 1 = &quot; &lt;&lt; (bits1 &lt;&lt; 1) &lt;&lt; &quot; (左移1位，相当于乘以2)&quot; &lt;&lt; endl;    cout &lt;&lt; bits1 &lt;&lt; &quot; &gt;&gt; 1 = &quot; &lt;&lt; (bits1 &gt;&gt; 1) &lt;&lt; &quot; (右移1位，相当于除以2)&quot; &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n6 &amp; 3 = 2 (按位与)6 | 3 = 7 (按位或)6 ^ 3 = 5 (按位异或)~6 = 4294967289 (按位取反，注意符号位)6 &lt;&lt; 1 = 12 (左移1位，相当于乘以2)6 &gt;&gt; 1 = 3 (右移1位，相当于除以2)\n数据在计算机中是用二进制存储的，数据在被标示成二进制后，就可以对每一位进行操作。\n\n\n按位与&amp;表示对数据的每一位都进行与操作，某一位上都为1的依然为1，否则这一位为0。\n\n\n按位或|表示对数据的每一位都进行或操作，某一位上任一数据是1则为1，全是0的位仍然是0。\n\n\n按位异或^表示对数据的每一位都进行异或操作，某一位上都为同为1或同为0的为0，否则这一位为1(相同为0，不同为1)。\n\n\n按位取反~表示对数据的每一位都进行取反操作，为1的位变为0，为0的位变成1。\n\n\n左移&lt;&lt;表示对数据的每一位都向左移动1位，末尾补0。这个操作相当于将原数据$\\times 2$。\n\n\n右移&gt;&gt;表示对数据的每一位都向右移动1位，开头补0。这个操作相当于将原数据$\\div 2$\n\n\n复合赋值运算符\n//复合赋值运算符    cout &lt;&lt; &quot;===== 8. 复合赋值运算符 =====&quot; &lt;&lt; endl;    int compound = 10;        cout &lt;&lt; &quot;初始值: compound = &quot; &lt;&lt; compound &lt;&lt; endl;    compound += 5;  // compound = compound + 5    cout &lt;&lt; &quot;compound += 5 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound -= 3;  // compound = compound - 3    cout &lt;&lt; &quot;compound -= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound *= 2;  // compound = compound * 2    cout &lt;&lt; &quot;compound *= 2 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound /= 4;  // compound = compound / 4    cout &lt;&lt; &quot;compound /= 4 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        compound %= 3;  // compound = compound % 3    cout &lt;&lt; &quot;compound %= 3 后: compound = &quot; &lt;&lt; compound &lt;&lt; endl;        int bitwise = 12; // 二进制: 1100    bitwise &amp;= 10;    // 10是1010，按位与后：1000 (8)    cout &lt;&lt; &quot;bitwise &amp;= 10 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise |= 3;     // 3是0011，按位或后：1011 (11)    cout &lt;&lt; &quot;bitwise |= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise ^= 1;     // 1是0001，按位异或后：1010 (10)    cout &lt;&lt; &quot;bitwise ^= 1 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &lt;&lt;= 2;    // 左移2位：101000 (40)    cout &lt;&lt; &quot;bitwise &lt;&lt;= 2 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;        bitwise &gt;&gt;= 3;    // 右移3位：101 (5)    cout &lt;&lt; &quot;bitwise &gt;&gt;= 3 后: bitwise = &quot; &lt;&lt; bitwise &lt;&lt; endl;    cout &lt;&lt; endl;\n运行结果为\n===== 8. 复合赋值运算符 =====初始值: compound = 10compound += 5 后: compound = 15compound -= 3 后: compound = 12compound *= 2 后: compound = 24compound /= 4 后: compound = 6compound %= 3 后: compound = 0bitwise &amp;= 10 后: bitwise = 8bitwise |= 3 后: bitwise = 11bitwise ^= 1 后: bitwise = 10bitwise &lt;&lt;= 2 后: bitwise = 40bitwise &gt;&gt;= 3 后: bitwise = 5\n复合赋值就是将一些运算符与赋值运算符=连接在一起使用，这些运算符一般都是二元运算符，复合之后的效果相当于将变量自身的值进行对应的操作后再赋值给变量自身。\nsizeof\n//sizeof运算符    cout &lt;&lt; &quot;===== 9. sizeof运算符 =====&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(int) = &quot; &lt;&lt; sizeof(int) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(double) = &quot; &lt;&lt; sizeof(double) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(char) = &quot; &lt;&lt; sizeof(char) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(bool) = &quot; &lt;&lt; sizeof(bool) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;        int arr[5] = &#123;1, 2, 3, 4, 5&#125;;    cout &lt;&lt; &quot;数组 arr 的大小: sizeof(arr) = &quot; &lt;&lt; sizeof(arr) &lt;&lt; &quot; 字节&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = &quot;          &lt;&lt; sizeof(arr)/sizeof(arr[0]) &lt;&lt; &quot; 个&quot; &lt;&lt; endl;        cout &lt;&lt; &quot;sizeof(10) = &quot; &lt;&lt; sizeof(10) &lt;&lt; &quot; 字节 (字面量的大小)&quot; &lt;&lt; endl;    cout &lt;&lt; &quot;sizeof(10 + 3.14) = &quot; &lt;&lt; sizeof(10 + 3.14) &lt;&lt; &quot; 字节 (表达式的结果类型大小)&quot; &lt;&lt; endl;\n运行结果为\n===== 9. sizeof运算符 =====sizeof(int) = 4 字节sizeof(double) = 8 字节sizeof(char) = 1 字节sizeof(bool) = 1 字节数组 arr 的大小: sizeof(arr) = 20 字节数组 arr 的元素个数: sizeof(arr)/sizeof(arr[0]) = 5 个sizeof(10) = 4 字节 (字面量的大小)sizeof(10 + 3.14) = 8 字节 (表达式的结果类型大小)\nsizeof在前面讲过，这里不再细讲，可以看看代码进行回忆。\n优先级\n正如加减乘除要先算乘除后算加减一样，C++中的运算符也是有优先级的区分的，下面是优先级的表格，数字越小表示优先级越高，数字越大表示优先级越低。\n\n\n\n等级\n名称\n运算符\n\n\n\n\n1\n作用域解析运算符\n::\n\n\n2\n成员选择、下标、后缀递增和后缀递减\n.、-&gt;、()、++、–\n\n\n3\nsizeof、前缀递增和递减、求补、逻辑NOT、单目加和减、取址和解除引用、new、new[]、delete、delete[]、类型转换、sizeof()\n++、–、~、!、+、-、&amp;、*、()\n\n\n4\n用于指针的成员选择\n.、-&gt;\n\n\n5\n乘、除、求模\n*、/、%\n\n\n6\n加、减\n+、-\n\n\n7\n移位（左移和右移）\n&lt;&lt;、&gt;&gt;\n\n\n8\n不等关系\n&lt;、&lt;=、&gt;、&gt;=\n\n\n9\n相等关系\n==、!=\n\n\n10\n按位AND\n&amp;\n\n\n11\n按位XOR\n^\n\n\n12\n按位OR\n|\n\n\n13\n逻辑AND\n&amp;&amp;\n\n\n14\n逻辑OR\n||\n\n\n15\n条件运算符\n?:\n\n\n16\n赋值运算符\n=、*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&amp;=、|=、^=\n\n\n17\n逗号运算符\n,\n\n\n\n这个表格非常的复杂，记忆起来非常困难，因此，一般我们不会根据这个表格进行编程，我们会将我们想要优先进行的运算用()包裹，这样一来，运行的顺序就会非常的直观，我们只需要记住优先级比()高的运算符即可。\n","categories":["C++"],"tags":["C++"]},{"title":"C++程序组成","url":"/2025/12/25/%E7%A8%8B%E5%BA%8F%E7%BB%84%E6%88%90/","content":"C++程序组成\nC++ 的语法与 C 语言高度相似，最初确实是作为 C 语言的扩展而诞生的。然而，随着时间的发展，C++ 已演变为一门独立且功能丰富的编程语言。作为一门支持面向对象编程（OOP）的语言，C++ 引入了许多 C 语言所不具备的特性，其中最具代表性的是面向对象的三大核心特征：封装、继承和多态。此外，C++ 的标准库也与 C 语言有显著不同，例如提供了标准模板库（STL）、更安全的字符串和容器类型等。因此，即便已经掌握了 C 语言，也不应轻视 C++ 的复杂性和深度，而应将其视为一门全新的语言来系统学习。\nC++程序基本构成\n以下面这个简单的C++程序为例\n//头文件#include &lt;iostream&gt;//主函数int main()&#123;    //功能    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    //返回值    return 0;&#125;  \n首先是头文件#include &lt;iostream&gt;，#include &lt;&gt;是C++引入头文件的语法，iostream则是头文件的文件名，头文件可以理解为实现了某些功能的文件，引入头文件才能在自己的代码中使用这些功能。iostream是C++提供的标准库。\n下面是主函数部分，语法为\nint main()&#123;    return 0;&#125;  \n主函数是程序的入口点，首先是int main()，这是函数头，int表示这个函数的返回值的类型是整数，main是函数的名字，main 函数可以定义为带参数的形式int main(int argc, char* argv[])，用于接收命令行参数。花括号{}括住的部分是这个函数的代码块，return 0;表示返回一个数字0，这个返回值是个整数，与int main()中的int对应。一般来说，函数返回了0表示程序成功执行并正常退出，非零返回值（包括 -1）通常表示程序执行出错或异常退出。\n接下来是编写函数功能的代码\nstd::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;\n这两行代码的含义是输出两行文本到命令行，第一行是&quot;Hello World&quot;，第二行是&quot;你好，世界&quot;。\nstd是一个命名空间，它的作用是：避免全局作用域中的名称冲突，例如当代码里有两个地方分别写了同一个相同名称的函数(函数是完成某个固定功能的代码块，通过名称区分)，但是他们的代码不同，那么在使用这个函数时，编译器会不知道到底调用哪里的函数，这时就可以使用命名空间来区分它们。\nstd::cout的含义就是使用std命名空间中的cout函数(这里其实并不正确，cout是std中定义的一个流，但是现在这样更好理解)。&lt;&lt;是流插入运算符，意思是把运算符后面的内容插入到运算符前面的流中。std::endl作用是换行和刷新输出缓冲区。\n要使用std::cout和std::endl必须包含头文件#include &lt;iostream&gt;，因为它们定义在iostream文件中。\n\n需要注意的是：C++中每一条语句后面都要加分号;，可以看到在代码中，只有#include &lt;iostream&gt;并没有加分号，因为预处理指令并不是 C++ 语句。\n\n最后介绍一下C++的注释，//是注释符号，//后面一整行的内容都是注释部分，注释在程序中起到解释代码含义的作用，它并不会被编译器编译，也就是说，在编译器的眼中，这个代码是这个样子的\n#include &lt;iostream&gt;int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n另外，也可以使用多行注释，格式是/* 这里写注释 */，例如\n#include &lt;iostream&gt;/*我可以跨多行，只要在这两个符号中间的都是注释*/int main()&#123;    std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;//我只负责这一行    std::cout &lt;&lt; &quot;你好，世界&quot; &lt;&lt; std::endl;    return 0;&#125;\n命名空间\n在前面介绍代码的基本结构时，已经简单介绍过命名空间，总而言之，命名空间是为了避免全局作用域中的名称冲突，这里面的名称冲突并不仅仅包含函数名，也包括变量名，也包括流等等。\n在学习C++时，写的代码比较简单，一般不会出现命名冲突，这个时候可以简化写法\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    return 0;&#125;\n可以看到，使用了using namespace std声明了std这个命名空间后，写cout和endl时就不需要在前面明确std了。\n但是这样有时会无法确定std命名空间中的其他名称是否会发生冲突，因此更推荐的用法是\n#include &lt;iostream&gt;//using namespace std;using std::cout, std::endl;int main()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    return 0;&#125;\n这个示例中，通过使用using，也实现了简化写法的功能。二者的区别是：前者可以在使用std中定义的所有内容都无需加std::；后者只有cout和endl可以不加std::。\n函数\n函数能够将应用程序划分成多个功能单元，程序员通常需要编写自己的函数。\n下面是一个使用函数的示例\n#include &lt;iostream&gt;using std::cout, std::endl;//声明函数int sum(int a, int b);int main()&#123;    int x=1,y=2;        //这里是定义了两个整数类型的变量，并给他们赋值为1和2    cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; sum(x,y) &lt;&lt; endl; //函数可以在其他语句中被调用    int result = sum(x,y);              //函数的返回值可以被赋值给变量    cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; result &lt;&lt; endl;   //将变量输出    cout &lt;&lt; &quot;1+2=&quot; &lt;&lt; sum(1,2) &lt;&lt; endl; //传递给函数的不一定是变量，也可以是常量    return 0;&#125;//定义函数，函数需要传递两个整数(int)int sum(int a, int b)&#123;    int res = a+b;  //使用两个变量进行求和运算    return res;     //返回计算结果&#125;\n使用函数前要先声明函数，可以理解为这是在告诉编译器：我有这样一个函数，名字是sum，返回值是整数类型，需要传递两个整数类型的参数，虽然我现在还没有告诉你它里面具体做了什么，但是我在后面会告诉你，你不要报错。\n在后面要定义函数，用{}包裹住的是这个函数的实现步骤。\n\n若函数定义在 main 之前，则无需单独声明。\n\nIO操作\nI表示输入，O表示输出。在写代码时，不能仅仅考虑输出结果(通过cout输出)，还要考虑如何读取用户的输入，读取输入的语法与输出结果类似。\n#include &lt;iostream&gt;//定义IOfunc函数int IOfunc()&#123;    int a, b;    std::cout &lt;&lt; &quot;请输入两个整数（用空格分开）：&quot;;    //读取用户输入的整数，将其放到变量a和b中    std::cin &gt;&gt; a &gt;&gt; b;    std::cout &lt;&lt; &quot;您输入的第一个数是：&quot; &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;您输入的第二个数是：&quot; &lt;&lt; b &lt;&lt; std::endl;    return 0;&#125;int main()&#123;    //调用IOfunc函数    IOfunc();    return 0;&#125;\n运行结果为\n请输入两个整数（用空格分开）：3 99您输入的第一个数是：3您输入的第二个数是：99\n读取输入使用std::cin，后面使用提取运算符&gt;&gt;，将输入流中的数据提取到变量中。输入的数据之间要通过空格隔开，按下回车就相当于输入完毕，代码才会继续向后执行。\n运算符\nC++中有多种运算符，例如前面用到的&lt;&lt;和&gt;&gt;，这里先介绍常用的算术运算符\n\n\n\n运算符\n描述\n实例\n\n\n\n\n+\n把两个操作数相加\nA+B（10+20）将得到30\n\n\n-\n从第一个操作数中减去第二个操作数\nA-B（10-20）将得到-10\n\n\n*\n把两个操作数相乘\nA*B（10x20）将得到200\n\n\n/\n分子除以分母\nB/A（20/10）将得到2\n\n\n%\n取模运算符，整除后的余数\nB%A（20%10）将得到0\n\n\n++\n自增运算符，整数值增加1\nA++将得到11\n\n\n--\n自减运算符，整数值减少1\nA--将得到9\n\n\n\n\n=并不是相等的运算符，在C++中，这表示赋值，也就是将=右边赋值给=左边。\n\n","categories":["C++"],"tags":["C++"]}]